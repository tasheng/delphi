+TITLE.
C Skeleton Analysis Program  Version 2.0/01
+PATCH,PSTITLE. ========================================================
************************************************************************
*-----------------------------------------------------------------------
*
*        SKELANA - XShort/Full DST skeleton analysis program
*
*
*-----------------------------------------------------------------------
************************************************************************
+PATCH,PSMAIN.==========================================================
+DECK,PSMAIN. **********************************************************
      PROGRAM PSMAIN
************************************************************************
*                                                                      *
*     Name           :  PSMAIN                                         *
*     Called by      :  Main                                           *
*     Date of coding :  Jan 18, 1992                                   *
*     Last update    :  Nov 25, 1993                                   *
*     Task           :  Main routine                                   *
*                                                                      *
************************************************************************
*
*--   PHDST package initialization
*
      CALL PHDST (' ',   0, IFLAG)
*
      END
*
+DECK,USER00. **********************************************************
      SUBROUTINE USER00
************************************************************************
*                                                                      *
*     Name           :  USER00                                         *
*     Called by      :  PHINIT                                         *
*     Date of coding :  Oct 23, 1993                                   *
*     Last update    :  Mar 07, 1995                                   *
*     Task           :  User initialization                            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCRNQ.
+CDE, PSCUTT.
*
*--   Skelana initialization
      CALL PSINI
*
*--   Change the default values
*--   of control flags and keys
      IFLBSP = 2
      IFLBTG = 2
*
*     Print the chosen flag values and track selection cuts:
*
      WRITE (*,1000) IFLTRA,IFLODR,IFLVEC,IFLSTR,IFLCUT,
     +               IFLRVR,IFLSIM,IFLBSP,IFLBTG,IFLPVT,
     +               IFLVDR,IFLFCT,IFLRNQ,IFLBHP,IFLUTE,
     +               IFLVDH,IFLMUO,IFLECL,IFLELE,IFLEMC,
     +               IFLPHO,IFLPHC,IFLSTC,IFLHAC,IFLHAD,
     +               IFLRV0,IFLJET,IFLENR

*
      IF (IFLCUT.LT.1. .OR. IFLCUT.GT.NCUT) THEN
        IFLCUT = 3
        WRITE (*,1002) IFLCUT
      ENDIF
      IF (IFLSTR.GT.0) THEN
        WRITE (*,1001) TRKMOM(IFLCUT),TRKMAX(IFLCUT),TRKERR(IFLCUT),
     +                 TRKRPH(IFLCUT),TRKZET(IFLCUT),TRKLEN(IFLCUT),
     +                 TRCCOS(IFLCUT),VDONLY(IFLCUT),IDVDWZ(IFLCUT),
     +                 IHADRJ(IFLCUT),ISTOEL(IFLCUT),
     +                 EHPC(IFLCUT)  ,EFEMC(IFLCUT) ,EHAC(IFLCUT),
     +                 ESTIC(IFLCUT) ,TRNCOS(IFLCUT),
     +                 RECCAL(IFLCUT)

      ELSE
       WRITE(*,*) 'No Track Selection applied'
      ENDIF
*
+SELF,IF=-NOIFLENR.
*
*--   Read the energy correction  2000
      IF ( IFLENR .GT. 0 ) CALL PSENRG
*
+SELF.
+SELF,IF=-NOIFLBHP.
*
*--   Read the bad 1997 HPC event list
      IF ( IFLBHP .GT. 0 ) CALL PSBHPC
*
+SELF.
+SELF,IF=-NOIFLRNQ.
*
*--   Change the default acceptance conditions for
*--   detectors/triggers of the "RUNQUALITY" files
*
      IF ( IFLRNQ .GT. 0 ) THEN
*
*--      MVX_A and MVX_C
         IRQDMN(1) = 1
         IRQDMN(2) = 1
*
*--      TPC_0 and TPC_1
         IRQDMN(5) = 7
         IRQDMN(6) = 7
*
*--      Read the runquality files
         CALL PSRUNQ(0)
      ENDIF
+SELF.
*
*--   Put your initialization code here...
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSMAIN-I-USER00, ','SKELANA flags for this run:',/,
     +       /,1X,'IFLTRA = ',I3,
     +       /,1X,'IFLODR = ',I3,
     +       /,1X,'IFLVEC = ',I3,
     +       /,1X,'IFLSTR = ',I3,
     +       /,1X,'IFLCUT = ',I3,
     +       /,1X,'IFLRVR = ',I3,
     +       /,1X,'IFLSIM = ',I3,
     +       /,1X,'IFLBSP = ',I3,
     +       /,1X,'IFLBTG = ',I3,
     +       /,1X,'IFLPVT = ',I3,
     +       /,1X,'IFLVDR = ',I3,
     +       /,1X,'IFLFCT = ',I3,
     +       /,1X,'IFLRNQ = ',I3,
     +       /,1X,'IFLBHP = ',I3,
     +       /,1X,'IFLUTE = ',I3,
     +       /,1X,'IFLVDH = ',I3,
     +       /,1X,'IFLMUO = ',I3,
     +       /,1X,'IFLECL = ',I3,
     +       /,1X,'IFLELE = ',I3,
     +       /,1X,'IFLEMC = ',I3,
     +       /,1X,'IFLPHO = ',I3,
     +       /,1X,'IFLPHC = ',I3,
     +       /,1X,'IFLSTC = ',I3,
     +       /,1X,'IFLHAC = ',I3,
     +       /,1X,'IFLHAD = ',I3,
     +       /,1X,'IFLRV0 = ',I3,
     +       /,1X,'IFLJET = ',I3,
     +       /,1X,'IFLENR = ',I3,
     +       /)

 1001 FORMAT(/,1X,'%PSMAIN-I-USER00, '
     &  ,'track selection cuts for this run:',/,
     +       /,1X,'TRKMOM = ',E10.4,
     +       /,1X,'TRKMAX = ',E10.4,
     +       /,1X,'TRKERR = ',E10.4,
     +       /,1X,'TRKRPH = ',E10.4,
     +       /,1X,'TRKZET = ',E10.4,
     +       /,1X,'TRKLEN = ',E10.4,
     +       /,1X,'TRCCOS = ',E10.4,
     +       /,1X,'VDONLY = ',I3,
     +       /,1X,'IDVDWZ = ',I3,
     +       /,1X,'IHADRJ = ',I3,
     +       /,1X,'ISTOEL = ',I3,
     +       /,1X,'EHPC   = ',E10.4,
     +       /,1X,'EFEMC  = ',E10.4,
     +       /,1X,'EHAC   = ',E10.4,
     +       /,1X,'ESTIC  = ',E10.4,
     +       /,1X,'TRNCOS = ',E10.4,
     +       /,1X,'RECCAL = ',E10.4,
     +  /)
 1002 FORMAT(/,1X,'%PSMAIN-E-USER00, '
     &  ,'unknown track selection cuts,'
     &  ,' set ',I3,' as default',/)
      END
*
+DECK,USER01. **********************************************************
      SUBROUTINE USER01(NEED)
************************************************************************
*                                                                      *
*     Name           :  USER01                                         *
*     Called by      :  PHNEED                                         *
*     Date of coding :  Jan 18, 1992                                   *
*     Last update    :  Mar 15, 1994                                   *
*     Task           :  General event analysis                         *
*                                                                      *
*     Output         :  NEED = 1 the event is     needed               *
*                       NEED = 0 the event is NOT needed               *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCBHP.
*
*--   arguments
      INTEGER NEED
*
*--   functions
      INTEGER IPHPIC,JBIT
      CHARACTER*4 PHRTY
*
*--   local variables
      INTEGER     IDENT
      CHARACTER*4 RECTYP
+SELF,IF=-NOIFLRNQ.
      INTEGER IRSEL
+SELF.
+SELF,IF=-NOIFLBHP.
      INTEGER I
+SELF.
*
      NEED   = 0
*
*--   Check the record type
      RECTYP = PHRTY()
*
*--   Skip the unwanted records
      IF     ( RECTYP .EQ. 'RAW ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'TAN ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'SOR ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'COR ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'EOR ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'SOS ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'EOS ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'BOF ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. 'CPT ' ) THEN
         GO TO 99
      ELSE IF( RECTYP .EQ. '0072' ) THEN
         GO TO 99
      ENDIF
*
      IF ( RECTYP .NE. 'DST ' ) THEN
         WRITE(*,1000) RECTYP,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
*--   Maximum  number of events
*      IF ( NEVENT .GT. 10 ) THEN
*         NEED = -3
*         GO TO 99
*      ENDIF

*
      IF ( RECTYP .EQ. 'DST ' ) THEN
*
*--      Pilot record information
         IDENT = IPHPIC ('IDEN',1)
         IF ( IDENT .GE. 0 ) THEN
*--         Hadronic selection
            IHAD4 = 0
            IF(JBIT(IPILOT(IDENT+6),1) .EQ. 1  .AND.
     +         JBIT(IPILOT(IDENT+6),2) .EQ. 1) IHAD4 = 1
         ENDIF
*
+SELF,IF=-NOIFLRNQ.
*--      Run quality selection
         IF ( IFLRNQ .GT. 0  .AND.
     +        IIIRUN .GT. 0 ) THEN
            CALL PSRUNS(IRSEL)
         ENDIF
*
+SELF.
+SELF,IF=-NOIFLBHP.
*--      Skip the bad 97 HPC events
         IF ( IFLBHP .GT. 0 ) THEN
            IF ( IIIRUN .GE. IRNBAD(     1)  .AND.
     +           IIIRUN .LE. IRNBAD(NEVBAD) ) THEN
               DO I = 1, NEVBAD
                  IF ( IIIRUN .EQ. IRNBAD(I)  .AND.
     +                 IIIEVT .EQ. IEVBAD(I) ) THEN
                     NEED = 0
                     GO TO 99
                  ENDIF
               ENDDO
            ENDIF
         ENDIF
+SELF.
*--      Event selection (an example)
CCC      IF ( IRSEL .EQ. 1  .AND.
CCC  +        IHAD4 .NE. 0 ) NEED = 1
*
      NEED = 1
*
      ENDIF
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSMAIN-E-USER01, ','Event not in any DST format'
     +      ,/,1X,'                  ','Record type',A4
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,USER02. **********************************************************
      SUBROUTINE USER02
************************************************************************
*                                                                      *
*     Name           :  USER02                                         *
*     Called by      :  PHPROC                                         *
*     Date of coding :  Nov 18, 1993                                   *
*     Last update    :  Mar 07, 1995                                   *
*     Task           :  To access the event for analysis               *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.                                                                
+CDE, PSCEVT.
+CDE, PSCTRA.
+CDE, PSCEMF.
+CDE, PSCHPC.
+CDE, PSCSTC.
+CDE, PSCHAC.
+CDE, PSCLUJ.

*
      INTEGER I, IERR
*
*
*--- (re)fill skelana commons
      CALL PSBEG

*---  Dump event information as plain text
      PRINT *, "--------------------------"
      WRITE(*,98)      "HAPPY CHECK: EVENT :",IIIRUN,":",IIIEVT
      WRITE(*,97)      "CHECK: ECM     :",ECMAS
      WRITE(*, 99)     "CHECK: TRACKS :", NVECP
      DO I=1, NVECP
         WRITE(*, *)  I, VECP(7,I), VECP(1,I),VECP(2,I),
     $        VECP(3,I), VECP(4,I), QEMF(8,I), QHPC(8,I),
     $        QHAC(8,I), QSTIC(1,I), LVLOCK(I)
      ENDDO
      WRITE(*, 104)     "CHECK: GEN :", NP
      DO I=1, NP
         WRITE(*, *)  I, KP(I,2), PP(I,1), PP(I,2),
     $        PP(I,3), PP(I,4), PP(I,5), KP(I,1)
      ENDDO
 97   FORMAT(A,F10.2)
 98   FORMAT(A,I10,A,I10)
 99   FORMAT(A,I10)
* 100  FORMAT(A,F12.6)
 104  FORMAT(A,I10)
* 105  FORMAT(A,I10,F12.6, F12.6, F12.6, F12.6, F12.6, F12.6,I10)
* 106  FORMAT(A,"(",F12.6,",",F12.6,",",F12.6,",",F12.6,")")
      END
*
+DECK, USER99. *********************************************************
      SUBROUTINE USER99
************************************************************************
*                                                                      *
*     Name           :  USER99                                         *
*     Called by      :  PHEND                                          *
*     Date of coding :  Aug 07, 1993                                   *
*     Last update    :  Mar 25, 1994                                   *
*     Task           :  To be called at the end of the run             *
*                                                                      *
************************************************************************
+CDE, PSCEVL.
*
*--   Close the event list files
      CLOSE(LUNMU1)
      CLOSE(LUNEL1)
      CLOSE(LUNLP2)
*
      END
*
+PATCH,PSSERV.==========================================================
+DECK,PSINI.  **********************************************************
      SUBROUTINE PSINI
************************************************************************
*                                                                      *
*     Name           :  PSINI                                          *
*     Called by      :  USER00                                         *
*     Date of coding :  Oct 23, 1993                                   *
*     Last update    :  Mar  7, 1995                                   *
*     Task           :  To be called at the beggining of the run       *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCRNQ.
+CDE, PXCONS.
+CDE, PSCUTT.
+CDE, AAPARM.
*
*--   local variables
      INTEGER IDDATE,IDTIME
      INTEGER IDATQQ,ITIMQQ
+SELF,IF=-NOIFLRNQ.
      INTEGER I
+SELF.
*
*--   Print the version
      CALL DATIME (IDDATE, IDTIME)
+SEQ, DATEQQ, TIMEQQ.
      WRITE (*,1000) IDATQQ,ITIMQQ,IDDATE,IDTIME
 1000 FORMAT(//,1X,
+SEQ, QFTITLE, N=60.
     +/1X,'Compiled ',I6.6,'.',I4.4,'  Today is',I7.6,'.',I4.4//)
*
*--   General constants
      PI   = ACOS(-1.)
      AMPI = 0.139570
*
+SELF,IF=-NOIFLVDH.
*--   VD initialization
      CALL VDIDST
*
+SELF.
*
+SELF,IF=-NOIFLBTG.
      NAMDST = 'NDEF'
+SELF.
*
*--   Set-up the default values
*--   of control flags and keys
      IFLTRA = 1
      IFLODR = 1
      IFLVEC = 22
      IFLSTR = 11
      IFLCUT = 3
      IFLRVR = 111
      IFLSIM = 1
      IFLBSP = 2
      IFLBTG = 2
      IFLPVT = 1
      IFLVDR = 1
      IFLFCT = 1
      IFLRNQ = 0
      IFLBHP = 1
      IFLUTE = 1
      IFLVDH = 1
      IFLMUO = 1
      IFLECL = 22
      IFLELE = 1
      IFLEMC = 1
      IFLPHO = 1
      IFLPHC = 1
      IFLSTC = 1
      IFLHAC = 1
      IFLHAD = 1
      IFLRV0 = 1
      IFLJET = 0
      IFLENR = 0
*
*--   Set the default track selection cuts
*
*--   Old SKELANA selection:
*
      TRKMOM(1) = 0.4
      TRKLEN(1) = 30.
      TRKRPH(1) = 4.
      TRKZET(1) = 10.
      TRCCOS(1) = 0.937
      TRKMAX(1) = 1.E+10
      TRKERR(1) = 1.
      TRNCOS(1) = 1.
      EHPC(1)   = 1.E-10
      EFEMC(1)  = 1.E-10
      EHAC(1)   = 1.E-10
      ESTIC(1)  = 1.E-10
      RECCAL(1) = 1.E+10
      VDONLY(1) = 0
      IDVDWZ(1) = 0
      IHADRJ(1) = 0
      ISTOEL(1) = 0
*
*--   May 98 tuning for 97 data
*
      TRKMOM(2) = 0.2
      TRKLEN(2) = 0.
      TRKRPH(2) = 4.
      TRKZET(2) = 4.
      TRCCOS(2) = 1.
      TRKMAX(2) = 1.5
      TRKERR(2) = 1.
      TRNCOS(2) = 1.
      EHPC(2)   = 0.5
      EFEMC(2)  = 0.4
      EHAC(2)   = 0.9
      ESTIC(2)  = 0.3
      RECCAL(2) = 5.
      VDONLY(2) = 2
      IDVDWZ(2) = 1
      IHADRJ(2) = 0
      ISTOEL(2) = 0
*
*--   April 99 tuning for 98 data (SKELANA/XSDST 1.07)
*
      TRKMOM(3) = 0.1
      TRKLEN(3) = 0.
      TRKRPH(3) = 4.
      TRKZET(3) = 4.
      TRCCOS(3) = 1.
      TRKMAX(3) = 1.5
      TRKERR(3) = 1.
      TRNCOS(3) = 1.
      EHPC(3)   = 0.3
      EFEMC(3)  = 0.4
      EHAC(3)   = 0.
      ESTIC(3)  = 0.3
      RECCAL(3) = 5.0
      VDONLY(3) = 1
      IDVDWZ(3) = 1
      IHADRJ(3) = 2
      ISTOEL(3) = 1
*
+SELF,IF=-NOIFLRNQ.
*--   Set-up the default acceptance conditions for
*--   detectors/triggers of the "RUNQUALITY" files
*
      DO I = 1, NRQDET
         IRQDET(I) = 0
         IRQDMN(I) = 0
         IRQDMX(I) = 9
      ENDDO
*
      DO I = 1, NRQT9X-2
          RQTMN(I) = 1.0E-4
          RQTMX(I) = 1.0E+0
      ENDDO
*
      DO I = NRQT9X-1, NRQT9X
         IRQTMN(I) = 0
         IRQTMX(I) = 9
      ENDDO
*
      DO I = NRQT90, NRQTRG
         IRQTMN(I) = 0
         IRQTMX(I) = 9
      ENDDO
*
+SELF.
      END
*
+DECK,PSBEG. ***********************************************************
      SUBROUTINE PSBEG
************************************************************************
*                                                                      *
*     Name           :  PSBEG                                          *
*     Called by      :  USER02                                         *
*     Date of coding :  May 24, 1994                                   *
*     Last update    :  Aug 18, 1999                                   *
*     Task           :  To be called at the beggining of each event    *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCLUJ.
+CDE, PSCTRA.
+CDE, PSCHPC.
+CDE, PSCEMF.
+CDE, PSCHAC.
+CDE, PSCSTC.
+CDE, PSCMUD.
+CDE, PSCMUV.
+CDE, PSCMUL.
+CDE, PSCMUT.
+CDE, PSCHAD.
+CDE, PSCDEX.
+CDE, PSCGRC.
+CDE, PSCLRC.
+CDE, PSCELD.
+CDE, PSCELO.
+CDE, PSCELT.
+CDE, PSCPHO.
+CDE, PSCPI0.
+CDE, PSCVDA.
+CDE, PSCVDU.
+CDE, PSCPHC.
+CDE, PXCONS.
+CDE, PSCECL.
+CDE, PSDSTYPE.
+CDE, TRACKNTP.
*
*--   functions
      INTEGER IPHPIC,JBYT
      CHARACTER*4 PHRTY
*
*--   local variables
      INTEGER LPV,LPA
      INTEGER IDENT,I,IERR
      REAL    BTESLA,BGEVCM
      CHARACTER*4 RECTYP
*

*--   Vertices
      NVTX   = 0
      NVTXMC = 0
      CALL vzeroi( KVTX, LENVTX * 2*NVTXMX )
      DO I = 1, 2*NVTXMX
         KVTX(16,I) = -1
      ENDDO
*
*--   VECP event record
      NVECP  = 0
      NCVECP = 0
      NNVECP = 0
      NVECMC = 0
      CALL vzeroi( LVLOCK(1),     3*MTRACK )
      CALL vzeroi( INVECP(1),     3*MTRACK )
      CALL uzeror( VECP(1,1),1,10*3*MTRACK )
*
*--   LUND common
      NP = 0
      CALL vzeroi( KP(1,1),   NPMAX*5 )
      CALL uzeror( PP(1,1), 1,NPMAX*5 )
      CALL uzeror( VP(1,1), 1,NPMAX*5 )
      CALL uzeror( ZF(1)  , 1,NPMAX   )
      CALL uzeror( DM(1)  , 1,NPMAX   )
*
*--   Track information
      IF ( IFLTRA .GT. 0 ) THEN
         NTRAC = 0
         CALL vzeroi( KTRAC, LENTRA*MTRACK )
      ENDIF
*
*--   Elm. calorimetry information
      IF ( IFLEMC .GT. 0 ) THEN
         NHPC = 0
         CALL vzeroi( KHPC  , LENHPC*MTRACK )
         CALL vzeror( HPCLAY, NHPLAY*MTRACK )
         NEMF = 0
         CALL vzeroi( KEMF  , LENEMF*MTRACK )
      ENDIF
*
*--   Hadron calorimetry information
      IF ( IFLHAC .GT. 0 ) THEN
         NHAC = 0
         CALL vzeroi( KHAC  , LENHAC*MTRACK )
         CALL vzeror( HACLAY, NHCLAY*MTRACK )
      ENDIF
*
*--   Muon identification
      IF ( IFLMUO .GT. 0 ) THEN
         NMUID = 0
         CALL vzeroi( KMUID, LENMUD*MTRACK )
         NMUVL = 0
         CALL vzeroi( KMUVL, LENMUV*MTRACK )
         NMULS = 0
         CALL vzeroi( KMULS, LENMUL*MTRACK )
         NMUTI = 0
         CALL vzeroi( KMUTI, LENMUT*MTRACK )
      ENDIF
*
*--   Electron identification
      IF ( IFLELE .GT. 0 ) THEN
         NELID = 0
         CALL vzeroi( KELID, LENELD*MTRACK )
         NELOU = 0
         CALL vzeroi( KELOU, LENELO*MTRACK )
         NELTR = 0
         CALL vzeroi( KELTR, LENELT*MTRACK )
      ENDIF
*
*--   Hadron identification
      IF ( IFLHAD .GT. 0 ) THEN
         NHAID  = 0
         CALL vzeroi( KHAID , LENHAD*MTRACK )
         NHAIDN = 0
         CALL vzeroi( KHAIDN, LNHADN*MTRACK )
         CALL vzeroi( KHAIDT, LNHADN*MTRACK )
         NHAIDR = 0
         CALL vzeroi( KHAIDR, LNHADR*MTRACK )
         NHAIDE = 0
         CALL vzeroi( KHAIDE, LNHADE*MTRACK )
         NHAIDC = 0
         CALL vzeroi( KHAIDC, LNHADC*MTRACK )
         NDEDX  = 0
         CALL vzeroi( KDEDX , LENDEX*MTRACK )
         NGRIC  = 0
         CALL vzeroi( KGRIC , LENGRC*MTRACK )
         NLRIC  = 0
         CALL vzeroi( KLRIC , LENLRC*MTRACK )
      ENDIF
*
*--   Photon/Pi0 identification
      IF ( IFLPHO .GT. 0 ) THEN
         NPHOT = 0
         CALL vzeroi( KPHOT, LENPHO*MTRACK )
         NPI0  = 0
         CALL vzeroi( KPI0 , LENPI0*MTRACK )
      ENDIF
*
*--   STIC showers
      IF ( IFLSTC .GT. 0 ) THEN
         NSTIC = 0
         CALL vzeroi( KSTIC, LENSTC*MTRACK )
      ENDIF
*
*--   Vertex detector hits
      IF ( IFLVDH .GT. 0 ) THEN
         NVDHT = 0
         NVDUN = 0
         CALL vzeroi( KVDUN, LENVDU*NVDUMX )
         NVDAS = 0
         CALL vzeroi( NASHT, MTRACK )
         CALL vzeroi( KVDAS, LENVDA*MTRACK*NHIT )
      ENDIF
*
*--   Photon conversion
      IF ( IFLPHC .GT. 0 ) THEN
         NPHOC = 0
         CALL uzeror( QPHOC, 1, LENPHC*NPCMAX )
      ENDIF
*
*--   REMCLU electromagnetic clusters
      IF ( IFLECL .GT. 0 ) THEN
        NEMCLU = 0
        CALL uzeror( QEMCLU, 1, LENCLU*MTRACK )
        CALL vzeroi( IEMCLU, MTRACK )
      ENDIF
*
*--   Track recovery
      INREC = 0
      CALL vzeroi(LVSELE(1), 3*MTRACK)
*
*--   Check the record type
      RECTYP = PHRTY()
*
      IF ( RECTYP .EQ. 'DST ' ) THEN
*--      Pilot record information
         IDENT = IPHPIC ('IDEN',1)
         IF ( IDENT .GT. 0 ) THEN
*--         Short/LongDST version
            ISVER = MOD(IPILOT(IDENT+4),1000)
         ELSE
            ISVER = 0
         ENDIF
      ENDIF
*
*     Protection for REMCLU in PV-PA
*     Force the only meaningful mode in this case
*
      IF (ISVER.GE.108 .AND. IFLECL.GT.0) IFLECL = 11
*
      IF (IFLVEC.EQ.3 .AND. ISVER.LT.108) IFLVEC = 2
*
      IF ( RECTYP .EQ. 'DST ' ) THEN
*
*--      Define the B field values
         CALL BPILOT(BTESLA,BGEVCM)

         IF ( ISVER .GT. 0 ) THEN
+SELF,IF=-NOPSHORT.
*
*--         PV  vertex bank address
            IF (LDTOP.LE.0)  RETURN
            LPV=LQ(LDTOP-1)
*
*--         Loop over the particles
            DO WHILE ( LPV .NE. 0 )
               LPA = LQ( LPV -  1 )
               DO WHILE ( LPA .NE. 0 )
*
*--               Create module (8) for tracks to
*                 secondary hadronic interactions
                  IF ( JBYT(IQ(LPA+3), 19, 7) .EQ. 120 ) THEN
                     CALL MAKEMOD8( LPA, .FALSE., IERR )
                  ENDIF
*
                  LPA = LQ(LPA)
               ENDDO
               LPV = LQ(LPV)
            ENDDO
*
            FULLDST=.FALSE. ! short DST event
            CALL PSHORT
+SELF.
         ELSE
+SELF,IF=-NOPSFULL.
            CALL PSFULL
+SELF.
         ENDIF
      ELSE
         WRITE(*,1000) IIIRUN,IIIEVT,NEVENT
      ENDIF
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSMAIN-E-PSBEG, ','Event not in any of DST formats'
     +      ,/,1X,'                 ','Run',I7,', Event',I6,' /',I6,/)
      END
*
+DECK,PSJETS. ************************************************************
      SUBROUTINE PSJETS(IALGO,DJOIN,MASK,IERR)
**************************************************************************
*                                                                        *
*     Name           :  PSJETS                                           *
*     Called by      :  USER02                                           *
*     Date of coding :  Mars 24, 1995                                    *
*     Last update    :  Sept 12, 1997                                    *
*     Task           :  To interface the jets reconstruction             *
*                       of JETSET and VECSUB                             *
*                                                                        *
*     Input          :  IALGO - cluster finding algorithm:               *
*                               0 = No jet reconstruction                *
*                                 - Jet reconstruction with              *
*                                   LUCLUS pre-clusterisation            *
*                               1 = LUCLUS standard                      *
*                               2 = JADE  with scaled invariant mass     *
*                               3 = LUCLUS no re-association             *
*                               4 = JADE  with fixed invariant mass      *
*                                 - Jet reconstruction with              *
*                                   exact minimisation (see VECSUB)      *
*                               5 = JADE   (PUYCLU)                      *
*                               6 = DURHAM (PUDCLU)                      *
*                               7 = PUJET4                               *
*                                 - Thrust or Sphericity                 *
*                              1x = Don't compute the thrust             *
*                             1xx = Don't compute the sphericity         *
*                                                                        *
*                       DJOIN - distance scale  to join  two clusters,   *
*                               its exact definition and usage depends   *
*                               on the cluster finding algorithm         *
*                       MASK  - track selection mask to use in  LVLOCK   *
*                                                                        *
*     Output         :  IERR  - error diagnostic:                        *
*                               0     - successful  completion           *
*                               bit 1 - no jet  reconstruction           *
*                               bit 2 - no thrust axis defined           *
*                               bit 3 - no sphericity  defined           *
*                                                                        *
*     Remarks        :  1) To fix the number of jets to reconstruct one  *
*                          should update MSTU(47) in LUDAT1 common with  *
*                          the required value. For default = 0 the num-  *
*                          ber of jets is left free ( except for PUJET4  *
*                          where the jet number is always 4 ).           *
*                       2) The thrust  and  sphericity are computed  by  *
*                          default for backward compatibility. To avoid  *
*                          it add 10 (100) to IALGO.                     *
*                                                                        *
**************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCVECJJ.
      INTEGER MSTU,MSTJ
      REAL    PARU,PARJ
+CDE, LUDAT1.
*
*--   arguments
      INTEGER IALGO,MASK,IERR
      REAL    DJOIN
*
*--   functions
      INTEGER IAND
*
*--   local variables
      INTEGER LTRACK,NTRACK
      INTEGER IALGOR,MINP
      INTEGER NV,NHEM1,NHEM2
      REAL    SPH,APL,THR,OBL
      REAL    YMIN,TGEN,DMIN,EMAX1,EMAX2
*
*--   Initialisation
      IALGOR = MOD(IALGO, 10)
      IF (IALGOR .GT. 0) NJET = 0
                         IERR = 0
*
*--   Cluster finding algorithm
      IF     ( IALGOR .EQ. 1 ) THEN
         MSTU(46) = 1
         PARU(44) = DJOIN
      ELSEIF ( IALGOR .EQ. 3 ) THEN
         MSTU(46) = 2
         PARU(44) = DJOIN
      ELSEIF ( IALGOR .EQ. 4 ) THEN
         MSTU(46) = 3
         PARU(44) = DJOIN
      ELSEIF ( IALGOR .EQ. 2 ) THEN
         MSTU(46) = 4
         PARU(45) = DJOIN
      ELSEIF ( IALGOR .GT. 7)  THEN
         WRITE(*,1000)
         GO TO 99
      ENDIF
*
*--   Track selection
      IF ( MASK .EQ. 0 ) THEN
         LTRACK = 1
         NTRACK = NVECP
      ELSE
         IF ((3*MTRACK-LVWORK) .LT. NVECP) THEN
            WRITE(*,1100)  IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
*
         LTRACK = LVWORK + 1
         NTRACK = 0
         CALL PZERX( LTRACK, LTRACK+NVECP )
*
         DO NV = 1, NVECP
            IF ( IAND(LVLOCK(NV), MASK) .EQ. 0 ) THEN
               CALL ucopyr( VECP(1,NV), VECP(1,LTRACK+NTRACK), 10 )
               NTRACK = NTRACK + 1
            ENDIF
         ENDDO
*
         IF ( NTRACK .LE. 0 ) THEN
            WRITE(*,1200) IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
      ENDIF
*
*--   Jets reconstruction
      IF (IALGOR.GT.0) THEN
         CALL PZERX ( LVJET+1, LVJET+20 )
*
         IF      (IALGOR .LT. 5) THEN
            CALL PUCLUS(LTRACK,NTRACK,LVJET+1,NJET,TGEN,DMIN )
            MSTU(47) = 1
         ELSE IF (IALGOR .EQ. 5) THEN
            CALL PUYCLU(LTRACK,NTRACK,LVJET+1,NJET,DJOIN,MSTU(47)
     +                 ,MINP,YMIN)
         ELSE IF (IALGOR .EQ. 6) THEN
            CALL PUDCLU(LTRACK,NTRACK,LVJET+1,NJET,DJOIN,MSTU(47)
     +                 ,MINP,YMIN)
         ELSE IF (IALGOR .EQ. 7) THEN
            IF (MASK .NE. 0) THEN
               WRITE(*,1300) IIIRUN,IIIEVT,NEVENT
               GO TO 99
            ENDIF
            CALL PUJET4(LTRACK,NTRACK,LVWORK+1,1000,IERR)
            IF (IERR .EQ. 0) THEN
               NJET = 4
               CALL ucopyr( VECP(1,LVWORK+1), VECP(1,LVJET+1), 40 )
            ENDIF
         ENDIF
         IF ( NJET .LE. 0 )  IERR = 1
      ENDIF
*
*--   Thrust axis
      IF ( MOD(INT(IALGO/10),10) .EQ. 0 ) THEN
         CALL PZERX ( LVTHRU+1,LVTHRU+3 )
         CALL PUTHRU( LTRACK, NTRACK, LVTHRU+1, THR, OBL, 1. )
*
        IF ( THR  .LE. 0 ) IERR = IERR + 2
      ENDIF
*
*--   Sphericity axis
      IF ( MOD(INT(IALGO/100),10) .EQ. 0) THEN
         CALL PZERX ( LVSPHE+1,LVSPHE+3 )
         CALL PUSPHE( LTRACK, NTRACK, LVSPHE+1, SPH, APL, 2.,
     +                NHEM1, NHEM2, EMAX1, EMAX2 )
*
        IF ( SPH  .LE. 0 ) IERR = IERR + 4
      END IF
*
*--   Update the  IVECP(10,I)
      IF ( MASK .NE. 0 ) THEN
         NTRACK = 0
         DO NV = 1, NVECP
            IF ( IAND(LVLOCK(NV), MASK) .EQ. 0 )  THEN
               IVECP(10,NV) = IVECP(10,LTRACK + NTRACK)
               NTRACK = NTRACK + 1
            ENDIF
         ENDDO
      ENDIF
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(1X,'%PSSERV-E-PSJETS, ','Wrong cluster finding algorithm')
 1100 FORMAT(1X,'%PSSERV-E-PSJETS, ','The working area is too small  '
     +    ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
 1200 FORMAT(1X,'%PSSERV-E-PSJETS, ','No tracks have been selected   '
     +    ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
 1300 FORMAT(1X,'%PSSERV-E-PSJETS, ','PUJET4 cannot run with MASK # 0'
     +    ,/,1X,'                  ','due to working area limitation,'
     +    ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSEVTL. **********************************************************
      SUBROUTINE PSEVTL
************************************************************************
*                                                                      *
*     Name           :  PSEVTL                                         *
*     Called by      :  USER02                                         *
*     Date of coding :  May 24, 1994                                   *
*     Last update    :  Jun 11, 1994                                   *
*     Task           :  To produce event list(s) of selected events    *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVL.
*
*--   functions
      INTEGER LPHPA,JBY

*
      PRINT*, IIIRUN, IIIEVT

      END
*
+DECK,PSENRG. **********************************************************
      SUBROUTINE PSENRG
************************************************************************
*                                                                      *
*     Name           :  PSENRG                                         *
*     Called by      :  USER00                                         *
*     Date of coding :  Apr 25, 2000                                   *
*     Last update    :  Apr 25, 2000                                   *
*     Task           :  To read the energy correction for Y2K          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCENR.
*
*--   functions
      INTEGER LENOCC
*
*--   local variables
      INTEGER LUNHPI,IOS,LLINE
      CHARACTER*80 CHLINE
*
*--   Read the online energy table
      NRFCOR = 0
      LUNHPI = 13
*
*--   Open the I/O files
      CALL PHOPEN(LUNHPI,'ENERGY.DAT',' ',' ',IOS)
      IF ( IOS .NE. 0 ) THEN
         WRITE(*,1100)
         GO TO 99
      ENDIF
*
 10   CONTINUE
+SELF,IF= IBMVM.
      CHLINE = ' '
      READ(LUNHPI,NUM=LLINE,END=20) CHLINE
+SELF,IF=-IBMVM.
      CHLINE = ' '
      READ(LUNHPI,'(A)',END=20) CHLINE
+SELF.
      LLINE = LENOCC(CHLINE)
      IF ( LLINE .EQ. 0 ) GO TO 10
      IF (CHLINE(22:25) .EQ. 'Mini') GOTO 10
*
      IF ( NRFCOR .GE. MRFCOR ) THEN
         WRITE(*,1200) MRFCOR
         GO TO 20
      ELSE
          NRFCOR = NRFCOR + 1
      ENDIF
*
      READ(CHLINE( 1: 6),'( I6 )') NRUN_FROM(NRFCOR)
      READ(CHLINE( 8: 9),'( I2 )') NFIL_FROM(NRFCOR)
      READ(CHLINE(11:16),'( I6 )') NRUN_TO  (NRFCOR)
      READ(CHLINE(18:19),'( I2 )') NFIL_TO  (NRFCOR)
      READ(CHLINE(22:28),'(F7.3)') ECMASS   (NRFCOR)
*
      GO TO 10
   20 CONTINUE
      CLOSE(LUNHPI)
   99 CONTINUE
 1100 FORMAT(//1X,'%PSMAIN-I-PSENRG, File ENERGY.DAT not open')
 1200 FORMAT(//1X,'%PSMAIN-I-PSENRG, More then ',I5,' run/files')
      END
*
+DECK,PSECOR. **********************************************************
      SUBROUTINE PSECOR(ENCORR)
************************************************************************
*                                                                      *
*     Name           :  PSECOR                                         *
*     Called by      :  PSHEVT                                         *
*     Date of coding :  Apr 25, 2000                                   *
*     Last update    :  Apr 25, 2000                                   *
*     Task           :  To correct the wrong energy for Y2K            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCENR.
*
*--   arguments
      REAL   ENCORR
*
*--   local variables
      INTEGER NC
*
      DO NC = 1,NRFCOR
         IF ( IIIRUN .GE. NRUN_FROM(NC)  .AND.
     +        IIIRUN .LE. NRUN_TO  (NC)) THEN
            IF ( IIIRUN .EQ. NRUN_FROM(NC)  .AND.
     +           IIFILE .LT. NFIL_FROM(NC)) GO TO 10
            IF ( IIIRUN .EQ. NRUN_TO  (NC)  .AND.
     +           IIFILE .GT. NFIL_TO  (NC)) GO TO 10
            ENCORR = ECMASS(NC)
         ENDIF
   10    CONTINUE
      ENDDO
*
      END
*
+DECK,PSBHPC. **********************************************************
      SUBROUTINE PSBHPC
************************************************************************
*                                                                      *
*     Name           :  PSBHPC                                         *
*     Called by      :  USER00                                         *
*     Date of coding :  Jun 19, 1998                                   *
*     Last update    :  Jun 19, 1998                                   *
*     Task           :  To read the bad HPC event file                 *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCBHP.
*
*--   functions
      INTEGER LENOCC
*
*--   local variables
      INTEGER LUNHPI,IOS,LLINE
      CHARACTER*80 CHLINE
*
*--   Read the bad 1997 HPC events
      NEVBAD = 0
      LUNHPI = 13
*
*--   Open the I/O files
      CALL PHOPEN(LUNHPI,'BAD_EVENTS97.LIST',' ',' ',IOS)
      IF ( IOS .NE. 0 ) THEN
         WRITE(*,1100)
         GO TO 30
      ENDIF
*
 10   CONTINUE
+SELF,IF= IBMVM.
      CHLINE = ' '
      READ(LUNHPI,NUM=LLINE,END=20) CHLINE
+SELF,IF=-IBMVM.
      CHLINE = ' '
      READ(LUNHPI,'(A)',END=20) CHLINE
+SELF.
      LLINE = LENOCC(CHLINE)
      IF ( LLINE .EQ. 0 ) GO TO 10
*
      IF ( CHLINE( 1: 4) .EQ. 'Nrun' ) THEN
         IF ( NEVBAD .GE. MEVBAD ) THEN
            WRITE(*,1200) MEVBAD
            GO TO 20
         ELSE
            NEVBAD = NEVBAD + 1
         ENDIF

         READ(CHLINE( 6:10),'(I5)') IRNBAD(NEVBAD)
         READ(CHLINE(19:23),'(I5)') IEVBAD(NEVBAD)
      ENDIF
      GO TO 10
   20 CONTINUE
      CLOSE(LUNHPI)
   30 CONTINUE
 1100 FORMAT(//1X,'%PSMAIN-I-PSBHPC, File BAD_EVENTS97.LIST not open')
 1200 FORMAT(//1X,'%PSMAIN-I-PSBHPC, More then ',I5,' bad HPC events')
      END
*
+DECK,PSRUNQ. **********************************************************
      SUBROUTINE PSRUNQ(LUNRQO)
************************************************************************
*                                                                      *
*     Name           :  PSRUNQ                                         *
*     Called by      :  USER01                                         *
*     Date of coding :  Sep 03, 1991                                   *
*     Last update    :  Aug 12, 1997                                   *
*     Task           :  To read the RUNQUALITY files                   *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCRNQ.
*
*--   arguments
      INTEGER LUNRQO
*
*--   functions
      INTEGER LENOCC
*
*--   local variables
      INTEGER IACC,LUNRQI,IOS
      INTEGER I,IR,ID,IT,IS,NF
      INTEGER LLINE,NRUNS
      INTEGER NRUN,NOLD,NFIL,NFLD
*
      INTEGER    NNAM
      PARAMETER (NNAM = 12)
*
      CHARACTER*2   FILE
      CHARACTER*126 FILES
      CHARACTER*122 CHLINE
      CHARACTER*21  FILNAM(NNAM)
      CHARACTER*8   DETNAM(NRQDET),TRGNAM(NRQTRG)
*
      DATA FILNAM /'RUNQUALI.SUMARY90'  ,'RUNQUALI.SUMARY91'
     +,            'RUNQUALI.SUMARY92'  ,'RUNQUALI.SUMARY93'
     +,            'RUNQUALI.SUMARY94'  ,'RUNQUALI.SUMARY95'
     +,            'RUNQUALI.SUMARY95P3','RUNQUALI.SUMARY96'
     +,            'RUNQUALI.SUMARY97'  ,'RUNQUALI.SUMARY98'
     +,            'RUNQUALI.SUMARY99'  ,'RUNQUALI.SUMARY00'/
*
      DATA FILES ( 1: 42) /'A B C D E F G H I J K L M N O P Q R S T U '/
      DATA FILES (43: 84) /'V W X Y Z AAABACADAEAFAGAHAIAJAKALAMANAOAP'/
      DATA FILES (85:126) /'AQARASATAUAVAWAXAYAZBABCBDBEBFBGBHBIBJBKBL'/
*
      DATA DETNAM/'MVX_A   ','MVX_C   ','ID_JET  ','ID_TRIG ','TPC_0   '
     +,           'TPC_1   ','BRICH_L ','BRICH_G ','OD_B    ','OD_D    '
     +,           'HPC_0   ','HPC_1   ','HCAB_A  ','HCAB_C  ','MUB_B   '
     +,           'MUB_D   ','FCA_A   ','FCA_C   ','RIF_A   ','RIF_C   '
     +,           'FCB_A   ','FCB_C   ','EMF_A   ','EMF_C   ','HCAF_A  '
     +,           'HCAF_C  ','MUF_A   ','MUF_C   ','SAT_CAL ','SAT_TRA '
     +,           'VSAT    ','VFT_PIX ','VFT_STR ','MUS     ','TOF     '
     +,           'TAG_40  ','TAG_90  ','TAG_PHI '/
*
      DATA TRGNAM/'TRIG_T1 ','TRIG_T2 ','B1_OR   ','B1_FW   ','PYT_SA  '
     +,           'PYT_BM2 ','PYT_FM2 ','PYT_BMJ ','PYT_FMJ ','SAT     '
     +,           'VSAT    '
     +,           'ID      ','OD      ','HPC     ','TOF     ','FCA_A   '
     +,           'FCA_C   ','FCB_A   ','FCB_C   ','EMF_A   ','EMF_C   '
     +,           'HOF     ','SAT     '/
*
*--   Open the I/O files
      IF ( LUNRQO .GT. 6 ) THEN
         CALL PHOPEN( LUNRQO, 'RUNQUALI.OUTPUT', '.', 'W', IOS )
      ENDIF
*
*--
      IF ( LUNRQO .NE. 0 ) THEN
         WRITE (LUNRQO,1100) (I,DETNAM(I),IRQDMN(I),IRQDMX(I),
     +                                              I=1,NRQDET)
         WRITE (LUNRQO,1200) (I,TRGNAM(I), RQTMN(I), RQTMX(I),
     +                                              I=1,NRQT9X-2)
         WRITE (LUNRQO,1300) (I,TRGNAM(I),IRQTMN(I),IRQTMX(I),
     +                                              I=NRQT9X-1,NRQT9X)
         WRITE (LUNRQO,1400) (I,TRGNAM(I),IRQTMN(I),IRQTMX(I),
     +                                              I=NRQT90  ,NRQTRG)
         WRITE (LUNRQO,1500)
      ENDIF
*
*--   Read the RUN-selection file and get
*--   the  DELPHI detector/trigger statae
*
      NRQFIL = 0
      NSRUNS = 0
      IACC   = 0
      LUNRQI = 13
*
      DO NF = 1, NNAM
*
         CALL PHOPEN(LUNRQI,FILNAM(NF),' ',' ',IOS)
         IF ( IOS .NE. 0 ) GOTO 99
*
 10      CONTINUE
+SELF,IF= IBMVM.
         CHLINE = ' '
         READ(LUNRQI,NUM=LLINE,END=40) CHLINE
+SELF,IF=-IBMVM.
         READ(LUNRQI,'(A)',END=40) CHLINE
+SELF.
         LLINE = LENOCC(CHLINE)
         IF ( LLINE .EQ. 0 ) GO TO 10
*
         IF ( CHLINE( 2: 5) .EQ. 'FILL' ) THEN
            IF ( NRQFIL .GE. MRQFIL ) THEN
               WRITE(*,1550) MRQFIL
               GO TO 40
            ELSE
              NRQFIL = NRQFIL + 1
            ENDIF
*
            READ(CHLINE( 6: 9),'( I4 )') IRQFIL(NRQFIL)
            READ(CHLINE(13:18),'(F6.3)') ERQFIL(NRQFIL)
            READ(CHLINE(26:28),'( I3 )') NRUNS
*
            DO IR = 1, NRUNS
+SELF,IF= IBMVM.
               CHLINE = ' '
               READ(LUNRQI,NUM=LLINE,END=99) CHLINE
+SELF,IF=-IBMVM.
               READ(LUNRQI,'(A)',END=99) CHLINE
+SELF.
*
               IF ( IRQFIL(NRQFIL) .GT. 5450 ) THEN
                  READ( CHLINE( 1: 6),'(I6)' ) NRUN
                  READ( CHLINE( 7: 8),'(I2)' ) NFIL
               ELSE
                  READ( CHLINE( 1: 5),'(I5)' ) NRUN
                  IF ( NRUN .GT. 72000 ) THEN
                    READ(CHLINE( 6: 7),'(I2)') NFIL
                  ELSE
                    READ(CHLINE( 6: 7),'(A2)') FILE
                    NFIL = MAX((INDEX(FILES,FILE)+1)/2,1)
                  ENDIF
               ENDIF
*
               READ(CHLINE(10:19),'( 10I1)') (IRQDET(I),I= 1,10)
               READ(CHLINE(21:26),'(  6I1)') (IRQDET(I),I=11,16)
               READ(CHLINE(28:39),'( 12I1)') (IRQDET(I),I=17,28)
               READ(CHLINE(41:43),'(  3I1)') (IRQDET(I),I=29,31)
               IF ( NRUN .GT. 72000 ) THEN
               READ(CHLINE(45:51),'(  7I1)') (IRQDET(I),I=32,38)
               ENDIF
*
               DO ID = 1, NRQDET
                  IF(IRQDET(ID) .LT. IRQDMN(ID) .OR.
     +               IRQDET(ID) .GT. IRQDMX(ID))THEN
                     IF(LUNRQO .GT. 0 ) THEN
                        WRITE(LUNRQO,1600) NRUN,NFIL,IRQDET(ID)
     +                                              ,DETNAM(ID)
                     ENDIF
                     GO TO  20
                  ENDIF
               ENDDO
*
               IF ( IRQFIL(NRQFIL) .LT. 500 ) THEN
                  READ(CHLINE(46:51),'(  3I2)') (IRQTRG(I),I= 1, 3)
                  READ(CHLINE(56:60),'(  5I1)') (IRQTRG(I),I= 4, 8)
                  READ(CHLINE(61:62),'(   I2)') (IRQTRG(I),I= 9, 9)
                  READ(CHLINE(66:67),'(   I2)') (IRQTRG(I),I=10,10)
                  READ(CHLINE(72:73),'(  2I1)') (IRQTRG(I),I=11,12)
*
                  DO IT = NRQT90, NRQTRG
                     IF(IRQTRG(IT) .LT. IRQTMN(IT) .OR.
     +                  IRQTRG(IT) .GT. IRQTMX(IT))THEN
                        IF(LUNRQO .GT. 0 ) THEN
                           WRITE(LUNRQO,1700) NRUN,NFIL,IRQTRG(IT),
     +                                                  TRGNAM(IT)
                        ENDIF
                        GO TO  20
                     ENDIF
                  ENDDO
               ELSE
C                 READ(CHLINE(46:52),'(I3,I4)') (IRQTRG(I),I= 1, 2)
C                 READ(CHLINE(54:81),'(7F4.0)') ( RQTRG(I),I= 3, 9)
C                 READ(CHLINE(83:84),'(  2I1)') (IRQTRG(I),I=10,11)
               ENDIF
*
               IF ( IACC .EQ. 0 )  THEN
                  IF ( NSRUNS .GE. MSRUNS ) THEN
                     WRITE(*,1750) MSRUNS
                     GO TO 40
                  ELSE
                     NSRUNS  =  NSRUNS + 1
                     IFRUNS(NSRUNS) = NRUN
                     IFFILE(NSRUNS) = NFIL
                     IACC = 1
                  ENDIF
               ENDIF
                           GO TO 30
   20          CONTINUE
               IF ( IACC .EQ. 1 )  THEN
                  ILRUNS(NSRUNS) = NOLD
                  ILFILE(NSRUNS) = NFLD
                  IACC = 0
               ENDIF
*
   30          NOLD = NRUN
               NFLD = NFIL
            ENDDO
         ENDIF
*
         GO TO 10
 40      CONTINUE
         IF ( IACC .EQ. 1 )  THEN
            ILRUNS(NSRUNS) = NOLD
            ILFILE(NSRUNS) = NFLD
            IACC = 0
         ENDIF
*
         CLOSE(LUNRQI)
      ENDDO
*
      IF ( LUNRQO .NE. 0 ) THEN
         WRITE(LUNRQO,1800) (IFRUNS(IS),IFFILE(IS),
     +                       ILRUNS(IS),ILFILE(IS),IS=1,NSRUNS)
      ENDIF
   99 CONTINUE
*-----------------------------------------------------------------------
 1100 FORMAT(/,1X,'%PSMAIN-I-PSRUNQ, Requirements for detector quality'
     +,     //,1X,'                  Detector            Status       '
     +,      /,1X,'                               minimum      maximum'
     +,     //,  ('               ', I3,1X,A8,7X,I2,11X,I2))
*
 1200 FORMAT(/,1X,'%PSMAIN-I-PSRUNQ, Requirements for trigger  quality'
     +,      /,1X,'                                199X               '
     +,     //,1X,'                  Trigger             Status       '
     +,      /,1X,'                               minimum      maximum'
     +,     //,  ('               ', I3,1X,A8,5X,E7.2,6X,E7.2))
*
 1300 FORMAT((15X,I3,1X,A8,7X,I2,11X,I2))
*
 1400 FORMAT(/,1X,'%PSMAIN-I-PSRUNQ, Requirements for trigger  quality'
     +,      /,1X,'                                1990               '
     +,     //,1X,'                  Trigger             Status       '
     +,      /,1X,'                               minimum      maximum'
     +,     //,  ('               ', I3,1X,A8,7X,I2,11X,I2))
*
 1500 FORMAT(//1X,'%PSMAIN-I-PSRUNQ, List of the rejected DELPHI runs:'
     +,      /)
 1550 FORMAT(//1X,'%PSMAIN-I-PSRUNQ, More then ',I4,' fills')
 1600 FORMAT(  1X,'                 ',I7,'_',I2.2,', status',I2
     +,           ' of detector ',A8)
 1700 FORMAT(  1X,'                 ',I7,'_',I2.2,', status',I2
     +,           ' of trigger  ',A8)
 1750 FORMAT(//1X,'%PSMAIN-I-PSRUNQ, More then ',I4,' runs')
 1800 FORMAT(//1X,'%PSMAIN-I-PSRUNQ, List of the selected DELPHI runs:'
     +,     //(1X,'                ',I8,'_',I2.2,'  -  ',I6,'_',I2.2))
      END
*
+DECK,PSRUNS. **********************************************************
      SUBROUTINE PSRUNS(IRSEL)
************************************************************************
*                                                                      *
*     Name           :  PSRUNS                                         *
*     Called by      :  USER01                                         *
*     Date of coding :  Sep 03  1991                                   *
*     Last update    :  Mar 07  1995                                   *
*     Task           :  To select good DELPHI runs                     *
*                                                                      *
*     Output         :  IRSEL = 1 - the run is selected                *
*                       IRSEL = 0 - the run is rejected                *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCRNQ.
*
*--   arguments
      INTEGER IRSEL
*
*--   local variables
      INTEGER IS
      INTEGER IOLDRN,IOLDFL
      SAVE    IOLDRN,IOLDFL
      DATA    IOLDRN/0/,IOLDFL/0/
*
      IF ( IIIRUN .GT. 0 ) THEN
         IF ( IIIRUN .NE. IOLDRN   .OR.
     +        IIFILE .NE. IOLDFL ) THEN
*
            IRSEL = 0
*
            DO IS = 1, NSRUNS
               IF ( IIIRUN .GT. IFRUNS(IS) .AND.
     +              IIIRUN .LT. ILRUNS(IS)) THEN
                    IRSEL= 1
                    GO TO 99
               ENDIF
*
               IF ( IIIRUN .EQ. IFRUNS(IS) .AND.
     +              IIFILE .GE. IFFILE(IS)  .OR.
     +              IIIRUN .EQ. ILRUNS(IS) .AND.
     +              IIFILE .LE. ILFILE(IS)) THEN
                    IRSEL= 1
                    GO TO 99
               ENDIF
            ENDDO
*
            IOLDRN  =  IIIRUN
            IOLDFL  =  IIFILE
         ENDIF
      ELSE
         IRSEL = 1
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSBEAM. **********************************************************
      SUBROUTINE PSBEAM
************************************************************************
*                                                                      *
*     Name           :  PSBEAM                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep 03  1994                                   *
*     Last update    :  Nov 23  1999                                   *
*     Task           :  To read the beam spot position and size        *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCBSD.
+CDE, PSCBSP.
*
*--   local variables
      INTEGER NYEAR,JYEAR,LQSPOT
*
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST /.TRUE./
*
      IF ( IFLBSP .EQ. 1 ) THEN
*
*--      Read the Beam in bank(25)
         IF ( LDTOP.LE.0 )  RETURN
         LQSPOT  =  LQ(LDTOP - 25)
*
         IF ( ISVER .GE. 102  .AND.
     +       LQSPOT .GT.   0) THEN
            XYZBS(1) = Q(LQSPOT+1)
            XYZBS(2) = Q(LQSPOT+2)
            XYZBS(3) = Q(LQSPOT+3)
           DXYZBS(1) = Q(LQSPOT+4)
           DXYZBS(2) = Q(LQSPOT+5)
           DXYZBS(3) = Q(LQSPOT+6)
         ELSE
           IF ( FIRST ) THEN
              FIRST = .FALSE.
*
*--           Set-up the defaults
                                         JYEAR= 0
              IF ( CDTYPE(1:1) .EQ. 'A') JYEAR=10
*
              READ ( CDTYPE(2:2),'(I1)') NYEAR
              CALL SETBS ( 1, 1, SIGBS(1,NYEAR+JYEAR) )
           ENDIF
*
*--        Beam spot coordinates
           CALL VDBSPT( XYZBS, DXYZBS, IERRBS )
        ENDIF
*
      ELSEIF ( IFLBSP .GE. 2 ) THEN
*
         IF ( FIRST ) THEN
            FIRST = .FALSE.
*
*--         VD initialization
            CALL VDIDST
*
*--         Set-up the defaults
                                       JYEAR= 0
            IF ( CDTYPE(1:1) .EQ. 'A') JYEAR=10
*
            READ ( CDTYPE(2:2),'(I1)') NYEAR
            CALL SETBS ( 1, 1, SIGBS(1,NYEAR+JYEAR) )
         ENDIF
*
*--      Beam spot coordinates
         CALL VDBSPT( XYZBS, DXYZBS, IERRBS )
      ENDIF
*
      END
*
+DECK,PSLABC. **********************************************************
      CHARACTER*4 FUNCTION PSLABC ( INDLAB )
************************************************************************
*                                                                      *
*     Name           :  PSLABC                                         *
*     Called by      :  PSMEVT                                         *
*     Date of coding :  Mar 29, 1995                                   *
*     Last update    :  Mar 30, 1995                                   *
*     Task           :  Convert the Laboratory index into name         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
*--   argiments
      INTEGER INDLAB
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER     NLAB
      PARAMETER  (NLAB = 50)
      INTEGER     ILAB
      INTEGER     LABIND(NLAB)
      CHARACTER*4 LABNAM(NLAB)
*
*--   Laboratory indecies and names
      DATA LABIND /
     1      110,    200,    310,    410,    500,    510,    520,    530,
     2      540,    550,    560,    570,    580,    590,    610,    620,
     3      710,    720,    730,    810,    820,    830,    910,    920,
     4      930,    940,    950,    960,    970,   1010,   1110,   1120,
     5     1210,   1220,   1310,   1320,   1410,   1420,   1430,   1510,
     6     1610,   1620,   1710,   1810,   1860,   1980,   1990,   2000,
     7     2110,   2210/
*
      DATA LABNAM /
     1   'WIEN', 'BELG', 'NBI ', 'HELS', 'CCPN', 'CDF ', 'LAL ', 'LPNH',
     2   'SACL', 'STRA', 'LYON', 'GREN', 'MARS', 'BAST', 'KARL', 'WUPP',
     3   'LIVE', 'OXFO', 'RAL ', 'ATHE', 'ANTU', 'DEMO', 'BOLO', 'GENO',
     4   'MILA', 'PADU', 'ROMA', 'TRIE', 'TORI', 'NIKH', 'BERG', 'OSLO',
     5   'CRAC', 'WARS', 'SANT', 'VALE', 'LUND', 'STOC', 'UPPS', 'AMES',
     6   'SERP', 'DUBN', 'LISB', 'PRAG', 'BRAT', 'SNAK', 'FARM', 'CERN',
     7   'LJUB', 'BRAZ'/
*
      IF ( INDLAB .LE. 0 ) THEN
         PSLABC = '????'
      ELSE
         ILAB   = IUCOMP( INDLAB, LABIND , NLAB )
         PSLABC = LABNAM(ILAB)
      ENDIF
*
      END
*
+PATCH,PSHORT.==========================================================
+DECK,PSHORT. **********************************************************
      SUBROUTINE PSHORT
************************************************************************
*                                                                      *
*     Name           :  PSHORT                                         *
*     Called by      :  USER02                                         *
*     Task           :  Access and read the short DST data,            *
*                       called once per event                          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
      CALL PSHORTEVT() ! EVT BANKS, DON'T DEPEND ON SELECTED TRACKS
*
      CALL PSHORTINIT() ! INITIALISE SKELANA BANKS
*
      CALL PSHORTTRK() ! SELECT TRKS
*
      CALL PSHORTOTH() ! BANKS WHICH DON'T STORE TRK INFO
                       ! BUT DO NEED TRKS SELECTED
*
      RETURN
      END
*
+DECK,PSHORTEVT. *******************************************************
      SUBROUTINE PSHORTEVT
************************************************************************
*                                                                      *
*     Name           : PSHORTEVT                                       *
*     Called by      : PSHORT                                          *
*     Task           : routines which fill event based banks,          *
*                      i.e. skelana banks that are                     *
*                      independent of which tracks are selected        *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PHCIII.
+CDE, PSCFLG.
+CDE, PSDSTYPE.
*
*--   VECP links protection
      CALL PUCINI
*
*--   General event information
      CALL PSHEVT
*
*--   Read the vertex information not dependent on track selection
      CALL PSHVTX
*
+SELF,IF=-NOIFLBSP.
*
*--   Beam spot
      IF ( IFLBSP .GT. 0 ) CALL PSBEAM
+SELF.
*
+SELF,IF=-NOIFLBTG.
*
*--   B_tagging
      IF (FULLDST) THEN
        IF ( IFLBTG .GT. 0 ) CALL PSFBTG
      ELSE ! short DST
        IF ( IFLBTG .EQ. 1 ) CALL PSHBTG
        IF ( IFLBTG .EQ. 2 ) CALL PSFBTG
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLUTE.
*--   Fill the Unassoc. TER's information
      IF ( IFLUTE .GT. 0 ) THEN
        IF (FULLDST) THEN
          CALL PSFUTE
        ELSE ! short DST
          CALL PSHUTE
        ENDIF
      ENDIF
+SELF.
+SELF,IF=-NOIFLECL.
*--   Fill the Rec. elm. cluster information
      IF (FULLDST) THEN
        IF ( IFLECL .GT. 0 ) THEN
          CALL REMCLU
          CALL REMOUT
        ENDIF
      ELSE ! short DST
        IF ( IFLECL .EQ. 1 .OR. IFLECL .EQ. 11) THEN
            CALL PSHEC1
        ELSEIF ( IFLECL .EQ. 2 .OR. IFLECL .EQ. 22) THEN
          CALL REMCLU
          CALL REMOUT
        ENDIF
      ENDIF
+SELF.
*
      RETURN
      END
*
+DECK,PSHORTINIT. ******************************************************
      SUBROUTINE PSHORTINIT
************************************************************************
*                                                                      *
*     Name           :  PSHORTINIT                                     *
*     Called by      :  PSHORT                                         *
*     Task           :  calls routines which initialise skelana banks  *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PSCFLG.
+CDE, PSDSTYPE.
*
+SELF,IF=-NOIFLELE.
*--   Electron identification initialization
      IF (FULLDST) THEN
* Electron identification not available on Full DST
      ELSE ! SHORT DST
        IF ( IFLELE .GT. 0 )  CALL PSHELE(0,0)
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLHAD.
      IF (FULLDST) THEN
        IF ( IFLHAD .GT. 0 )  CALL PSFHAD(0,0)
      ELSE ! SHORT DST
*--   Hadron   identification initialization
        IF ( IFLHAD .EQ. 1 )  CALL PSHHAD(0,0)
        IF ( IFLHAD .EQ. 2 )  CALL PSFHAD(0,0)
      ENDIF
+SELF.
*
       RETURN
       END
*
+DECK,PSHORTSEL. *******************************************************
      SUBROUTINE PSHORTSEL(ISTAT)
************************************************************************
*                                                                      *
*     Name           :  PSHORTSEL                                      *
*     Called by      :  PSHORTTRK                                      *
*     Task           :  Calls Track selection routine                  *
*                       and recovery routine                           *
*                                                                      *
*      Meaning of the bits of LVSELE (1-32)                            *
*                                                                      *
*      bit 1 ....................... standard selection (global)       *
*      bit 2-11 .................... cut that caused the rejection     *
*      bit 20-22 ................... recovery step result              *
*      bit 30 ...................... REMCLU cluster added to VECP      *
*      bit 31 ...................... PA in REMCLU cluster              *
*      bit 32 ...................... multivertex structure handling    *
*      currently unused bits are reserved for future SKELANA changes   *
*                                                                      *
*      NB: In case of recovery of a charged as a neutral the selection *
*      bits are those of the charged track selection (2-11)            *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, TRACKNTP.
*
*--   arguments
      INTEGER ISTAT
*
*--   local variables
      INTEGER I,ICUT,IREJ
*-- function
      INTEGER JBIT

      ISTAT=0
      I=NVECP
*
*--   Track selection applied
      IF ( IFLSTR .GT. 0 ) THEN
        ICUT = IFLCUT
*
         IREJ=0
         IF (VECP(7,I).EQ.0.) THEN
           CALL PSHSNT( I, ICUT, IREJ ) ! neutral trk selection             
         ELSE
           CALL PSHSCT( I, ICUT, IREJ ) ! chged trk selection
         ENDIF
*
*--        Recovery routine
         IF(  IREJ.EQ.1 .AND. IFLRVR .GT. 0) THEN
           IF (VECP(7,I).EQ.0) THEN
              CALL PSHSNTRECOVER( I, ICUT, IREJ ) !  neutral trk recovery
           ELSE
              CALL PSHSCTRECOVER( I, ICUT, IREJ ) ! chged trk recovery
           ENDIF
         ENDIF
*
*--        Lock rejected tracks
         IF ( IREJ   .NE.  0 ) CALL SBIT1(LVSELE(NVECP),1)
*
         IF ( IREJ.EQ.-1) THEN ! chged recovered as neutral
           CALL SBIT0(LVSELE(NVECP),1)
           ISTAT = 2
         ENDIF
*
* reject recovered neutrals, if locking not used
* and unwanted multi-vertex or Remclu PA
         IF ((IREJ.EQ.-1.AND.IFLSTR.LT.10).AND.
     +       ((JBIT(LVSELE(NVECP),31).EQ.1).OR.
     +        (JBIT(LVSELE(NVECP),32).EQ.1))) ISTAT=1
*
         IF (IREJ.EQ.1.AND.IFLSTR.LT.10) ISTAT=1 ! reject track
       ENDIF
*
*--    Copy all the ICTFAIL/INTFAIL information in LVSELE
*
*--    Failure bits
*
       IF (ISTAT.NE.2) THEN
* for charged recovered as neutrals, LVSELE is set in PSHCTRECCAL
         IF (VECP(7,NVECP).NE.0.) THEN
           CALL MVBITS(ICTFAIL,0,10,LVSELE(NVECP),1)
         ELSE
           CALL MVBITS(INTFAIL,0,10,LVSELE(NVECP),1)
         ENDIF
*
*--    Recovery bits
*
         IF (VECP(7,NVECP).NE.0.) THEN
           CALL MVBITS(ICTFAIL,19,3,LVSELE(NVECP),19)
         ENDIF
*
       ENDIF

       RETURN
       END
*
+DECK,PSHORTOTH. *******************************************************
      SUBROUTINE PSHORTOTH
************************************************************************
*                                                                      *
*     Name           :  PSHORTSEL                                      *
*     Called by      :  PSHORT                                         *
*     Task           :  fill banks  which do not store track level     *
*                       information, however do require  (e.g. for     *
*                       reference indexes) tracks already selected     *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PHCIII.
+CDE, PSCFLG.
+CDE, PSDSTYPE.
*
+SELF,IF=-NOIFLJET.
      INTEGER IERR,MASK
      REAL    DJOIN
+SELF.
*
+SELF,IF=-NOIFLJET.
*--   Jet reconstruction
      IF ( IFLJET .NE. 0 ) THEN
         MASK = 0
         CALL SBIT1 ( MASK,  1 )
         CALL SBIT1 ( MASK, 32 )
         IF ( IFLJET .EQ. 1 ) DJOIN = 3.
         IF ( IFLJET .GE. 2 ) DJOIN = 0.01
         CALL PSJETS( IFLJET, DJOIN, MASK, IERR )
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLSIM.
*--   Read the Simulation banks
      IF ( IFLSIM .GT. 0  .AND.
     +     IIIRUN .LT. 0 ) THEN
        IF (FULLDST) THEN
          CALL PSFMC
        ELSE ! short DST
          CALL PSHMC
        ENDIF
      ENDIF
+SELF.
*
*--   Read the vertex information dependent on track selection
       CALL PSHVT2
*
+SELF, IF=-NOIFLVDH.
*--   Fill the Vertex detector hits
       IF (FULLDST) THEN
         IF ( IFLVDH .GT. 0 ) CALL PSFVDH
       ELSE ! short DST
         IF ( IFLVDH .GT. 0 ) CALL PSHVDH
       ENDIF
+SELF.
*
+SELF,IF=-NOIFLRV0.
*--   Fill the Reconstructed V0's
       IF (FULLDST) THEN
* MAMMOTH identification not available on FULLDST
       ELSE ! short DST
         IF ( IFLRV0 .GT. 0 ) CALL PSHRV0
       ENDIF
+SELF.
*
+SELF,IF=-NOIFLPHC.
*--   Fill the Converted photon information
      IF (FULLDST) THEN
* not available on FULLDST
      ELSE ! short DST
        IF ( IFLPHC .GT. 0 ) CALL PSHPHC
      ENDIF
+SELF.
+SELF,IF=-NOIFLECL.
*--   Fill the Rec. elm. cluster information
      IF (FULLDST) THEN
        IF ( IFLECL .GT. 0 ) CALL PSFECL
      ELSE ! short DST
        IF ( IFLECL .EQ. 1 .OR. IFLECL .EQ. 11) CALL PSHECL
        IF ( IFLECL .EQ. 2 .OR. IFLECL .EQ. 22) CALL PSFECL
      ENDIF
+SELF.
*
       RETURN
       END
*
+DECK,PSHORTTRK. *******************************************************
      SUBROUTINE PSHORTTRK
************************************************************************
*                                                                      *
*     Name           :  PSHORTTRK                                      *
*     Called by      :  PSHORT                                         *
*     Task           :  Fill skelana banks for all tracks              *
*                       IFLVEC settings and                            *
*                       track selection are considered                 *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, PSCVECJJ.
+CDE, PSCTBL.
+CDE, TRACKNTP.
*
*--   functions
      INTEGER LPHPA
      INTEGER PSVECWANT
      INTEGER JBIT
*
*--   local variables
      INTEGER LPV,LPA,LMAIN,LTRAC
      INTEGER ISTAT,ICNTYPE
      INTEGER I,IFLAG
*
*--   Fill banks with Neutrals, Charged or PV,PA order
      ICNTYPE=0
*
 11   CONTINUE
*
      IF (IFLODR.EQ.0) THEN
        ICNTYPE=0 ! PV,PA order
      ELSE
        ICNTYPE=ICNTYPE+1 ! 1=charged, 2=neutral
      ENDIF
*
*--   Loop over the vertices
*--   PV  vertex bank address
      IF (LDTOP.LE.0)  RETURN
      LPV=LQ(LDTOP-1)
      DO WHILE ( LPV .NE. 0 )
*
*--   Loop over the particles
*--   PA  bank address
         LPA = LQ(LPV - 1)
         DO WHILE ( LPA .NE. 0 )
*
           IF (PSVECWANT(LPV,LPA).EQ.1) GOTO 10 ! skip particle
*
           LMAIN = LPHPA('MAIN',LPA,0)
           IF ( LMAIN .EQ. 0 ) GOTO 10
*
           IF (NINT(Q(LMAIN+8)) .NE. 0) THEN
             LTRAC = LPHPA('TRAC',LPA,0)
             IF ( LTRAC .EQ. 0 ) GOTO 10
           ENDIF
*
*--        Skip neutrals on this pass
           IF (ICNTYPE.EQ.1.AND.(NINT(Q(LMAIN+8)).EQ. 0)) GOTO 10
*
*--        Skip charged on this pass
           IF (ICNTYPE.EQ.2.AND.(NINT(Q(LMAIN+8)).NE. 0)) GOTO 10
*
           IF (NCVECP .GE. NVMAX) THEN
             WRITE(*,1000) NVMAX,IIIRUN,IIIEVT,NEVENT
             GO TO 99
           ENDIF
*
* --       Update track counters
           NVECP=NVECP+1
           IF (NINT(Q(LMAIN+8)) .NE. 0) THEN
             NCVECP=NCVECP+1
           ELSE
             NNVECP=NNVECP+1
           ENDIF
*
*--        Fill banks for all tracks
*
*--        Lock tracks from unrequired vertices
           IF (PSVECWANT(LPV,LPA).EQ.2) CALL SBIT1(LVSELE(NVECP),32)
*
*--        Fill here only the banks require
*--        to perform  the track  selection
           CALL PSHBANKS1(LPA)
*
           ISTAT = 0
*--        Check if the PA is part of a REMCLU cluster
*--        (if wanted by the user)
           IFLAG = 0
           IF (IFLECL.GT.0 .AND. IFLECL.LE.2) CALL PSHREMCLU(LPA,IFLAG)
           IF (IFLAG.EQ.1 .OR. IFLAG.EQ.2 .OR. IFLAG.EQ.3) THEN
             CALL SBIT1(LVSELE(NVECP),31)
             CALL SBIT1(LVLOCK(NVECP),32)
*
*--          If the rejection is selected skip the PAs part of REMCLU clusters
*
             IF (IFLVEC.GT.0 .AND. IFLVEC.LT.10) THEN
               ISTAT = 1
             ENDIF
           ELSEIF (IFLAG.EQ.0 .OR. IFLAG.EQ.4 .OR. IFLAG.EQ.5) THEN
*
* -- perform  track refitting
             CALL PSHTREFT(LPA)
*--          Perform track selection
             CALL PSHORTSEL(ISTAT)
           ENDIF
*
           IF (ISTAT.EQ.0) THEN ! track retained
*--          Fill here all the reamining banks
             CALL PSHBANKS2(LPA)
*
*--          Recovery of a rejected charged as a neutral
*--          in case of PV-PA structure order
*
           ELSEIF (ISTAT.EQ.2 .AND. ICNTYPE.EQ.0) THEN
             NCVECP = NCVECP-1
             NNVECP = NNVECP+1
             CALL PSHCHREC(LPA)
             CALL PSHBANKS2(LPA)
           ELSE
*--          Track rejected - zero banks
             CALL PSHBANKS1ZERO(LPA)
           ENDIF
*
   10      CONTINUE
           LPA = LQ(LPA)
         ENDDO ! LPA loop
   20    CONTINUE
         LPV = LQ(LPV)
      ENDDO
*
*--   Fill the additional VECP entries corresponding to REMCLU clusters
*
      IF (IFLECL.GT.0 .AND. IFLECL.LE.2) CALL PSHREMFIL(ICNTYPE)
*
      IF (IFLODR.EQ.1.AND.ICNTYPE.LT.2) GOTO 11 ! loop for neutrals
*
*--   Reorder the new neutrals created from recovery of energy
*--   associated to charged failing the cuts
*
      IF (ICNTYPE.EQ.0) CALL vzeroi(LVECP(LVWORK+1),MTRACK)
*
      IF (LVECP(LVWORK+1).NE.0) THEN
        I = 1
        DO WHILE (LVECP(LVWORK+I).NE.0)
          NVECP = NVECP+1
          NNVECP = NNVECP+1
          CALL PSHBANKS1(LVECP(LVWORK+I))
          CALL PSHCHREC(LVECP(LVWORK+I))
          CALL PSHBANKS2(LVECP(LVWORK+I))
          LVECP(LVWORK+I) = 0
          I = I+1
        ENDDO
      ENDIF
*
*     For all the VECP entries fill LVLOCK with the first and the last
*     bit of LVSELE
*
      DO I = 1,NVECP
        IF (JBIT(LVSELE(I),1).EQ.1) CALL SBIT1(LVLOCK(I),1)
        IF (JBIT(LVSELE(I),32).EQ.1) CALL SBIT1(LVLOCK(I),32)
      ENDDO
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHCTK, ','More than ',I4,' tracks'
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
*
      RETURN
      END
*
+DECK,PSHBANKS1. *******************************************************
      SUBROUTINE PSHBANKS1(LPA)
************************************************************************
*                                                                      *
*     Name           :  PSHBANKS1                                      *
*     Called by      :  PSHORTTRK                                      *
*     Task           :  SKELANA banks to fill                          *
*                       before performing track selection              *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCVEC.
+CDE, PSCFLG.
+CDE, PSDSTYPE.
+CDE, PSTMP.
+CDE, PSCHPC.
+CDE, PSCEMF.
+CDE, PSCHAC.
+CDE, PSCSTC.
+CDE, PSCTRA.
*
*--   arguments
      INTEGER LPA
*
*--   local variables
      INTEGER I

* store info. in case track is rejected and PSHBANKS1ZERO called
      NHPCOLD=NHPC
      NEMFOLD=NEMF
      NHACOLD=NHAC
      NSTICOLD=NSTIC
      NTRACOLD=NTRAC

      I=NVECP

      CALL PSHVEC ( LPA ) ! fill VECP

+SELF,IF=-NOIFLTRA.
*--   Fill the track information common
      IF (FULLDST) THEN
        IF ( IFLTRA .GT. 0 ) CALL PSFTRA(LPA,I)
      ELSE ! short DST
        IF ( IFLTRA .GT. 0 ) CALL PSHTRA(LPA,I)
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLEMC.
*--   Fill the elm. calorimetry commons
      IF (FULLDST) THEN
         IF ( IFLEMC .GT. 0 ) CALL PSFEMC(LPA,I)
      ELSE ! short DST
         IF ( IFLEMC .GT. 0 ) CALL PSHEMC(LPA,I)
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLHAC.
*--   Fill the hadron calorimetry common
      IF (FULLDST) THEN
        IF ( IFLHAC .GT. 0 ) CALL PSHHAC(LPA,I)
      ELSE ! short DST
        IF ( IFLHAC .GT. 0 ) CALL PSHHAC(LPA,I)
      ENDIF
+SELF.
*
+SELF,IF=-NOIFLSTC.
*--   Fill the STIC shower information commons
      IF (FULLDST) THEN
        IF ( IFLSTC .GT. 0 ) CALL PSFSTC(LPA,I)
      ELSE ! short DST
        IF ( IFLSTC .GT. 0 ) CALL PSHSTC(LPA,I)
      ENDIF
+SELF.
*
*       Fixing for 99 HPC photons (99C1 data/99A1 MC)
*
      CALL GAMFIX99(LPA,I)
*
       RETURN
       END

+DECK,PSHBANKS1ZERO. ***************************************************
      SUBROUTINE PSHBANKS1ZERO(LPA)
************************************************************************
*                                                                      *
*     Name           :  PSHBANKS1ZERO                                  *
*     Called By      :  PSHORTTRK                                      *
*     Task           :  If the track is rejected                       *
*                       zero the banks filled in PSHBANKS1             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCHPC.
+CDE, PSCEMF.
+CDE, PSCHAC.
+CDE ,PSCSTC.
+CDE ,PSCTRA.
+CDE ,TRACKNTP.
+CDE ,PSTMP.
*
*--   arguments
      INTEGER LPA
*
*--   function
      INTEGER LPHPA
*
*--   local variables
      INTEGER LMAIN,I
*
      I=NVECP
*
*--   PSCHPC
      NHPC=NHPCOLD
      CALL uzeror(QHPC(1,I),1,LENHPC)
*
*--   PSCEMF
      NEMF=NEMFOLD
      CALL uzeror(QEMF(1,I),1,LENEMF)
*
*--   PSCHAC
      NHAC=NHACOLD
      CALL uzeror(QHAC(1,I),1,LENHAC)
*
*--   PSCSTC
      NSTIC=NSTICOLD
      CALL uzeror(QSTIC(1,I),1,LENSTC)
*
*--   PSCTRA
      NTRAC=NTRACOLD
      CALL uzeror(QTRAC(1,I),1,LENTRA)

*--   PSHVEC
      LVECP (NVECP) = 0
      LVLOCK(NVECP) = 0
      LVSELE(NVECP) = 0
      CALL uzeror(VECP(1,I),1,10)
*
      NVECP=NVECP-1
*
      LMAIN = LPHPA('MAIN',LPA,0)
      IF ( LMAIN .EQ. 0 ) GOTO 10
*
      IF (NINT(Q(LMAIN+8)) .NE. 0) THEN
         NCVECP=NCVECP-1
      ELSE
         NNVECP=NNVECP-1
      ENDIF
*
   10 CONTINUE
      RETURN
      END
*
+DECK,PSHBANKS2. *******************************************************
      SUBROUTINE PSHBANKS2(LPA)
************************************************************************
*                                                                      *
*     Name           :  PSHBANKS2                                      *
*     Called By      :  PSHORTTRK                                      *
*     Task           :  SKELANA banks to fill                          *
*                       after performing track selection               *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, PSDSTYPE.
*
*--   arguments
      INTEGER LPA
*
*--   functions
      INTEGER LPHPA
*
*--   local variables
      INTEGER LMAIN,I
*
      LMAIN = LPHPA('MAIN',LPA,0)
      IF ( LMAIN .EQ. 0 ) GOTO 10

      I=NVECP
*
+SELF,IF=-NOIFLPHO.
*--   Fill the photon/pi0 identification commons
      IF (FULLDST) THEN
        IF ( IFLPHO .GT. 0 ) CALL PSFPHO(LPA,I)
      ELSE ! short DST
        IF ( IFLPHO .GT. 0 ) CALL PSHPHO(LPA,I)
      ENDIF
+SELF.
*
*--   Charged tracks only
      IF (NINT(Q(LMAIN+8)) .NE. 0) THEN

+SELF,IF=-NOIFLELE.
*--      Fill the electron identification commons
         IF (FULLDST) THEN
* Electron ID not available from Full DST
         ELSE ! short DST
           IF ( IFLELE .GT. 0 ) CALL PSHELE(LPA,I)
         ENDIF
+SELF.
*
+SELF,IF=-NOIFLMUO.
*--      Fill the muon identification commons
         IF (FULLDST) THEN
* Muon ID not available from Full DST
         ELSE ! short DST
           IF ( IFLMUO .GT. 0 ) CALL PSHMUO(LPA,I)
         ENDIF
+SELF.
*
+SELF,IF=-NOIFLHAD.
*--      Fill the hadron identification commons
         IF (FULLDST) THEN
           IF ( IFLHAD .GT. 0 ) CALL PSFHAD(LPA,I)
         ELSE ! short DST
           IF ( IFLHAD .EQ. 1 ) CALL PSHHAD(LPA,I)
           IF ( IFLHAD .EQ. 2 ) CALL PSFHAD(LPA,I)
         ENDIF
+SELF.
      ENDIF

   10 CONTINUE
      RETURN
      END
*
+DECK,PSHREMCLU. *******************************************************
      SUBROUTINE PSHREMCLU(LPA,IFLAG)
************************************************************************
*                                                                      *
*     Name           : PSHREMCLU                                       *
*     Called By      : PSHORTTRK                                       *
*     Input .......... LPA (I) PA address                              *
*     Ouput .......... IFLAG (I) presence of the PA in REMCLU clusters *
*     0 not present                                                    *
*     1 main track/shower                                              *
*     2 track/shower with e.m. deposit                                 *
*     3      "       without e.m. deposit forward                      *
*     4      "       without e.m. deposit barrel                       *
*     5 not isolated forward (not to be created in VECP)               *
*                                                                      *
*     F. Cossutti - 17/09/1999                                         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCVEC.
+CDE, PXCONS.
+CDE, PEMOUT.
*
*--   arguments
      INTEGER LPA,IFLAG
      INTEGER ISEARCH
*
*--   functions
      INTEGER IUCOMP,JBYT,JBIT
*
*--   local variables
      INTEGER I,J,NPACLU,NPATOT
*
      IFLAG = 0
      I = IUCOMP(LPA,LEMCLU,NLNR)
*
      IF (I.NE.0) THEN
*
        NPATOT = 0
        DO J = 1,NECL
          NPACLU = JBYT( NINT(DEMCLU(6,J)), 19, 6 )
          NPATOT = NPATOT + NPACLU
          IF (I.LE.NPATOT) THEN
*
*           not isolated forward clusters have not to be filled in VECP
*
            IF (JBYT(NINT(DEMCLU( 6,J)), 1, 6).LT.30) THEN
              I = I-(NPATOT-NPACLU)
              IF (I.EQ.1) THEN
                IFLAG = 1
                GOTO 999
              ELSEIF (JBIT(NINT(DEMCLU(7,J)),I).EQ.1) THEN
                IFLAG = 2
                GOTO 999
              ELSE
                ISEARCH = JBIT(NINT(DEMCLU(6,J)),7)
                IF (ISEARCH.EQ.0) THEN
                  IFLAG = 4
                ELSE
                  IFLAG = 3
                ENDIF
                GOTO 999
              ENDIF
            ELSE
              IFLAG = 5
              GOTO 999
            ENDIF
          ENDIF
        ENDDO
*
      ENDIF
*
  999 CONTINUE
      RETURN
      END
*
+DECK,PSHREMFIL. *******************************************************
      SUBROUTINE PSHREMFIL(ICNTYPE)
************************************************************************
*                                                                      *
*     Name           :  PSHREMFIL                                      *
*     Called By      :  PSHORTTRK                                      *
*     Input ..........  ICNTYPE (I) kind of operation to be performed  *
*     0 fill all REMCLU clusters                                       *
*     1 fill only charged REMCLU clusters                              *
*     2 fill only neutral REMCLU clusters                              *
*                                                                      *
*     F. Cossutti - 23/09/1999                                         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCIII.
+CDE, PXCONS.
+CDE, PSCVEC.
+CDE, PEMOUT.
+CDE, PSCECL.
+CDE, TRACKNTP.
*
*--   arguments
      INTEGER ICNTYPE
*
*--   functions
      INTEGER JBYT
*
*--   local variables
      INTEGER III,ITAG,ICHA
*
      INTEGER NPACLU
      SAVE NPACLU
*
      IF (ICNTYPE.LT.0 .OR. ICNTYPE.GT.2) THEN
        WRITE (6,1000) IIIRUN,IIIEVT,ICNTYPE
        RETURN
      ENDIF
*
      IF (NECL.EQ.0) GOTO 999
*
*--   Initialise the PA couter the first time the routine runs for an event
*
      IF (ICNTYPE.LE.1) NPACLU = 0
*
      DO 10 III = 1,NECL
*
*--     Create the VECP entry
*
        ICHA = JBYT(NINT(DEMCLU(6,III)),17,2)
        IF ((ICHA.EQ.0 .AND. ICNTYPE.EQ.1) .OR.
     &    (ICHA.NE.0 .AND. ICNTYPE.EQ.2)) GOTO 10
*
        ITAG = JBYT(NINT(DEMCLU(6,III)),1,6)
        IF (ITAG.GE.30) GOTO 10
*
        NVECP = NVECP+1
        IF (ICHA.NE.0) THEN
          NCVECP = NCVECP+1
        ELSE
          NNVECP = NNVECP+1
        ENDIF
*
        VECP(4,NVECP) = DEMCLU(1,III)
        VECP(7,NVECP) = FLOAT(ICHA)
        IF (VECP(7,NVECP).EQ.2.) VECP(7,NVECP) = -1.
        IF (MOD(ITAG,10).EQ.1) THEN
          VECP(5,NVECP) = AMPI
          VECP(8,NVECP) = -2.*SIGN(1.,VECP(7,NVECP))
        ELSE
          VECP(5,NVECP) = 0.
          VECP(8,NVECP) = 21.
        ENDIF
        VECP(6,NVECP) = SQRT(VECP(4,NVECP)**2-VECP(5,NVECP)**2)
        VECP(1,NVECP) = VECP(6,NVECP)*SIN(DEMCLU(2,III))*COS(DEMCLU(3
     &    ,III))
        VECP(2,NVECP) = VECP(6,NVECP)*SIN(DEMCLU(2,III))*SIN(DEMCLU(3
     &    ,III))
        VECP(3,NVECP) = VECP(6,NVECP)*COS(DEMCLU(2,III))
        IVECP(9,NVECP) = ITAG
*
*--     Give dummy PA address
*
        LVECP(NVECP) = -999
        NPACLU = NPACLU+JBYT(NINT(DEMCLU(6,III)),19,6)
*
*--     Flag the REMCLU clusters in VECP
*
        CALL SBIT1(LVSELE(NVECP),30)
*
*--     Fill the corresponding entry in the REMCLU COMMON
*
        QEMCLU( 1,NVECP) =           DEMCLU( 1,III)
        QEMCLU( 2,NVECP) =           DEMCLU( 2,III)
        QEMCLU( 3,NVECP) =           DEMCLU( 3,III)
        QEMCLU( 4,NVECP) =           DEMCLU( 4,III)
        QEMCLU( 5,NVECP) =           DEMCLU( 5,III)
        KEMCLU( 6,NVECP) = JBYT(NINT(DEMCLU( 6,III)), 1, 6)
        KEMCLU( 7,NVECP) = 1000*III
        KEMCLU( 8,NVECP) = JBYT(NINT(DEMCLU( 6,III)), 19, 6)
        KEMCLU( 9,NVECP) = JBYT(NINT(DEMCLU( 6,III)), 17, 2)
        IF (KEMCLU( 9,NVECP).EQ.2) KEMCLU( 9,NVECP) = -1
*
 10   CONTINUE
 999  RETURN
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSMAIN-E-PSHREMFIL, ','Run',I7,', Event',I6
     +      ,/,1X,'Invalid operation code',I7,/)
      END
*
+DECK,PSVECWANT. *******************************************************
      INTEGER FUNCTION PSVECWANT(LPV,LPA)
************************************************************************
*                                                                      *
*     Name           :  PSVECWANT                                      *
*     Called By      :  PSHORTTRK                                      *
*     Task           :  Do we want to keep, reject, or                 *
*                       lock tracks from this vertex ?                 *
*                       0 - keep                                       *
*                       1 - reject                                     *
*                       2 - lock                                       *
*                       controlled by flag IFLVEC                      *
*                                                                      *
************************************************************************
       IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCEVT.
*
*--   arguments
      INTEGER LPV,LPA
*
*--   function
      INTEGER JBIT,LPHPA,JBYT
*
*--   local variables
      INTEGER LMAIN,NLPV,LPAO
*
      PSVECWANT=0
*
* reject outgoing tracks
       IF ( IFLVEC.EQ.2 ) THEN
         IF ( JBIT(IQ(LPV), 2) .GT. 0 ) PSVECWANT=1
         IF ( JBIT(IQ(LPV), 3) .GT. 0 ) PSVECWANT=1
       ENDIF
*
*--    Lock outgoing tracks
       IF ( IFLVEC.EQ.22 ) THEN
         IF ( JBIT(IQ(LPV), 2) .GT. 0 ) PSVECWANT=2
         IF ( JBIT(IQ(LPV), 3) .GT. 0 ) PSVECWANT=2
       ENDIF

*
       LMAIN = LPHPA('MAIN',LPA,0)
       IF (LMAIN.GT.0) THEN
         NLPV = LQ(LPA - 1)
         IF (NLPV.NE.0) THEN
*
*--        Reject new-incoming tracks
           IF ( IFLVEC.EQ.1 .AND. LPA.GT.0 ) THEN
             IF ( NINT(Q(LMAIN+8)).EQ.0 .OR.
     +            JBIT(IQ(NLPV), 3) .GT. 0 ) PSVECWANT=1
           ENDIF
*
*--        Lock new-incoming tracks
           IF ( IFLVEC.EQ.11 .AND. LPA.GT.0 ) THEN
              IF ( NINT(Q(LMAIN+8)).EQ.0 .OR.
     +             JBIT(IQ(NLPV), 3) .GT. 0 ) PSVECWANT=2
           ENDIF
*
         ENDIF
       ENDIF
*
* reject outgoing tracks and incoming REMCLU clusters (v 1.08)
       IF (ISVER.GE.108) THEN
         IF ( IFLVEC.EQ.3 ) THEN
*
*          Outgoing
*
           IF ( JBIT(IQ(LPV), 2) .GT. 0 ) PSVECWANT=1
           IF ( JBIT(IQ(LPV), 3) .GT. 0 ) THEN
             LPAO = LQ(LPV-2)
             IF (JBYT(IQ(LPAO+3),1,25).NE.0 .OR.
     &         JBYT(IQ(LPAO+3),26,3).EQ.0 .OR.
     &         IQ(LPAO+4).GT.2 .OR.
     &         JBYT(IQ(LPAO+3),26,3).NE.MOD(IQ(LPAO+1),1000)) THEN
               PSVECWANT = 1
             ELSE
               PSVECWANT = 0    ! keep original PAs of a cluster
             ENDIF
           ENDIF
*
*          Do not fill the incoming cluster
*
           LMAIN = LPHPA('MAIN',LPA,0)
           IF (LMAIN.GT.0) THEN
             NLPV = LQ(LPA - 1)
             IF (NLPV.NE.0) THEN
               IF ( JBIT(IQ(NLPV), 3) .GT. 0 .AND.
     &              JBYT(IQ(LPA+3),1,25).EQ.0 .AND.
     &              JBYT(IQ(LPA+3),26,3).NE.0 .AND.
     &              IQ(LPA+4).LE.2 .AND.
     &              JBYT(IQ(LPA+3),26,3).EQ.MOD(IQ(LPA+1),1000))
     &              PSVECWANT=1
             ENDIF
           ENDIF
*
         ENDIF
       ENDIF
*
       RETURN
       END
*
+DECK,PSHEVT. **********************************************************
      SUBROUTINE PSHEVT
************************************************************************
*                                                                      *
*     Name           :  PSHEVT                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  19, 1995                                  *
*     Task           :  To read the general event information          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCBSP.
*
*--   functions
      INTEGER IPHPIC,LPHPA,JBIT
      CHARACTER*4 CFROMI
*
*--   local variables
      INTEGER LPV,LPA,LMAIN
      INTEGER IDANA,IDENT
*
*--   Laboratory identifier
      LABO = CFROMI(IQ(LDTOP + 4))
*
*--   Processing identifier
      CALL DSTQID(CDTYPE)
*
*--   Center of mass energy  (GeV)
      IDANA = IPHPIC ( 'DANA', 0 )
      IF ( IDANA .LE. 0 ) THEN
         ECMAS = 91.250
      ELSE
         ECMAS = FLOAT(IPILOT(IDANA+13))/1000.
      END IF
*
+SELF,IF=-NOIFLENR.
*
*--   Energy correction for year 2000
      IF ( IFLENR .GT. 0 ) THEN
         IF ( IIIRUN .GE. 108613 ) THEN
            CALL PSECOR(ECMAS)
         ENDIF
      ENDIF
+SELF.
*
      EBEAM = ECMAS/2.
*
*--   Charged and neutral energy
      NCTRK = 0                         ! Charged multiplicity total
      NCTR4 = 0                         ! Charged multiplicity team4
      NNTRK = 0                         ! Neutral multiplicity
      ECHAR = 0.                        ! Total charged energy (MeV)
      EMNEU = 0.                        ! Total em. neutral energy (MeV)
      EHNEU = 0.                        ! Total had.neutral energy (MeV)
*
*--   PV  vertex bank address
      IF (LDTOP.LE.0) GOTO 50
      LPV=LQ(LDTOP-1)
      IF (LPV .LE. 0) GOTO 50
*
*--   Loop over the particles
   10 CONTINUE
      LPA = LQ(LPV-1)
   20 IF (LPA .LE. 0) GOTO 40
*
      LMAIN = LPHPA('MAIN',LPA,0)
*--   Charged or neutral track ?
      IF(NINT(Q(LMAIN+8)) .NE. 0) THEN
         NCTRK = NCTRK + 1
         IF(    Q(LMAIN+ 7)  .LT. 0.4)  GOTO 30        ! Momentum cut
         IF(    Q(LMAIN+ 9)  .LT. 30.)  GOTO 30        ! Track length
         IF(ABS(Q(LMAIN+11)) .GT.  4.)  GOTO 30        ! Rphi  impact
         IF(ABS(Q(LMAIN+20)) .GT. 10.)  GOTO 30        ! Z     impact
         IF(ABS(Q(LMAIN+19)/Q(LMAIN+6)).GT. 1.)        ! dE/E < 100 %
     +                                  GOTO 30
         IF(ABS(Q(LMAIN+5)/Q(LMAIN+7)) .GT..9397)      ! Cos  < 20 deg.
     +                                  GOTO 30
         NCTR4 = NCTR4 + 1
         ECHAR = ECHAR + Q(LMAIN+6)
      ELSE
         NNTRK = NNTRK + 1
         IF ( NINT(Q(LMAIN+10)) .EQ. 21   .OR.
     +        NINT(Q(LMAIN+10)) .EQ. 47 ) THEN
            EMNEU = EMNEU + Q(LMAIN + 6)
         ELSEIF(NINT(Q(LMAIN+10)) .NE. 0) THEN
            EHNEU = EHNEU + Q(LMAIN + 6)
         ENDIF
      ENDIF
*
   30 CONTINUE
      LPA = LQ(LPA)
                    GOTO 20
   40 CONTINUE
      LPV = LQ(LPV)
      IF (LPV.NE.0) GOTO 10
   50 CONTINUE
*
*--   Hadronic selection (Team 4)
      IHAD4 = 0
      IDENT = IPHPIC('IDEN',0)
      IF ( IDENT .GE. 0 ) THEN
         IF ( JBIT(IPILOT(IDENT+6),1) .EQ. 1 .AND.
     +        JBIT(IPILOT(IDENT+6),2) .EQ. 1) THEN
            IHAD4 = 1
         ENDIF
      ELSE
         IF ( NCTR4       .GE. 5     .AND.
     +        ECHAR/ECMAS .GE. 0.12 ) THEN
            IHAD4 = 1
         ENDIF
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHVTX. **********************************************************
      SUBROUTINE PSHVTX
************************************************************************
*                                                                      *
*     Name           :  PSHVTX                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  March 07, 1994                                 *
*     Last update    :  June  18, 1999                                 *
*     Task           :  To fill PSCVTX with vertex information         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCFLG.
+CDE, PSCTBL.
*
*--   functions
      INTEGER JBIT,JBYT
*
*--   local variables
      INTEGER LPV
      INTEGER LPAO
*
*--   PV  vertex bank address
      IF (LDTOP.LE.0) GOTO 90
      LPV=LQ(LDTOP-1)
*
*--   Loop over the verticies
      DO WHILE (LPV .NE. 0)
         IF ( IFLVEC .EQ. 1 ) THEN
            IF ( JBIT(IQ(LPV), 2) .GT. 0 ) GOTO 10
            IF ( JBIT(IQ(LPV), 3) .GT. 0 ) GOTO 10
         ENDIF
*
        IF ( IFLVEC .EQ. 3 ) THEN
           IF ( JBIT(IQ(LPV), 2) .GT. 0 ) GOTO 10
           IF ( JBIT(IQ(LPV), 3) .GT. 0 ) THEN
             LPAO = LQ(LPV-2)
             IF (JBYT(IQ(LPAO+3),1,25).NE.0 .OR.
     &         JBYT(IQ(LPAO+3),26,3).EQ.0 .OR.
     &         IQ(LPAO+4).GT.2 .OR.
     &         JBYT(IQ(LPAO+3),26,3).NE.MOD(IQ(LPAO+1),1000)) THEN
               GOTO 10
             ENDIF
           ENDIF
         ENDIF
*
         IF ( NVTX .GE. NVTXMX ) THEN
            WRITE(*,1000) NVTXMX,IIIRUN,IIIEVT,NEVENT
            GO TO 90
         ENDIF
*
         NVTX  = NVTX + 1
         LVTX(NVTX) = LPV
*
         KVTX( 3,NVTX) =     IQ(LPV + 2)
         KVTX( 4,NVTX) =     IQ(LPV + 3)
         KVTX( 5,NVTX) = NINT(Q(LPV + 4))
*
*--      Coordinates
         CALL ucopyr( Q(LPV + 5), QVTX( 6,NVTX), 3)
*
*--      Vertex fit
         QVTX( 9,NVTX) = Q(LPV + 8)
*
*--      Error matrix
         CALL ucopyr( Q(LPV + 9), QVTX(10,NVTX), 6)
*
*--      Status bits
         KVTX(17,NVTX) = JBYT(IQ(LPV), 1, 5)
*
   10    CONTINUE
         LPV = LQ(LPV)
      ENDDO
*
   90 CONTINUE
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHVTX, ','More than ',I4,' vertecies'
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSHVT2. **********************************************************
      SUBROUTINE PSHVT2
************************************************************************
*                                                                      *
*     Name           :  PSHVT2                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  March 07, 1994                                 *
*     Last update    :  June  18, 1999                                 *
*     Task           :  To fill PSCVTX with vertex information         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCFLG.
+CDE, PSCTBL.
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER LPV,LQIN,LQOUT,I
*
      DO I = 1,NVTX
         LPV = LVTX(I)
*
*--      Index of outgoing particle (first)
         LQOUT = LQ(LPV - 1)
         IF ( LQOUT .NE. 0 ) THEN
            KVTX( 1,I) = IUCOMP(LQOUT,LVECP,NVECP)
         ENDIF
*
*--      Index of incoming particle
         LQIN  = LQ(LPV - 2)
         IF ( LQIN  .NE. 0 ) THEN
            KVTX( 2,I) = IUCOMP(LQIN,LVECP,NVECP)
         ENDIF
      ENDDO
*
*--   Fill up the PA-PV correspondance table
      DO I = 1, NVECP
         IF  (LVECP(I).GT.0) THEN
           LPV = LQ(LVECP(I) + 1)
           IPAPV(1,I) = IUCOMP(LPV, LVTX, NVTX)
           LPV = LQ(LVECP(I) - 1)
           IF ( LPV .EQ. 0 ) THEN
             IPAPV(2,I) = 0
           ELSE
             IPAPV(2,I) = IUCOMP(LPV, LVTX, NVTX)
           ENDIF
         ENDIF
      ENDDO
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHVT2, ','More than ',I4,' vertecies'
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSHVEC. **********************************************************
      SUBROUTINE PSHVEC(LPA)
************************************************************************
*                                                                      *
*     Name           :  PSHVEC                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Mar 08, 1994                                   *
*     Last update    :  Nov 07, 1995                                   *
*     Task           :  To fill VECP vector for selected tracks        *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, PSCVTX.
+CDE, PSCVEC.
*
*--   arguments
      INTEGER LPA
*
*--   functions
      INTEGER LPHPA
      REAL ABS,VMOD
*
*--   local variables
      INTEGER LMAIN,LTRAC
      REAL    P,TRAC(5)
*
      REAL       XMPI
      PARAMETER (XMPI = 0.1395675)
*
      LVECP(NVECP)=LPA
*
*--   Get the standard module info
      LMAIN = LPHPA('MAIN',LPA, 0)
*
*--   Charged tracks
      IF ( NINT(Q(LMAIN+8)) .NE. 0 ) THEN
*
*--      Get the track at the perigee
         LTRAC = LPHPA('TRAC',LPA, 0)
         IF ( LTRAC .NE. 0 )    THEN
*
*--         Propagate perigee parameters
            IF (KVTX(16,1).LE.0) THEN
              CALL PSPGBM( QVTX(6,1), Q(LTRAC+2), TRAC(1) )
            ELSE
              CALL ucopyr(Q(LTRAC+2), TRAC(1),5)
            ENDIF
*
*--         Fill the momentum  P(x), P(y), P(z) and |P|
            P = ABS(Q(LMAIN+7))
            IF ( P .LE. 0.00001 ) THEN
               VECP(6,NVECP) = 0.
            ELSE
               VECP(6,NVECP) = P
            ENDIF
            VECP(1,NVECP) = VECP(6,NVECP)*SIN(TRAC(3))*COS(TRAC(4))
            VECP(2,NVECP) = VECP(6,NVECP)*SIN(TRAC(3))*SIN(TRAC(4))
            VECP(3,NVECP) = VECP(6,NVECP)*COS(TRAC(3))
*
*--         Fill the mass, energy and charge
            VECP(5,NVECP) = XMPI
            VECP(4,NVECP) = VMOD(VECP(5,NVECP),2)
*
            IF     ( NINT(Q(LMAIN+8)) .EQ. 1 ) THEN
               VECP(7,NVECP) = 1.
            ELSEIF ( NINT(Q(LMAIN+8)) .EQ. 2 ) THEN
               VECP(7,NVECP) =-1.
            ELSE
               VECP(7,NVECP) = 999.
            ENDIF
*
*--         Mass code & identification
            VECP(8,NVECP) =  Q(LMAIN+10)
            CALL MVBITS( IQ(LPA+3), 0, 18, IVECP(9,NVECP), 0 )
         ENDIF
      ELSE
*
*--   Neutral tracks
*
*--      Fill the momentum  P(x), P(y), P(z) and |P|
         P = ABS(Q(LMAIN+7))
         CALL ucopyr ( Q(LMAIN+3), VECP(1,NVECP), 3 )
         IF ( P .LE. 0.00001 ) THEN
            VECP(6,NVECP) = 0.
            VECP(1,NVECP) = 0.
            VECP(2,NVECP) = 0.
            VECP(3,NVECP) = 0.
         ELSE
            VECP(6,NVECP) = P
         ENDIF
*
*--      Fill the mass,energy and charge
         VECP(5,NVECP) = 0.
         VECP(4,NVECP) = VMOD(VECP(5,NVECP),2)
         VECP(7,NVECP) = 0.
*
*--      Mass code & identification
         VECP(8,NVECP) =  Q(LMAIN+10)
         CALL MVBITS( IQ(LPA+3), 18, 7, IVECP(9,NVECP), 18 )
      ENDIF
*
      END
*
+DECK,PSHTRA. **********************************************************
      SUBROUTINE PSHTRA(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHTRA                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Feb  19, 1995                                  *
*     Task           :  To read the PA.TRAC extra-module (8)           *
*                       and fill the track information common          *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, PSCEVT.
+CDE, PSCBSP.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCTBL.
+CDE, PSCTRA.
*
+CDE, AAMAIN.
+CDE, AAMNVX.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,IUCOMP
      REAL    VMOD
*
*--   local variables
      INTEGER LQUP,LQEND
      INTEGER LMAIN,LTRAC,LQMVDH
      INTEGER NVDH,NWPH,NH,LTH,IMOD,ILAY,IU
      INTEGER NHITR(3),NHITZ(3)
      REAL    VCOV(6),DCA(4)
*
*--   Access the standard PA module
      LMAIN = LPHPA ('MAIN', LPA, 0)
      IF ( LMAIN .LE. 0 )  GO TO 99
*
      NTRAC = NTRAC + 1
*
*--   Index of origin vertex
      LQUP = LQ(LVECP(I) + 1)
      IF ( LQUP .NE. 0 ) THEN
         KTRAC( 1,I) = IUCOMP(LQUP,LVTX,NVTX)
      ENDIF
*
*--   Index of end vertex (if any)
      LQEND = LQ(LVECP(I) - 1)
      IF ( LQEND .NE. 0 ) THEN
         KTRAC( 2,I) = IUCOMP(LQEND,LVTX,NVTX)
      ENDIF
*
*--   Index of simulated track
      KTRAC( 3,I) = IUCOMP(I,ISTPA,NST)
*
*--   For charged tracks
      IF ( NINT(Q(LMAIN+8)) .NE. 0 ) THEN
*
*--      Access the "TRAC" extra module
         LTRAC = LPHPA ('TRAC', LPA, 0)
         IF ( LTRAC .GT. 0 ) THEN
            CALL ucopyr(Q(LTRAC + 2), QTRAC( 4,I), 20)
         ENDIF
*
*--      Track length
         IU = IUCOMP(LPA,IADTR(1),100)
         IF ( IU .NE. 0 ) THEN
            IF ( INMVX(IU) ) THEN
               QTRAC(24,I) = ABS(Q(LMAIN + 9))
            ELSE
               QTRAC(24,I) =-ABS(Q(LMAIN + 9))
            ENDIF
         ELSE
            QTRAC(24,I) =-ABS(Q(LMAIN + 9))
         ENDIF
*
*--      Detectors used in the reconstruction
         KTRAC(25,I) = IQ(LPA + 2)
*
*--      First measured point of the track
         QTRAC(26,I) = VMOD(Q(LMAIN + 23),2)
         QTRAC(27,I) =      Q(LMAIN + 25)
*
*--      Chi2 of the track fit
         QTRAC(28,I) = Q(LMAIN + 16)
         QTRAC(29,I) = Q(LMAIN + 26)
*
*--      Number of d.o.f. of the track fit
         IF ( Q(LMAIN + 17) .LT.    0.   .OR.
     +        Q(LMAIN + 17) .GT. 1000. ) THEN
              Q(LMAIN + 17) = 0.
         ENDIF
*
         KTRAC(30,I) = NINT(Q(LMAIN + 17))
         KTRAC(31,I) = NINT(Q(LMAIN + 27))
*
*--      Impact parameters with geom. sign
*--      to the primary vertex
         CALL vfillr( DCA, 4, -999.)
         IF ( KVTX(16,1) .LE. 0 ) THEN
            CALL TBDCAE( QTRAC(4,I), QVTX(6,1), QVTX(10,1), DCA )
         ENDIF
         QTRAC(38,I) = DCA(1)
         QTRAC(39,I) = DCA(2)
*
*--      Impact parameters with geom. sign
*--      to the beam spot
         CALL vfillr( VCOV, 6,    0.)
         CALL vfillr(  DCA, 4, -999.)
         CALL TBDCAE( QTRAC(4,I), XYZBS, VCOV, DCA )
         QTRAC(40,I) = DCA(1)
*
*--      Energy error (for team4 cut)
         QTRAC(41,I) = Q(LMAIN + 19)
*
*--      Chi2 of VD associated hits
         QTRAC(42,I) = Q(LMAIN + 18)
*
*--      RPhi assoc. hits in VD
         LQMVDH  =  LQ(LDTOP - 21)
         IF ( LQMVDH .GT. 0 ) THEN
            NVDH =  IQ(LQMVDH - 3)             ! Number of ass. VD hits
            NWPH =  IQ(LQMVDH + 1)/1000        ! Number of words per hit
            CALL vzeroi(NHITR(1),3)
            CALL vzeroi(NHITZ(1),3)
*
*--         Loop over the VD hits
            DO NH = 1, NVDH
*              Reference link to the PA bank
               IF ( LQ(LQMVDH - NH) .EQ. LPA ) THEN
                  LTH = LQMVDH+1 + (NH-1)*NWPH
                  IMOD = NINT(Q(LTH + 1))
                  ILAY = ABS(IMOD)/100+ 1
                  IF (NINT(Q(LTH + 3)) .GT. 0) THEN
                     NHITR(ILAY) = NHITR(ILAY) + 1
                  ELSE
                     NHITZ(ILAY) = NHITZ(ILAY) + 1
                  ENDIF
               ENDIF
            ENDDO
*
            CALL SBYT(NHITR(1), KTRAC(32,I), 1, 2)
            CALL SBYT(NHITR(2), KTRAC(32,I), 3, 2)
            CALL SBYT(NHITR(3), KTRAC(32,I), 5, 2)
*
            CALL SBYT(NHITZ(1), KTRAC(33,I), 1, 2)
            CALL SBYT(NHITZ(2), KTRAC(33,I), 3, 2)
            CALL SBYT(NHITZ(3), KTRAC(33,I), 5, 2)
         ENDIF
*
*--   For neutral tracks
      ELSE
*
*--      Theta and Phi
         IF ( Q(LMAIN+7) .NE. 0. ) THEN
             QTRAC( 6,I) = ACOS (Q(LMAIN+5)/Q(LMAIN+7))     ! Theta
             QTRAC( 7,I) = ATAN2(Q(LMAIN+4),Q(LMAIN+3))     ! Phi
             IF ( QTRAC( 7,I) .LT. 0. )
     +       QTRAC( 7,I) = QTRAC( 7,I) + 2.*PI
         ENDIF
*
*--      Detectors used in the reconstruction
         KTRAC(25,I) = IQ(LPA + 2)
*
*--      Set the SAT tracker  (if charge = 3)
         IF ( NINT(Q(LMAIN+8)) .EQ. 3 )  THEN
            CALL SBYT( 1, KTRAC(25,I), 5, 1 )
         ENDIF
*
*--      Energy error (for cuts)
         QTRAC(41,I) = Q(LMAIN+19)
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHEMC. **********************************************************
      SUBROUTINE PSHEMC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHEMC                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  31, 1995                                  *
*     Task           :  To read the PA.EMNC extra-module (22)          *
*                       and fill the elm. calorimetry commons          *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, MTRACK.
+CDE, PSCEVT.
+CDE, PSCHPC.
+CDE, PSCEMF.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBIT,JBYT
      REAL    VMOD
*
*--   local variables
      INTEGER LEMNC,NSIDET,NSHOWR,IDET,LSHOWR,LPATTR
      INTEGER NLAYER,NL,JL,NCOUNT,NBLOCK,JB,IB,KB,NS
      INTEGER NSHEMF,NSMAX
      REAL    ESHOWR,EMFBLK(10),EMFEXB(16)
*
*--   Access the "EMNC" extra module
      LEMNC = LPHPA ('EMNC', LPA, 0)
      IF ( LEMNC .EQ. 0 )  GO TO 99
*
         NSIDET = NINT(Q(LEMNC+2))
         NSHOWR =  MOD(NSIDET,100)
           IDET =      NSIDET/100
         LSHOWR = LEMNC + 2
         ESHOWR = 0.
*
*--      Access the HPC information
         IF ( IDET .EQ.  9 ) THEN
            NHPC = NHPC + 1
*
*--         Loop over the showers
            DO NS = 1,NSHOWR
               IF ( Q(LSHOWR + 1) .GT. ESHOWR ) THEN
                  QHPC( 1,I) = Q(LSHOWR + 1)
                  QHPC( 2,I) = ACOS (Q(LSHOWR+4)/VMOD(Q(LSHOWR+2),3))
                  QHPC( 3,I) = ATAN2(Q(LSHOWR+3),Q(LSHOWR+2))
                  IF ( QHPC( 3,I) .LT. 0. )
     +            QHPC( 3,I) = QHPC( 3,I) + 2.*PI
                  KHPC( 4,I) = JBYT(IQ(LPA+3), 19, 7)
                  KHPC( 5,I) = NINT(Q(LSHOWR + 5))
                  KHPC( 6,I) = NINT(Q(LSHOWR + 6))
*
*--               Loop over the layers
                  LPATTR = NINT(Q(LSHOWR + 6))
                  NLAYER = 0
*
                  DO NL = 1, NHPLAY
                     JL = JBIT(LPATTR,NL)
                     IF (JL .EQ. 1)  THEN
                        NLAYER = NLAYER+1
                        HPCLAY(NL,I) = Q(LSHOWR + 6 + NLAYER)
                     ENDIF
                  ENDDO
*
                  ESHOWR  = Q(LSHOWR + 1)
               ENDIF
*
               KHPC( 7,I) = NSHOWR
               QHPC( 8,I) = QHPC( 8,I) + Q(LSHOWR + 1)
*
               LSHOWR = LSHOWR+ 6 + NINT(Q(LSHOWR + 5))
            ENDDO
         ENDIF
*
*--      Access the EMF information
         IF ( IDET .EQ. 26 ) THEN
            NEMF = NEMF + 1
*
*--         Loop over the showers
            DO NS = 1,NSHOWR
               IF ( Q(LSHOWR + 1) .GT. ESHOWR ) THEN
                  QEMF( 1,I) = Q(LSHOWR + 1)
                  QEMF( 2,I) = ACOS (Q(LSHOWR+4)/VMOD(Q(LSHOWR+2),3))
                  QEMF( 3,I) = ATAN2(Q(LSHOWR+3),Q(LSHOWR+2))
                  IF ( QEMF( 3,I) .LT. 0. )
     +            QEMF( 3,I) = QEMF( 3,I) + 2.*PI
                  KEMF( 4,I) = 0
                  NSMAX = NS
*
                  ESHOWR = Q(LSHOWR + 1)
               ENDIF
*
               KEMF( 7,I) = NSHOWR
               QEMF( 8,I) = QEMF( 8,I) + Q(LSHOWR + 1)
*
               LSHOWR = LSHOWR + 4
            ENDDO
*
            NSHEMF = NINT(Q(LSHOWR + 1))
            LSHOWR = LSHOWR + 1
*
            DO NS = 1,NSHEMF
               IF ( NS .EQ. NSMAX ) THEN
                  KEMF( 5,I) = NINT(Q(LSHOWR + 2))
                  KEMF( 6,I) = NINT(Q(LSHOWR + 3))
*
                  NCOUNT = NINT(Q(LSHOWR + 1))
                  LPATTR = NINT(Q(LSHOWR + 3))
                  NBLOCK = 0
*
                  CALL uzeror(EMFBLK,1,10)
                  CALL uzeror(EMFEXB,1,16)
*
                  DO IB = 1, 18
                     JB = JBIT(LPATTR,IB)
                     IF (JB .EQ. 1)  THEN
                        NBLOCK = NBLOCK+1
                        IF(IB .LE. 10) THEN
                          EMFBLK(IB  ) = Q(LSHOWR + 3 + NBLOCK)
                        ELSE
                          KB = 2* (IB-10)
                          EMFEXB(KB-1) = Q(LSHOWR + 3 + NBLOCK)
                          EMFEXB(KB  ) = Q(LSHOWR + 3 + NBLOCK)
                        ENDIF
                     ENDIF
                  ENDDO
               ENDIF
*
               IF ( ISVER .GE. 106 ) THEN
                  LSHOWR = LSHOWR + 4 + NINT(Q(LSHOWR + 2))
               ELSE
                  LSHOWR = LSHOWR + 3 + NINT(Q(LSHOWR + 2))
               ENDIF
            ENDDO
         ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHHAC. **********************************************************
      SUBROUTINE PSHHAC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHHAC                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  11, 1994                                  *
*     Task           :  To read the PA.HCNC extra-module (23)          *
*                       or the HCAL extra-module (3)                   *
*                       and fill the had. calorimetry commons          *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, MTRACK.
+CDE, PSCHAC.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
      REAL    VMOD
*
*--   local variables
      INTEGER LHCAL,LHCNC,LSHOWR,NSHOWR
      INTEGER NS,NLHITS,NL,NLAY,NTOW,NCHA
      REAL    ESHOWR,PMOM
*
*--   Access the HCNC extra module
      LHCNC = LPHPA ('HCNC',LPA,0)
      IF ( LHCNC .GT. 0 )    THEN
*
         NHAC = NHAC + 1
*
         NSHOWR = NINT(Q(LHCNC+2))
         LSHOWR = LHCNC + 2
         ESHOWR = 0.
*
*--      Loop over the showers
         DO NS = 1, NSHOWR
            IF ( Q(LSHOWR + 1) .GT. ESHOWR ) THEN
               QHAC( 1,I) = Q(LSHOWR + 1)
*
               PMOM = VMOD(Q(LSHOWR+2),3)
               IF ( PMOM .GT. 0. ) THEN
                  QHAC( 2,I) = ACOS (Q(LSHOWR+4)/PMOM)
                  QHAC( 3,I) = ATAN2(Q(LSHOWR+3),Q(LSHOWR+2))
                  IF ( QHAC( 3,I) .LT. 0. )
     +            QHAC( 3,I) = QHAC( 3,I) + 2.*PI
               ENDIF
*
               KHAC( 4,I) = 0
*
*--            Loop over layer hits
               NLHITS = NINT(Q(LSHOWR + 5))
*
               DO NL = 1, NLHITS
                  NLAY =     NINT(Q(LSHOWR + 5 + 2*NL))/1000
                  NTOW = MOD(NINT(Q(LSHOWR + 5 + 2*NL)),1000)
*
                  KHAC( 5,I) = KHAC( 5,I) + NTOW
                  CALL MVBITS( MIN(NTOW,255),0,8,KHAC( 6,I),(NLAY-1)*8 )
*
                  HACLAY(NLAY,I) = HACLAY(NLAY,I) + Q(LSHOWR + 5+2*NL-1) 
               ENDDO
*
               ESHOWR = Q(LSHOWR + 1)
            ENDIF
*
            KHAC( 7,I) = NSHOWR
            QHAC( 8,I) = QHAC( 8,I) + Q(LSHOWR + 1 )
*
            LSHOWR = LSHOWR + 5 + 2*NINT(Q(LSHOWR + 5))
         ENDDO
         GO TO 99
      ENDIF
*
*--   Access the HCAL extra module
      LHCAL = LPHPA ('HCAL',LPA,0)
      IF ( LHCAL .GT. 0 )    THEN
*
         NHAC = NHAC + 1
*
         NSHOWR = NINT(Q(LHCAL + 2))
         ESHOWR = 0.
*
*--      Loop over the showers
         DO NS = 1, NSHOWR
            LSHOWR = LPHPA('HCAL.SHOWER',LHCAL,NS)
            IF ( Q(LSHOWR + 3) .GT. ESHOWR )  THEN
               QHAC( 1,I) = Q(LSHOWR + 3)
*
               PMOM = VMOD(Q(LSHOWR+4),3)
               IF ( PMOM .GT. 0 ) THEN
                  QHAC( 2,I) = ACOS (Q(LSHOWR+6)/PMOM)
                  QHAC( 3,I) = ATAN2(Q(LSHOWR+5),Q(LSHOWR+4))
                  IF ( QHAC( 3,I) .LT. 0. )
     +            QHAC( 3,I) = QHAC( 3,I) + 2.*PI
               ENDIF
*
               KHAC( 4,I) = 0
*
*--            Loop over the layer hits
               NLHITS = NINT(Q(LSHOWR+10))
*
               DO NL = 1, NLHITS
                  NLAY =     NINT(Q(LSHOWR + 11 + 2*NL))/1000
                  NCHA = MOD(NINT(Q(LSHOWR + 11 + 2*NL)),1000)
*
                  KHAC( 5,I) = KHAC( 5,I) + NCHA
                  CALL MVBITS( MIN(NCHA,255),0,8,KHAC( 6,I),(NLAY-1)*8 )
*
                  HACLAY(NLAY,I) = HACLAY(NLAY,I) + Q(LSHOWR +11+2*NL-1) 
               ENDDO
*
               ESHOWR = Q(LSHOWR + 3)
            ENDIF
*
            KHAC( 7,I) = NSHOWR
            QHAC( 8,I) = QHAC( 8,I) + Q(LSHOWR + 3)
         ENDDO
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHMUO. **********************************************************
      SUBROUTINE PSHMUO(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHMUO                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  30, 1994                                  *
*     Task           :  To read the PA.MUID extra-module (24)          *
*                       and fill the muon identification commons       *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, MTRACK.
+CDE, PSCMUD.
+CDE, PSCMUV.
+CDE, PSCMUL.
+CDE, PSCMUT.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBIT
*
*--   local variables
      INTEGER LMUID,IDAT
*
*--   Mass assignement for muons
      CALL MVBITS(IQ(LPA+3), 0, 5, KMUID(1,I), 0)
*
*--   Access the "MUID" extra module
      LMUID = LPHPA ('MUID', LPA, 0)
      IF ( LMUID .EQ. 0 )  GO TO 99
*
         IDAT = 2
*
*--      General muon identification
         IF ( JBIT(NINT(Q(LMUID + 2)), 1) .NE. 0 ) THEN
           NMUID = NMUID + 1
           QMUID(2,I) =      Q(LMUID + IDAT + 2)
           KMUID(3,I) = NINT(Q(LMUID + IDAT + 3))
         ENDIF
*
*--      Very loose identification
         IF ( JBIT(NINT(Q(LMUID + 2)), 1) .NE. 0 ) THEN
            NMUVL = NMUVL + 1
            KMUVL(1,I) = NINT(Q(LMUID + IDAT + 1))
            CALL ucopyr( Q(LMUID + IDAT + 2), QMUVL(2,I), LENMUV-1 )
            IDAT  = IDAT  + LENMUV
         ENDIF
*
*--      Loose and standard identification
         IF ( JBIT(NINT(Q(LMUID + 2)), 2) .NE. 0 ) THEN
            NMULS = NMULS + 1
            KMULS(1,I) = NINT(Q(LMUID + IDAT + 1))
            CALL ucopyr( Q(LMUID + IDAT + 2), QMULS(2,I), LENMUL-1 )
            IDAT  = IDAT  + LENMUL
         ENDIF
*
*--      Tight identification
         IF ( JBIT(NINT(Q(LMUID + 2)), 3) .NE. 0 ) THEN
            NMUTI = NMUTI + 1
            KMUTI(1,I) = NINT(Q(LMUID + IDAT + 1))
            CALL ucopyr( Q(LMUID + IDAT + 2), QMUTI(2,I), LENMUT-1 )
            IDAT  = IDAT  + LENMUT
         ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHELE. **********************************************************
      SUBROUTINE PSHELE(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHELE                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  09, 1993                                  *
*     Last update    :  May  15, 1994                                  *
*     Task           :  To read the PA.ELID extra-module (25)          *
*                       and fill the elec. identification commons      *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PXCONS.
+CDE, ELOUTP.
+CDE, MTRACK.
+CDE, PSCELD.
+CDE, PSCELO.
+CDE, PSCELT.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBYT
*
*--   local variables
      INTEGER LMAIN,LELID,LELTR
      INTEGER LHAID,LHDAT,NWIR
      INTEGER ITAG,IATAG,IVETO,IDAT,IDATI
      REAL    DEDX,SIGM,ERROR
      REAL    PT,P
*
      IF ( I .EQ. 0 ) THEN
*
         IF ( ISVER  .LT. 102 ) THEN
            CALL PXPINI
         ENDIF
*
         RETURN
      ENDIF
*
*--   Electron identification flags
      IATAG = JBYT(IQ(LPA+3),  7, 3)
      IVETO = JBYT(IQ(LPA+3), 10, 3)
      KELID(1,I) = IATAG
      KELID(2,I) = IVETO
*
*--   Access the standard PA module
      LMAIN = LPHPA ('MAIN', LPA, 0)
      IF ( LMAIN .GT. 0 )      THEN
*
         IF ( IATAG .GT. 1 ) THEN
            NELID = NELID + 1
*
            QELID(3,I) = Q(LMAIN + 3)             !Px of elec. fixed
            QELID(4,I) = Q(LMAIN + 4)             !Py of elec. fixed
            QELID(5,I) = Q(LMAIN + 5)             !Pz of elec. fixed
*
*--         Access the "ELTR" extra module
            LELTR = LPHPA ('ELTR', LPA, 0)
            IF ( LELTR .GT. 0 )      THEN
*
               IF (Q(LELTR + 4) .NE. 0. .AND.
     +             Q(LELTR + 6) .NE. 0.) THEN
                   PT = CONSA*BMAG/Q(LELTR+6)
                   P  = ABS(PT/SIN(Q(LELTR+4)))
*
                   QELID(3,I) = P*SIN(Q(LELTR+4))*COS(Q(LELTR+5))
                   QELID(4,I) = P*SIN(Q(LELTR+4))*SIN(Q(LELTR+5))
                   QELID(5,I) = P*COS(Q(LELTR+4))
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
*--   Access the "ELID" extra module
      LELID = LPHPA ('ELID', LPA, 0)
      IF ( LELID .GT. 0 )      THEN
*
         NELOU = NELOU + 1
*
         IF ( ISVER .LT. 102 ) THEN
            CALL ELMACO(LPA,ITAG,IVETO)
*
            QELOU( 1,I) = Q(LELID +  9)           ! EOVERP
            QELOU( 2,I) = Q(LELID + 10)           ! ELDZS
            QELOU( 3,I) = Q(LELID + 11)           ! ELDPHI
            QELOU( 4,I) = Q(LELID + 23)           ! ELDFI
*
            QELOU( 8,I) = Q(LELID + 18)           ! PREOVP
            QELOU( 9,I) = Q(LELID +  6)           ! PRSHFI
            QELOU(10,I) = Q(LELID + 19)           ! PRDZS
            QELOU(11,I) = PRDPHI                  ! PRDPHI
            QELOU(12,I) = PRDEDX                  ! PRDEDX
            QELOU(13,I) = PRDEXP                  ! PRDEXP
            QELOU(14,I) = Q(LELID +  4)           ! PRHPC
            QELOU(15,I) = PROBEL                  ! PROBEL
            QELOU(16,I) = Q(LELID + 14)           ! PRNSHO
            QELOU(17,I) = Q(LELID + 15)           ! PRNSOD
            QELOU(18,I) = Q(LELID + 21)           ! PRRGA1
            QELOU(19,I) = Q(LELID + 13)           ! PRGGA2
            QELOU(20,I) = Q(LELID +  8)           ! ELEFLG
            QELOU(21,I) = Q(LELID +  7)           ! ELEFIT
            QELOU(22,I) = Q(LELID + 12)           ! ELZEXR0
            QELOU(23,I) = ELPHIR0                 ! ELPHIR0
            QELOU(24,I) = Q(LELID +  5)           ! ELRCON
            QELOU(25,I) = Q(LELID + 20)           ! ELRICH
            QELOU(26,I) = ELHPCF                  ! ELHPCF
            QELOU(27,I) = ELPREF                  ! ELPREF
            QELOU(28,I) = EELEC                   ! EELEC
            QELOU(29,I) = ELCURI                  ! ELCURI
            QELOU(30,I) = ELCURO                  ! ELCURO
            QELOU(31,I) = ELCH2I                  ! ELCH2I
            QELOU(32,I) = ELCH2O                  ! ELCH2O
            QELOU(33,I) = ELROTA                  ! ELROTA
            QELOU(34,I) = ELSIGN                  ! ELSIGN
         ELSE
            QELOU( 1,I) = Q(LELID +  9)           ! EOVERP
            QELOU( 2,I) = Q(LELID + 10)           ! ELDZS
            QELOU( 3,I) = Q(LELID + 11)           ! ELDPHI
            QELOU( 4,I) = Q(LELID + 23)           ! ELDFI
*
            QELOU( 8,I) = Q(LELID + 18)           ! PREOVP
            QELOU( 9,I) = Q(LELID +  6)           ! PRSHFI
            QELOU(10,I) = Q(LELID + 19)           ! PRDZS
            QELOU(11,I) = Q(LELID + 33)           ! PRDPHI
            QELOU(12,I) = Q(LELID + 35)           ! PRDEDX
            QELOU(13,I) = Q(LELID + 36)           ! PRDEXP
            QELOU(14,I) = Q(LELID +  4)           ! PRHPC
            QELOU(15,I) = Q(LELID + 34)           ! PROBEL
            QELOU(16,I) = Q(LELID + 14)           ! PRNSHO
            QELOU(17,I) = Q(LELID + 15)           ! PRNSOD
            QELOU(18,I) = Q(LELID + 21)           ! PRRGA1
            QELOU(19,I) = Q(LELID + 13)           ! PRRGA2
            QELOU(20,I) = Q(LELID +  8)           ! ELEFLG
            QELOU(21,I) = Q(LELID +  7)           ! ELEFIT
            QELOU(22,I) = Q(LELID + 12)           ! ELZEXR0
            QELOU(23,I) = Q(LELID + 40)           ! ELPHIR0
            QELOU(24,I) = Q(LELID +  5)           ! ELRCON
            QELOU(25,I) = Q(LELID + 20)           ! ELRICH
            QELOU(26,I) = Q(LELID + 28)           ! ELHPCF
            QELOU(27,I) = Q(LELID + 39)           ! ELPREF
            QELOU(28,I) = Q(LELID + 29)           ! EELEC
            QELOU(29,I) = Q(LELID + 24)           ! ELCURI
            QELOU(30,I) = Q(LELID + 25)           ! ELCURO
            QELOU(31,I) = Q(LELID + 26)           ! ELCH2I
            QELOU(32,I) = Q(LELID + 27)           ! ELCH2O
            QELOU(33,I) = Q(LELID + 37)           ! ELROTA
            QELOU(34,I) = Q(LELID + 38)           ! ELSIGN
         ENDIF
*
*--      Access the "HAID" extra module
         LHAID = LPHPA ('HAID', LPA, 0)
         IF ( LHAID .GT. 0 )      THEN
*
            LHDAT  = NINT(Q(LHAID+2))
            IDATI  = MOD(LHDAT,10)
            IDAT   = 2
*
            IF ( IDATI .GE. 4 ) THEN
               QELOU( 5,I) = Q(LHAID + IDAT + 1)
               QELOU( 7,I) = Q(LHAID + IDAT + 3)
               IF ( ISVER .LT. 102 ) THEN
                  QELOU( 6,I) = Q(LHAID + IDAT + 4)
               ELSE
                  CALL GETDEDX(LPA,DEDX,SIGM,NWIR,ERROR)
                  QELOU( 6,I) =   ERROR
               ENDIF
            ENDIF
         ENDIF
      ENDIF
*
*--   Access the "ELTR" extra module
      LELTR = LPHPA ('ELTR', LPA, 0)
      IF ( LELTR .GT. 0 )      THEN
*
         NELTR = NELTR + 1
*
         QELTR( 1,I) = Q(LELTR + 2)               ! R Phi imp. parameter
         QELTR( 2,I) = Q(LELTR + 3)               ! Z     imp. parameter
         QELTR( 3,I) = Q(LELTR + 4)               ! Theta
         QELTR( 4,I) = Q(LELTR + 5)               ! Phi
         QELTR( 5,I) = Q(LELTR + 6)               ! 1/R (R-cur.radius)
         CALL ucopyr(Q(LELTR+7),QELTR( 6,I),15)    ! Err. matrix
      ENDIF
*
      END
*
+DECK,PSHHAD. **********************************************************
      SUBROUTINE PSHHAD(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHHAD                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  07, 1993                                  *
*     Last update    :  Mar  03, 1997                                  *
*     Task           :  To read the PA.HAID extra-module (26)          *
*                       and fill the hadron identification commons     *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
*
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCHAD.
+CDE, PSCDEX.
+CDE, PSCGRC.
+CDE, PSCLRC.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBYT
      REAL    VMOD,BBDXER
*
*--   local variables
      INTEGER LMAIN,IRICH,IDTAN,IQFLAG
      INTEGER LHAID,LHDAT,IDAT
      INTEGER IDATI,IDATG,IDATL
      INTEGER IDATV,IDATR,IDATQ,IDATT
      INTEGER IHAD1,IHAD2,NWIR
      INTEGER METHOD,IQUAL
      REAL    DEDX,SIGM,ERROR,GAP
      REAL    PMOM,PRICH(5)
      REAL    EDEDX(5),DDEDX(5),UDEDX(5),PDEDX(5)
*
      IF ( I .EQ. 0 ) THEN
         CALL RICHID
         RETURN
      ENDIF
*
*--   Access the "HAID" extra module
      LHAID = LPHPA ('HAID', LPA, 0)
      IF ( LHAID .EQ. 0 )  GO TO 99
*
         LHDAT  = NINT(Q(LHAID + 2))
         IDATI  = MOD(LHDAT       ,10)       ! Number of ionization  data
         IDATG  = MOD(LHDAT/10    ,10)       ! Number of RICH gas    data
         IDATL  = MOD(LHDAT/100   ,10)       ! Number of RICH liquid data
         IDATV  = MOD(LHDAT/1000  ,10)       ! Number of VD (dE/dx)  data
         IDATR  = MOD(LHDAT/10000 ,10)       ! Number of Ringscan    data
         IDATQ  = MOD(LHDAT/100000,10)       ! Number of RICH status data
         IDATT  =     LHDAT/1000000          ! Number of TPC (dE/dx) data
         IDAT   = 2
*
         LMAIN = LPHPA('MAIN',LPA,0)
         PMOM  = VMOD (Q(LMAIN+3),3)
*
*--      dE/dx identification
         IF ( IDATI .GE. 4 ) IDAT = IDAT + 4
*
         IF ( IQ(LDTOP+3) .LT. 333 ) THEN
            CALL GETDEDX( LPA, DEDX, SIGM, NWIR, ERROR)
         ELSE
            CALL BBDXGET( LPA, DEDX, GAP, NWIR, METHOD)
            IF ( NWIR .GT. 1 ) THEN
               ERROR = BBDXER( DEDX, GAP, NWIR, METHOD, IQUAL )
            ELSE
               ERROR = -1.
            ENDIF
            NWIR = NINT(NWIR*.8)
         ENDIF
*
         IF ( DEDX .NE. 0. ) THEN
            QDEDX( 1,I) = DEDX
            QDEDX( 2,I) = 0.
            KDEDX( 3,I) = NWIR
            QDEDX( 4,I) = 0.
            QDEDX( 5,I) = ERROR
*
            NDEDX = NDEDX + 1
         ENDIF
*
*--      dE/dx identification
*
*--      Kaon/Proton/Pion signature with dE/dx & RICH
         KHAID( 2,I) = -1
         KHAID( 3,I) = -1
         KHAID( 4,I) = -1
         KHAID( 5,I) = -1
         KHAID( 6,I) = -1
         QHAID( 7,I) = -1.
         QHAID( 8,I) = -1.
         KHAID( 9,I) = -1
*
         IF ( IDATI .EQ. 2 .OR. IDATI .EQ. 6 ) THEN
            IHAD1  = NINT(Q(LHAID + IDAT + 1))
            IHAD2  = NINT(Q(LHAID + IDAT + 2) * 10.)
*
*--         Used for combined tag (DEDX, RICH, both)
            KHAID( 1,I) = JBYT( IHAD1,  7, 4 )
            ISIGN(   I) = KHAID( 1,I)
*
*--         Kaon and proton signature with dE/dx
            KHAID( 2,I) = JBYT( IHAD1,  1, 3 ) - 1
            KHAID( 3,I) = JBYT( IHAD1,  4, 3 ) - 1
            IDKAON  (I) = KHAID( 2,I)
            IDPROTON(I) = KHAID( 3,I)
*
*--         Kaon, proton and pion signature with RICH
            KHAID( 4,I) = JBYT( IQ(LPA+3),13, 3 )- 1
            KHAID( 5,I) = JBYT( IQ(LPA+3),16, 3 )- 1
            KHAID( 6,I) = JBYT( IHAD1, 11, 3 ) - 1
            IKAON   (I) = KHAID( 4,I)
            IPROTON (I) = KHAID( 5,I)
            IPION   (I) = KHAID( 6,I)
*
*--         Combined kaon and proton tag
            QHAID( 7,I) = FLOAT(MOD(IHAD2,100)-10)/10.
            QHAID( 8,I) = FLOAT(    IHAD2/100 -10)/10.
            XKAON   (I) = QHAID( 7,I)
            XPROTON (I) = QHAID( 8,I)
*
            NHAID = NHAID + 1
            IDAT  = IDAT  + 2
         ENDIF
*
*--      New hadron identification based on...
         CALL vfilli( KHAIDN(1,I), LNHADN, -1 )
         CALL vfilli( KHAIDT(1,I), LNHADN, -1 )
         CALL vfilli( KHAIDR(1,I), LNHADR, -1 )
         CALL vfilli( KHAIDE(1,I), LNHADE, -1 )
         CALL vfilli( KHAIDC(1,I), LNHADC, -1 )
*
         IDTAN = IQ(  LPA  + 1 )
*
         LMAIN = LPHPA('MAIN',LPA,0)
         PMOM  = VMOD (Q(LMAIN+3),3)
         IF ( PMOM .GT.  0. )  THEN
                                               IRICH = 1
            IF( ABS(Q(LMAIN+5)/PMOM) .GT. .7 ) IRICH = 2
*
*--         ... RICH gas/liquid, Cherenkov angle,
*--         number of photons and quality flag
*
            CALL GETMINE( 1 )
            CALL XNEWTAG( IDTAN, KHAIDN(1,I), KHAIDN(2,I),
     +                           KHAIDN(3,I), KHAIDN(4,I),
     +                           KHAIDT(1,I), KHAIDT(2,I),
     +                           KHAIDT(3,I), KHAIDT(4,I))
*
*--         ... RICH gas/liquid and RIBMEAN probablities
*
            CALL XNEWPRO( IDTAN, KHAIDR(1,I), KHAIDR(2,I), KHAIDR(3,I),  
     +                           KHAIDR(4,I), KHAIDR(5,I), KHAIDR(6,I),
     +                           PRICH )
*
*--         ... dE/dx in TPC using probablities
*
            IF ( IQ(LDTOP+3) .LT. 333 ) THEN
               CALL GETDEDX( LPA, DEDX, SIGM, NWIR, ERROR )
               CALL RPRODO ( PMOM, IRICH, DEDX, SIGM, NWIR,
     +                       EDEDX,  DDEDX,  UDEDX,  PDEDX,
     +                       IQFLAG     , KHAIDE(1,I), KHAIDE(2,I),
     +                       KHAIDE(3,I), KHAIDE(4,I), KHAIDE(5,I))
            ELSE
               CALL RPRODE ( LPA,
     +                       PMOM, IRICH, DEDX, SIGM, NWIR,
     +                       EDEDX,  DDEDX,  UDEDX,  PDEDX,
     +                       IQFLAG     , KHAIDE(1,I), KHAIDE(2,I),
     +                       KHAIDE(3,I), KHAIDE(4,I), KHAIDE(5,I))
            ENDIF
*
            IF ( IQFLAG .EQ. 2 )  KHAIDE( 6,I) = 1
*
*--         ... combined RICH and TPC probablities
*
            CALL RPROCO( PMOM, PDEDX, PRICH, IRICH,
     +                   KHAIDC(1,I),  KHAIDC(2,I),
     +                   KHAIDC(3,I),  KHAIDC(4,I),
     +                   KHAIDC(5,I))
*
            IF ( KHAIDR(6,I) .GE. 0 ) THEN
               KHAIDC(6,I) = KHAIDR(6,I)
               IF ( IQFLAG .EQ. 2 ) CALL SBIT1(KHAIDC(6,I), 3)
            ELSE
               IF ( IQFLAG .EQ. 2 ) THEN
                  KHAIDC(6,I) = 0
                  CALL SBIT1(KHAIDC(6,I), 3)
              ENDIF
           ENDIF
*
         ENDIF
*
*--      RICH gas data
         IF ( IDATG .NE. 0 ) THEN
            QGRIC( 1,I) =          Q(LHAID + IDAT + 1)
            QGRIC( 2,I) =          Q(LHAID + IDAT + 2)
            KGRIC( 3,I) = MOD(NINT(Q(LHAID + IDAT + 3)),500)
            IF ( ISVER .LE. 102 ) THEN
               QGRIC( 4,I) =       Q(LHAID + IDAT + 3)/500.
            ELSE
               QGRIC( 4,I) =  AINT(Q(LHAID + IDAT + 3) /500.)/10.
            ENDIF
            KGRIC( 5,I) =     NINT(Q(LHAID + IDAT + 4))
*
            THEG    (I) = QGRIC( 1,I)
            SIGG    (I) = QGRIC( 2,I)
            NPHG    (I) = KGRIC( 3,I)
            NEPG    (I) = NINT(QGRIC( 4,I))
            FLAGG   (I) = KGRIC( 5,I)
*
            NGRIC = NGRIC + 1
            IDAT  = IDAT  + IDATG
         ENDIF
*
*--      RICH liquid data
         IF ( IDATL .NE. 0 ) THEN
            QLRIC( 1,I) =          Q(LHAID + IDAT + 1)
            QLRIC( 2,I) =          Q(LHAID + IDAT + 2)
            KLRIC( 3,I) = MOD(NINT(Q(LHAID + IDAT + 3)),500)
            IF ( ISVER .LE. 102 ) THEN
               QLRIC( 4,I) =       Q(LHAID + IDAT + 3)/500.
            ELSE
               QLRIC( 4,I) =  AINT(Q(LHAID + IDAT + 3) /500.)/10.
            ENDIF
            KLRIC( 5,I) =     NINT(Q(LHAID + IDAT + 4))
*
            THEL    (I) = QLRIC( 1,I)
            SIGL    (I) = QLRIC( 2,I)
            NPHL    (I) = KLRIC( 3,I)
            NEPL    (I) = NINT(QLRIC( 4,I))
            FLAGL   (I) = KLRIC( 5,I)
*
            NLRIC = NLRIC + 1
            IDAT  = IDAT  + IDATL
         ENDIF
*
*--      dE/dx from VD only
         IF ( IDATV .NE. 0 ) THEN
            QDEDX( 6,I) =      Q(LHAID + IDAT + 1)
            KDEDX( 7,I) = NINT(Q(LHAID + IDAT + 2))
*
            NDEDX = NDEDX + 1
            IDAT  = IDAT  + IDATV
         ENDIF
*
*--      RINGSCAN words
         IF ( IDATR .NE. 0 ) THEN
            IDAT = IDAT + IDATR
         ENDIF
*
*--      RICH quality word
         IF ( IDATQ .NE. 0 ) THEN
            KHAID( 9,I) = NINT(Q(LHAID + IDAT + 1))
*
            NHAID = NHAID + 1
            IDAT  = IDAT  + IDATQ
         ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHPHO. **********************************************************
      SUBROUTINE PSHPHO(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHPHO                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Nov  21, 1994                                  *
*     Last update    :  Mar  19, 1995                                  *
*     Task           :  To read the PA.PHOT extra-module (30)          *
*                       and fill the photon and pi0 ident. commons     *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCPHO.
+CDE, PSCPI0.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
*
*--   local variables
      INTEGER LPHOT,LPDAT
      INTEGER LNPHO,LNPI0,IDAT
*
*--   Access the "PHOT" extra module
      LPHOT = LPHPA ('PHOT', LPA, 0)
      IF ( LPHOT .EQ. 0 )  GO TO 99
*
         LPDAT  = NINT(Q(LPHOT+2))
         LNPHO  =  MOD(LPDAT,100)            ! Length of photon data
         LNPI0  =      LPDAT/100             ! Length of pi0    data
         IDAT   = 2
*
         IF ( LNPHO .GT. 0 ) THEN
            QPHOT( 1,I) =          Q(LPHOT + IDAT + 1)
            KPHOT( 2,I) =     NINT(Q(LPHOT + IDAT + 2))/1000
            KPHOT( 3,I) = MOD(NINT(Q(LPHOT + IDAT + 2))/100 ,10)
            KPHOT( 4,I) = MOD(NINT(Q(LPHOT + IDAT + 2))/10  ,10)
            KPHOT( 5,I) = MOD(NINT(Q(LPHOT + IDAT + 2))     ,10)
            QPHOT( 6,I) =          Q(LPHOT + IDAT + 3)
            QPHOT( 7,I) =          Q(LPHOT + IDAT + 4)
*
            NPHOT = NPHOT + 1
            IDAT  = IDAT  + LNPHO - 1
         ENDIF
*
         IF ( LNPI0 .GT. 0 ) THEN
            QPI0( 1,I) =          Q(LPHOT + IDAT +  1)
            QPI0( 2,I) =          Q(LPHOT + IDAT +  2)
            QPI0( 3,I) =          Q(LPHOT + IDAT +  3)
            QPI0( 4,I) =          Q(LPHOT + IDAT +  4)
            KPI0( 5,I) =     NINT(Q(LPHOT + IDAT +  5))
            KPI0( 6,I) =     NINT(Q(LPHOT + IDAT +  6))
            QPI0( 7,I) =          Q(LPHOT + IDAT +  7)
            QPI0( 8,I) =          Q(LPHOT + IDAT +  8)
            QPI0( 9,I) =          Q(LPHOT + IDAT +  9)
            QPI0(10,I) =          Q(LPHOT + IDAT + 10)
            QPI0(11,I) =          Q(LPHOT + IDAT + 11)
            QPI0(12,I) =          Q(LPHOT + IDAT + 12)
            QPI0(13,I) =          Q(LPHOT + IDAT + 13)
            QPI0(14,I) =          Q(LPHOT + IDAT + 14)
            QPI0(15,I) =          Q(LPHOT + IDAT + 15)
            QPI0(16,I) =          Q(LPHOT + IDAT + 16)
            QPI0(17,I) =          Q(LPHOT + IDAT + 17)
            QPI0(18,I) =          Q(LPHOT + IDAT + 18)
            QPI0(19,I) =          Q(LPHOT + IDAT + 19)
            KPI0(20,I) = MOD(NINT(Q(LPHOT + IDAT + 20)),100)
            KPI0(21,I) =     NINT(Q(LPHOT + IDAT + 20))/100
*
            IF ( LNPI0 .GT. 20 ) THEN
               QPI0(22,I) =       Q(LPHOT + IDAT + 23)
               KPI0(23,I) =  NINT(Q(LPHOT + IDAT + 24))
               QPI0(24,I) =       Q(LPHOT + IDAT + 25)
               QPI0(25,I) =       Q(LPHOT + IDAT + 26)
               QPI0(26,I) =       Q(LPHOT + IDAT + 27)
            ENDIF
*
            NPI0 = NPI0 + 1
            IDAT = IDAT + LNPI0
         ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSHSTC. **********************************************************
      SUBROUTINE PSHSTC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSHSTC                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  May  26, 1995                                  *
*     Last update    :  July 07, 1996                                  *
*     Task           :  To fill the STIC information commons           *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, MTRACK.
+CDE, PSCSTC.
+CDE, PSCEVT.
+CDE, PXCONS.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBIT
      REAL    VMOD
*
*--   local variables
      INTEGER LSTIC,LSSTC,LMAIN,LSHOWR,LVETOS
      INTEGER NSHOWR,LENSHO,IHITS
      INTEGER ISL1,ISC1,ISR1,ISL2,ISC2,ISR2
      INTEGER ISECT,ISE,ISL,ISH,IARM
      INTEGER IFLAG1,IFLAG2,KFLAG1,KFLAG2
      INTEGER IVEDIS(2)
      REAL    PMOM
*
*--   Access the STIC extra module
      LSTIC = LPHPA ('STIC',LPA,0)
      IF ( LSTIC  .GT.  0 )  THEN
         CALL PSFSTC ( LPA, I )
         GO TO 99
      ENDIF
*
      IF ( ISVER  .LE. 103 ) THEN
*
         LSSTC = LPHPA ('SSTC',LPA,0)
         IF ( LSSTC  .GT.  0 )  THEN
*
            NSTIC  = NSTIC + 1
*
*--         Access the MAIN extra module
            LMAIN = LPHPA ('MAIN',LPA,0)
*
            QSTIC( 1,I) = Q(LMAIN + 6)
*
            PMOM = VMOD(Q(LMAIN+3), 3)
            IF ( PMOM .GT. 0. )  THEN
               QSTIC( 2,I) = ACOS (Q(LMAIN+5)/PMOM)
               QSTIC( 3,I) = ATAN2(Q(LMAIN+4),Q(LMAIN+3))
               IF ( QSTIC( 3,I) .LT. 0. )
     +         QSTIC( 3,I) = QSTIC( 3,I) + 2.*PI
            ENDIF
*
            KSTIC( 4,I) = NINT(Q(LSSTC + 4)/10.)
            KSTIC( 5,I) = 0
            KSTIC( 6,I) = 0
*
            GO TO 99
         ENDIF
      ENDIF
*
*--   Access the SSTC extra module
      LSSTC = LPHPA ('SSTC',LPA,0)
      IF ( LSSTC .EQ. 0 ) GO TO 99
*
         NSTIC  = NSTIC + 1
*
         NSHOWR = NINT(Q(LSSTC  + 2))
         LSHOWR = LSSTC + 2
         LENSHO = NINT(Q(LSHOWR + 1))
*
*--      Access the MAIN extra module
         LMAIN = LPHPA ('MAIN',LPA,0)
*
*--      For each shower (only one per track)
CCC      DO NS = 1, NSHOWR
            QSTIC( 1,I) = Q(LMAIN + 6)
*
            PMOM = VMOD(Q(LMAIN+3), 3)
            IF ( PMOM .GT. 0. )  THEN
               QSTIC( 2,I) = ACOS (Q(LMAIN+5)/PMOM)
               QSTIC( 3,I) = ATAN2(Q(LMAIN+4),Q(LMAIN+3))
               IF ( QSTIC( 3,I) .LT. 0. )
     +           QSTIC( 3,I) = QSTIC( 3,I) + 2.*PI
            ENDIF
*
            KSTIC( 4,I) = NINT(Q(LSHOWR + 2)/10.)
            KSTIC( 6,I) = 0
*
*--         Charged tag from the veto
            IHITS = NINT(Q(LSHOWR + 2)/10.)
*
            LVETOS = LSHOWR + 2 + IHITS
*
            ISL1 =     NINT(Q(LVETOS + 1))/1000
            ISC1 = MOD(NINT(Q(LVETOS + 1)),1000)
            ISR1 =     NINT(Q(LVETOS + 2))/1000
            ISL2 = MOD(NINT(Q(LVETOS + 2)),1000)
            ISC2 =     NINT(Q(LVETOS + 3))/1000
            ISR2 = MOD(NINT(Q(LVETOS + 3)),1000)
*
*--         Set up the ADC flags :
*--         VFLAG1 = 1 for a single plane hit in the front shower sector
*--         VFLAG1 = 2 for a double plane hit in the front shower sector
*--         VFLAG2 = 1 for a single plane hit in  a  neighbouring sector
*--         VFLAG2 = 2 for a double plane hit in  a  neighbouring sector
*
                                                   KFLAG1 = 0
                                                   KFLAG2 = 0
*
            IF ( ISC1 .GT. 50 .OR.  ISC2 .GT. 50 ) KFLAG1 = 1
            IF ( ISL1 .GT. 50 .OR.  ISL2 .GT. 50 ) KFLAG2 = 1
            IF ( ISR1 .GT. 50 .OR.  ISR2 .GT. 50 ) KFLAG2 = 1
*
            IF ( ISC1 .GT. 50 .AND. ISC2 .GT. 50 ) KFLAG1 = 2
            IF ( ISL1 .GT. 50 .AND. ISL2 .GT. 50 ) KFLAG2 = 2
            IF ( ISR1 .GT. 50 .AND. ISR2 .GT. 50 ) KFLAG2 = 2
*
*--         Set up the discrimination flags :
*--         IFLAG1 = 1 for a single plane hit in the front shower sector
*--         IFLAG1 = 2 for a double plane hit in the front shower sector
*--         IFLAG2 = 1 for a single plane hit in  a  neighbouring sector
*--         IFLAG2 = 2 for a double plane hit in  a  neighbouring sector
*
            IVEDIS(1) = NINT(Q(LVETOS + 4))
            IVEDIS(2) = NINT(Q(LVETOS + 5))
*
                                          IARM = 1
            IF ( QSTIC( 2,I) .LE. PI/2. ) IARM = 2
*
            ISECT = INT((QSTIC(3,I)/PI*180. + 22.5)/22.5)
            IF ( IARM .EQ. 1 ) THEN
               ISECT = 9 - ISECT
               IF ( ISECT .LE. 0 ) ISECT = ISECT + 16
            ENDIF
*
            ISE = ISECT
            ISL = ISECT - 1
            ISH = ISECT + 1
            IF ( ISL .LT. 1 ) ISL = 16
            IF ( ISH .GT.16 ) ISH =  1
*
                                                   IFLAG1 = 0
                                                   IFLAG2 = 0
            IF ( JBIT(IVEDIS(1), ISE) .EQ. 1 .OR.
     +           JBIT(IVEDIS(2), ISE) .EQ. 1 )     IFLAG1 = 1
            IF ( JBIT(IVEDIS(1), ISL) .EQ. 1 .OR.
     +           JBIT(IVEDIS(2), ISL) .EQ. 1 )     IFLAG2 = 1
            IF ( JBIT(IVEDIS(1), ISH) .EQ. 1 .OR.
     +           JBIT(IVEDIS(2), ISH) .EQ. 1 )     IFLAG2 = 1
*
            IF ( JBIT(IVEDIS(1), ISE) .EQ. 1 .AND.
     +           JBIT(IVEDIS(2), ISE) .EQ. 1 )     IFLAG1 = 2
            IF ( JBIT(IVEDIS(1), ISL) .EQ. 1 .AND.
     +           JBIT(IVEDIS(2), ISL) .EQ. 1 )     IFLAG2 = 2
            IF ( JBIT(IVEDIS(1), ISH) .EQ. 1 .AND.
     +           JBIT(IVEDIS(2), ISH) .EQ. 1 )     IFLAG2 = 2
*
*--         Correct the discrimination with ADC flags
            IF ( KFLAG1 .GT. IFLAG1 ) IFLAG1 = KFLAG1
            IF ( KFLAG2 .GT. IFLAG2 ) IFLAG2 = KFLAG2
*
*--         Tight ADC photon AND tight DISC photon = tight photon
*--         Loose ADC photon AND tight DISC photon = loose photon
*--         Tight ADC photon AND loose DISC photon = loose photon
*--         Loose ADC photon AND loose DISC photon = loose photon
*--         ADC electron     OR  DISC electron     = electron
*
                IF ( IFLAG1 .EQ. 0 .AND. IFLAG2 .EQ. 0 ) THEN
*--                tight photon
                   KSTIC(5,I) = -2
            ELSEIF ( IFLAG1 .LE. 1 .AND. IFLAG2 .LE. 1 ) THEN
*--                loose photon
                   KSTIC(5,I) = -1
            ELSEIF ( IFLAG1 .EQ. 2 .OR.  IFLAG2 .EQ. 2 ) THEN
*--                electron
                   KSTIC(5,I) =  1
            ELSE
*--                no information
                   KSTIC(5,I) =  0
            ENDIF
CCC         LSHOWR = LSHOWR+LENSHO
CCC      ENDDO
*
   99 CONTINUE
      END
*
+DECK,PSHVDH. **********************************************************
      SUBROUTINE PSHVDH
************************************************************************
*                                                                      *
*     Name           :  PSHVDH                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Jun  18, 1997                                  *
*     Task           :  To read the VD hits bank at link 21            *
*                       and fill the VD hit commons                    *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCVDA.
+CDE, PSCVDU.
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER LQMVDH,LPA
      INTEGER NWPH,IDAT,N,I
*
*--   Micro VD hits bank
      IF (LDTOP  .LE. 0) GOTO 99
      LQMVDH = LQ(LDTOP - 21)
      IF (LQMVDH .LE. 0) GOTO 99
*
         NVDHT = MOD(IQ(LQMVDH+1),1000)       ! Number of all VD hits
         NVDAS =     IQ(LQMVDH-3)             ! Number of ass.VD hits
         NWPH  =     IQ(LQMVDH+1)/1000        ! Number of words per hit
         IDAT  = 1
*
*--      Temporary fix if > 999 hits
         IF ( IQ(LQMVDH+1) .EQ. 5000) THEN
            NVDHT = 1000
            NWPH  =    4
         ENDIF
         IF ( IQ(LQMVDH+1) .EQ. 6000) THEN
            NVDHT = 1000
            NWPH  =    5
         ENDIF
*
*--      Loop over ass. VD hits
         DO N = 1, NVDAS
*
*--         Reference link
            LPA = LQ(LQMVDH - N)
*
            I = IUCOMP(LPA,LVECP,NVECP)
*
            IF ( I .NE. 0 ) THEN
               NASHT(I) = NASHT(I) + 1
*
*--            Data words
               KVDAS(1,I,NASHT(I)) = NINT(Q(LQMVDH + IDAT + 1))
               QVDAS(2,I,NASHT(I)) =      Q(LQMVDH + IDAT + 2)
               QVDAS(3,I,NASHT(I)) =      Q(LQMVDH + IDAT + 3)
               QVDAS(4,I,NASHT(I)) =      Q(LQMVDH + IDAT + 4)
               IF ( NWPH .GT. 4 ) THEN
                  QVDAS(5,I,NASHT(I)) =   Q(LQMVDH + IDAT + 5)
               ELSE
                  QVDAS(5,I,NASHT(I)) =   0.
               ENDIF
            ENDIF
            IDAT = IDAT + NWPH
         ENDDO
*
*--      Loop over unass. VD hits
         NVDUN = MIN(NVDHT-NVDAS,NVDUMX)
*
         DO I = 1, NVDUN
            KVDUN(1,I) = NINT(Q(LQMVDH + IDAT + 1))
            QVDUN(2,I) =      Q(LQMVDH + IDAT + 2)
            QVDUN(3,I) =      Q(LQMVDH + IDAT + 3)
            QVDUN(4,I) =      Q(LQMVDH + IDAT + 4)
            IF ( NWPH .GT. 4 ) THEN
               QVDUN(5,I) =   Q(LQMVDH + IDAT + 5)
            ELSE
               QVDUN(5,I) =   0.
            ENDIF
            IDAT = IDAT + NWPH
         ENDDO
*
   99 CONTINUE
      END
*
*
+DECK,PSHUTE. **********************************************************
      SUBROUTINE PSHUTE
************************************************************************
*                                                                      *
*     Name           :  PSHUTE                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  15, 1994                                  *
*     Task           :  To read the Unassoc. TER's bank at link 23     *
*                       and fill the unassoc. TER's commons            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCTER.
*
*--   local variables
      INTEGER LQUTER,NTER,NWTE,IDAT,I
*
      NTEOD  = 0
      CALL vzeroi(KTEOD ,LENUTE*NUTMAX)
      NTEFCA = 0
      CALL vzeroi(KTEFCA,LENUTE*NUTMAX)
      NTEFCB = 0
      CALL vzeroi(KTEFCB,LENUTE*NUTMAX)
*
*--   Unassoc.  VD  hits bank
      IF (LDTOP.LE.0)  RETURN
      LQUTER = LQ(LDTOP - 23)
*
      IF ( LQUTER .GT. 0 ) THEN
         NTEOD  = MOD(IQ(LQUTER+1),100)
         NTEFCA = MOD(IQ(LQUTER+1)/100,100)
         NTEFCB =     IQ(LQUTER+1)/10000
         NTER   = NTEOD + NTEFCA + NTEFCB         ! Number of TE's
         NWTE   = (IQ(LQUTER-1) - 1)/NTER         ! Number of words/TE
         IDAT   = 1
*
*--      TER's  in  OD
         DO I = 1, NTEOD
            IF ( NWTE .EQ. 8 ) THEN
               QTEOD ( 1,I) = Q(LQUTER + IDAT + 1)
               QTEOD ( 2,I) = Q(LQUTER + IDAT + 2)
               QTEOD ( 3,I) = Q(LQUTER + IDAT + 3)
               QTEOD ( 4,I) = Q(LQUTER + IDAT + 4)
            ENDIF
               QTEOD ( 5,I) = Q(LQUTER + IDAT + (NWTE-4) + 1)
               QTEOD ( 6,I) = Q(LQUTER + IDAT + (NWTE-4) + 2)
               QTEOD ( 7,I) = Q(LQUTER + IDAT + (NWTE-4) + 3)
               QTEOD ( 8,I) = Q(LQUTER + IDAT + (NWTE-4) + 4)
            IDAT = IDAT + NWTE
         ENDDO
*
*--      TER's  in  FCA
         DO I = 1, NTEFCA
            IF ( NWTE .EQ. 8 ) THEN
               QTEFCA( 1,I) = Q(LQUTER + IDAT + 1)
               QTEFCA( 2,I) = Q(LQUTER + IDAT + 2)
               QTEFCA( 3,I) = Q(LQUTER + IDAT + 3)
               QTEFCA( 4,I) = Q(LQUTER + IDAT + 4)
            ENDIF
               QTEFCA( 5,I) = Q(LQUTER + IDAT + (NWTE-4) + 1)
               QTEFCA( 6,I) = Q(LQUTER + IDAT + (NWTE-4) + 2)
               QTEFCA( 7,I) = Q(LQUTER + IDAT + (NWTE-4) + 3)
               QTEFCA( 8,I) = Q(LQUTER + IDAT + (NWTE-4) + 4)
            IDAT = IDAT + NWTE
         ENDDO
*
*--      TER's  in  FCB
         DO I = 1, NTEFCB
            IF ( NWTE .EQ. 8 ) THEN
               QTEFCB( 1,I) = Q(LQUTER + IDAT + 1)
               QTEFCB( 2,I) = Q(LQUTER + IDAT + 2)
               QTEFCB( 3,I) = Q(LQUTER + IDAT + 3)
               QTEFCB( 4,I) = Q(LQUTER + IDAT + 4)
            ENDIF
               QTEFCB( 5,I) = Q(LQUTER + IDAT + (NWTE-4) + 1)
               QTEFCB( 6,I) = Q(LQUTER + IDAT + (NWTE-4) + 2)
               QTEFCB( 7,I) = Q(LQUTER + IDAT + (NWTE-4) + 3)
               QTEFCB( 8,I) = Q(LQUTER + IDAT + (NWTE-4) + 4)
            IDAT = IDAT + NWTE
         ENDDO
      ENDIF
*
      END
*
+DECK,PSHPHC. **********************************************************
      SUBROUTINE PSHPHC
************************************************************************
*                                                                      *
*     Name           :  PSHPHC                                         *
*     Called by      :  USER02                                         *
*     Date of coding :  Nov  11, 1993                                  *
*     Last update    :  Mar  23, 1996                                  *
*     Task           :  To read the Photon conver. bank at link 24     *
*                       or the PV-PA structure (since version 1.03)    *
*                       and fill up  the photon conversion  common     *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCPHC.
      INTEGER    NWPHOC
      PARAMETER (NWPHOC =  9)
*
*--   functions
      INTEGER JBYT,IUCOMP,LPHPA
*
*--   local variables
      INTEGER LPV,LPA,ICODE
      INTEGER LPVCON,LMAIN
      INTEGER LQPHOC,IDAT,I
*
      NPHOC = 0
      I     = 0
      CALL uzeror(QPHOC,1,LENPHC*NPCMAX)
*
      IF ( ISVER .GE. 103 ) THEN
*
*--      PV  vertex bank address
         IF (LDTOP.LE.0)  RETURN
         LPV=LQ(LDTOP-1)
*
*--      Loop over the particles
         DO WHILE ( LPV .NE. 0 )
            LPA = LQ(LPV - 1)
*
            DO WHILE ( LPA .NE. 0 )
               IF ( LQ(LPA - 1) .EQ. 0 )  GOTO 10
*
               ICODE = JBYT( IQ(LPA + 3), 19, 7 )
               IF ( ICODE .LT. 21 .OR. ICODE .GT. 24 ) GOTO 10              
*
               I = I + 1
               IF ( I .GT. NPCMAX ) GOTO 10
*
*--            Reference links
               LPVCON = LQ(LPA - 1)
*
               KPHOC( 1,I)    = IUCOMP(    LQ(LPVCON - 1) ,LVECP,NVECP )
               IF ( LQ(LPVCON - 1) .NE. 0 ) THEN
                  KPHOC( 2,I) = IUCOMP( LQ(LQ(LPVCON - 1)),LVECP,NVECP )
               ELSE
                  KPHOC( 2,I) = 0
               ENDIF
               KPHOC( 3,I)    = IUCOMP(    LQ(LPA    - 2) ,LVECP,NVECP )
*
*--            Photon parameters
               LMAIN = LPHPA('MAIN',LPA,0)
               IF ( LMAIN .EQ. 0 ) GOTO 10
*
               KPHOC( 4,I) =  ICODE
               QPHOC( 5,I) =  Q(LMAIN + 3)
               QPHOC( 6,I) =  Q(LMAIN + 4)
               QPHOC( 7,I) =  Q(LMAIN + 5)
               QPHOC( 8,I) =  Q(LMAIN + 6)
               QPHOC( 9,I) =  Q(LMAIN + 9)
*
*--            Conversion position
               QPHOC(10,I) = Q(LPVCON + 5)
               QPHOC(11,I) = Q(LPVCON + 6)
               QPHOC(12,I) = Q(LPVCON + 7)
*
               NPHOC = NPHOC + 1
   10          CONTINUE
               LPA = LQ(LPA)
            ENDDO
   20       CONTINUE
            LPV = LQ(LPV)
         ENDDO
*
      ELSE
*
*--   Gamma  conversion  bank
      IF (LDTOP.LE.0)  RETURN
      LQPHOC = LQ(LDTOP - 24)
*
      IF (LQPHOC .GT. 0) THEN
         NPHOC = IQ(LQPHOC+1)
         IDAT  = 1
*
         DO I = 1, NPHOC
*
*--         Reference links
            KPHOC(1,I) = IUCOMP (LQ(LQPHOC - 3*I + 2), LVECP, NVECP)
            KPHOC(2,I) = IUCOMP (LQ(LQPHOC - 3*I + 1), LVECP, NVECP)
            KPHOC(3,I) = IUCOMP (LQ(LQPHOC - 3*I    ), LVECP, NVECP)
*
*--         Data words
            KPHOC(4,I) =-IQ(LQPHOC + IDAT + 1)
            CALL ucopyr (Q(LQPHOC + IDAT + 2), QPHOC(5,I), NWPHOC-1)
*
            IDAT = IDAT + NWPHOC
         ENDDO
      ENDIF
      ENDIF
*
      END
*
+DECK,PSHBTG. **********************************************************
      SUBROUTINE PSHBTG
************************************************************************
*                                                                      *
*     Name           :  PSHBTG                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  Nov  15, 1994                                  *
*     Last update    :  Nov  29, 1994                                  *
*     Task           :  To read the B tagging bank at link 25          *
*                       and fill the vertex & B tagging commons        *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCBSP.
+CDE, PSCVTX.
+CDE, PSCBTG.
+CDE, AAMAIN.
+CDE, AAFLAG.
+CDE, AAMNVX.
+CDE, AAPARM.
*
*--   functions
      INTEGER IPHPIC,JBYT
*
*--   local variables
      INTEGER LQBTAG,IDENT
      REAL    PROBN,PROBP,PROBS
      CHARACTER*4 NAMBTG
*
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST /.TRUE./
*
      CALL vfillr( QBTPRN, 3, 2. )
      CALL vfillr( QBTPRP, 3, 2. )
      CALL vfillr( QBTPRS, 3, 2. )
      CALL vfillr( QBTTHR, 4, 2. )
*
      IF ( ISVER .GE. 102 ) THEN
*
*--      B_tagging bank (25)
         IF (LDTOP.LE.0)  RETURN
         LQBTAG = LQ(LDTOP - 25)
*
         IF ( LQBTAG .GT. 0 ) THEN
            IF ( IQ(LQBTAG-1) .GT. 6 ) THEN
*
              IF (IFLPVT.EQ.1) THEN
*
                KVTX( 3,1) = JBYT( NINT(Q(LQBTAG + 7)), 1, 8 )
                KVTX( 4,1) = JBYT( NINT(Q(LQBTAG + 7)), 9, 8 )
*
*--            Vertex coordinates
                QVTX( 6,1) = Q(LQBTAG +  8)
                QVTX( 7,1) = Q(LQBTAG +  9)
                QVTX( 8,1) = Q(LQBTAG + 10)
*
*--            Chi2 of the vertex fit
                QVTX( 9,1) = Q(LQBTAG + 11)
*
*--            Covariance matrix
                QVTX(10,1) = Q(LQBTAG + 12)
                QVTX(11,1) = Q(LQBTAG + 13)
                QVTX(12,1) = Q(LQBTAG + 14)
                QVTX(13,1) = Q(LQBTAG + 15)
                QVTX(14,1) = Q(LQBTAG + 16)
                QVTX(15,1) = Q(LQBTAG + 17)
*
*--            Error flag
                KVTX(16,1) = 0
*
              ENDIF
*
*--            B-tagging probabilities
               QBTPRN(1)  = Q(LQBTAG + 21)
               QBTPRN(2)  = Q(LQBTAG + 22)
               QBTPRN(3)  = Q(LQBTAG + 18)
               QBTPRP(1)  = Q(LQBTAG + 23)
               QBTPRP(2)  = Q(LQBTAG + 24)
               QBTPRP(3)  = Q(LQBTAG + 19)
               QBTPRS(1)  = Q(LQBTAG + 25)
               QBTPRS(2)  = Q(LQBTAG + 26)
               QBTPRS(3)  = Q(LQBTAG + 20)
               QBTTHR(1)  = Q(LQBTAG + 27)
               QBTTHR(2)  = Q(LQBTAG + 28)
               QBTTHR(3)  = Q(LQBTAG + 29)
               QBTTHR(4)  = Q(LQBTAG + 30)
            ELSE
*
              IF (IFLPVT.EQ.1) THEN
*
*--            Vertex coordinates
                QVTX( 6,1) = -999.
                QVTX( 7,1) = -999.
                QVTX( 8,1) = -999.
*
*--            Error flag
                KVTX(16,1) =    1
              ENDIF
            ENDIF
         ENDIF
      ELSE
*
*--      AABTAG initialization
         IF ( FIRST ) THEN
            FIRST = .FALSE.
*
            NAMBTG = NAMDST
            CALL AADATA
            NAMDST = NAMBTG
            IFK0ST = .TRUE.
            IFRFIX = .TRUE.
         ENDIF
*
*--      Check the Beam spot quality
         IF ( IERRBS .EQ. 0 ) THEN
            CALL AABTGS( XYZBS, DXYZBS, PROBN, PROBP, PROBS )
*
            IF (IFLPVT.EQ.1) THEN
              IF ( IBAD .EQ. 0 ) THEN
                NDOFVX = NATTVX
                KVTX( 3,1) = NATTVX
                KVTX( 4,1) = NDOFVX
*
*--            Vertex coordinates
                QVTX( 6,1) = POSVX(1)
                QVTX( 7,1) = POSVX(2)
                QVTX( 8,1) = POSVX(3)
*
*--            Chi2 of the vertex fit
                QVTX( 9,1) = CHI2VX
*
*--            Covariance matrix
                QVTX(10,1) = COVVX(1)
                QVTX(11,1) = COVVX(2)
                QVTX(12,1) = COVVX(3)
                QVTX(13,1) = COVVX(4)
                QVTX(14,1) = COVVX(5)
                QVTX(15,1) = COVVX(6)
              ELSE
*--            Vertex coordinates
                QVTX( 6,1) = XYZBS(1)
                QVTX( 7,1) = XYZBS(2)
                QVTX( 8,1) = XYZBS(3)
              ENDIF
*
*--         Error flag
              KVTX(16,1) = IBAD
            ENDIF
          ELSE
            IF (IFLPVT.EQ.1) THEN
              QVTX( 6,1) = -999.
              QVTX( 7,1) = -999.
              QVTX( 8,1) = -999.
              KVTX(16,1) =    1
            ENDIF
          ENDIF
*
*--      Identification blocklet
         IDENT = IPHPIC ('IDEN',0)
         IF ( IDENT .GE. 0 ) THEN
*
*--         B-tagging probabilities
            QBTPRN(3) = FLOAT(IPILOT(IDENT+11))/100000.
            QBTPRP(3) = FLOAT(IPILOT(IDENT+12))/100000.
            QBTPRS(3) = FLOAT(IPILOT(IDENT+13))/100000.
            QBTPRN(1) = FLOAT(IPILOT(IDENT+14))/100000.
            QBTPRN(2) = FLOAT(IPILOT(IDENT+15))/100000.
            QBTPRP(1) = FLOAT(IPILOT(IDENT+16))/100000.
            QBTPRP(2) = FLOAT(IPILOT(IDENT+17))/100000.
            QBTPRS(1) = FLOAT(IPILOT(IDENT+18))/100000.
            QBTPRS(2) = FLOAT(IPILOT(IDENT+19))/100000.
            QBTTHR(1) = FLOAT(IPILOT(IDENT+20))/100000.
            QBTTHR(2) = FLOAT(IPILOT(IDENT+21))/100000.
            QBTTHR(3) = FLOAT(IPILOT(IDENT+22))/100000.
         ENDIF
      ENDIF
*
      END
*
+DECK,PSHECL. **********************************************************
      SUBROUTINE PSHECL
************************************************************************
*                                                                      *
*     Name           :  PSHECL                                         *
*     Called by      :  PSHORT                                         *
*     Date of coding :  July 15, 1999                                  *
*     Last update    :  July 15, 1999                                  *
*     Task           :  To read the Reconstructed elm. cluster         *
*                       bank at link 33 and fill the commons           *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, PSCECL.
*
*--   functions
      INTEGER IUCOMP,JBYT,JBIT
*
*--   local variables
      INTEGER LQEMCL,IDAT,N,I,J
      INTEGER LEMCLU,NPACLU,NP
      INTEGER NPACLF,IPATYP
      INTEGER ISEARCH
*
*--   Electromagn. cluster bank
      IF (LDTOP .LE. 0)  RETURN
      IF ( IQ(LDTOP- 2) .GE. 33 .AND.
     +     LQ(LDTOP-33) .GT.  0) THEN
         LQEMCL = LQ(LDTOP - 33)
      ELSE
         CALL PSFECL
                       GO TO 99
      ENDIF
*
      NEMCLU = MOD(IQ(LQEMCL + 1),100)
      LEMCLU =     IQ(LQEMCL + 1)/100
      NPACLF = 1
      IDAT   = 1
*
*--   Loop on clusters
      DO N = 1, NEMCLU
*
*--      Number of associated PA's
         NPACLU = JBYT( NINT(Q(LQEMCL+IDAT+6)), 19, 6 )
         IPATYP = 1
*
*--      Reference links
         DO NP = NPACLF, NPACLF+NPACLU-1
            I  = IUCOMP( LQ(LQEMCL- NP), LVECP, NVECP )
*
*--         Cluster data
            IF ( NP .EQ. NPACLF ) THEN
              IF ( I .EQ.  0 ) GO TO 90
               QEMCLU( 1,I) =           Q(LQEMCL+IDAT+1)
               QEMCLU( 2,I) =           Q(LQEMCL+IDAT+2)
               QEMCLU( 3,I) =           Q(LQEMCL+IDAT+3)
               QEMCLU( 4,I) =           Q(LQEMCL+IDAT+4)
               QEMCLU( 5,I) =           Q(LQEMCL+IDAT+5)
               KEMCLU( 6,I) = JBYT(NINT(Q(LQEMCL+IDAT+6)), 1, 6)
               KEMCLU( 7,I) = 1 + 1000*N
               KEMCLU( 8,I) = NPACLU
               KEMCLU( 9,I) = JBYT(NINT(Q(LQEMCL+IDAT+6)), 17, 2)
               IF (KEMCLU( 9,I).EQ.2) KEMCLU( 9,I) = -1
*
               IEMCLU(I) = N
            ELSE
               IPATYP = IPATYP +  1
               IF ( I .GT. 0 ) THEN
                  J = JBIT(NINT(Q(LQEMCL+IDAT+7)), IPATYP)
                  ISEARCH = JBIT(NINT(Q(LQEMCL+IDAT+6)),7)
                  IF( J .EQ. 1 ) KEMCLU( 7,I) = 2 + 1000*N
                  IF( J .EQ. 0 ) THEN
                    IF (ISEARCH.EQ.0) THEN
                      KEMCLU( 7,I) = 4 + 1000*N
                    ELSE
                      KEMCLU( 7,I) = 3 + 1000*N
                    ENDIF
                  ENDIF
*
                  IF (NP-NPACLF+1.EQ.JBYT(NINT(Q(LQEMCL+IDAT+6)), 8, 5))
     &              THEN
                      KEMCLU( 7,I) = 11 + 1000*N
                  ENDIF
*
                  IEMCLU(I) = N
               ENDIF
            ENDIF
         ENDDO
*
   90    CONTINUE
         NPACLF = NPACLF + NPACLU
         IDAT   = IDAT   + LEMCLU
      ENDDO
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-W-PSHECL, ','Elm. cluster ',I2,' at PA ',I6
     +      ,/,1X,'                  ','dropped due to track selection'
     +      ,/,1X,'                  ','Run ',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSHEC1. **********************************************************
      SUBROUTINE PSHEC1
************************************************************************
*                                                                      *
*     Name           :  PSHEC1                                         *
*     Called by      :  PSHORTEVT                                      *
*     Date of coding :  September 17, 1999                             *
*     Last update    :  September 17, 1999                             *
*     Task           :  To read the Reconstructed elm. cluster         *
*                       bank at link 33 and fill the common PEMOUT     *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PEMOUT.
*
*--   functions
      INTEGER JBYT
*
*--   local variables
      INTEGER LQEMCL,I,J
      INTEGER IDAT,NPACLU
*
      LOGICAL FIRST
      DATA FIRST / .TRUE. /
      SAVE FIRST
*
      CALL uzeror (DEMCLU,1,LENECL*MTRACK)
      CALL vzeroi (LEMCLU,MTRACK)
      NECL = 0
      NLNR = 0
*
*     Read XSDST information only for the last LEP2 reprocessing
*
      IF (CDTYPE.EQ.'97G2' .OR.
     &  CDTYPE.EQ.'98E2' .OR.
     &  CDTYPE.EQ.'99E2' .OR.
     &  CDTYPE.EQ.'A0E2' .OR.
     &  CDTYPE.EQ.'A0U2') THEN
        GOTO 88
      ELSE
*
        IF (FIRST) THEN
          FIRST = .FALSE.
          WRITE (*,1000) CDTYPE
        ENDIF
*
        CALL REMCLU
        CALL REMOUT
        GOTO 99
      ENDIF
*
*--   Electromagn. cluster bank
 88   IF (LDTOP .LE. 0)  RETURN
      IF ( IQ(LDTOP- 2) .GE. 33 .AND.
     +  LQ(LDTOP-33) .GT.  0) THEN
        LQEMCL = LQ(LDTOP - 33)
        IF (LQEMCL.LE.0) GOTO 99
*
        NECL = MOD(IQ(LQEMCL + 1),100)
        IDAT = IQ(LQEMCL + 1)/100
        NLNR = 0
*
        DO I = 1,NECL
*
*         copy the cluster information
*
          CALL ucopyr(Q(LQEMCL+2+IDAT*(I-1)),DEMCLU(1,I),IDAT)
*
*         copy the PA identifier
*
          NPACLU = JBYT( NINT(DEMCLU(6,I)), 19, 6 )
          DO J = 1,NPACLU
            NLNR = NLNR+1
            LEMCLU(NLNR) = LQ(LQEMCL-NLNR)
          ENDDO
*
        ENDDO
*
      ENDIF
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSMAIN-I-PSHEC1, ','Forcing REMCLU rerunning for'
     +      ,' the reprocessing ',A4,/)
      END
*

+DECK,PSHRV0. **********************************************************
      SUBROUTINE PSHRV0
************************************************************************
*                                                                      *
*     Name           :  PSHRV0                                         *
*     Called by      :  USER02                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  May  15, 1995                                  *
*     Task           :  To read the Reconstructed V0 bank at link 22   *
*                       and fill the V0 commons                        *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCRV0.
+CDE, PSCHV0.
*
*--   functions
      INTEGER IUCOMP,JBYT
*
*--   local variables
      INTEGER IFVER
      INTEGER LQRCV0,LQV0TK,IDAT,IDTK,I,J
      INTEGER NWV0,NWTK,NHYP,NWHP,KFIT,NPRB
*
      NRV0 = 0
      CALL uzeror(QRV0,1,LENRV0*NV0MAX)
*
*--   PXDST version
      IFVER = IQ(LDTOP + 3)
*
*--   Reconstructed  V0  bank
      IF (LDTOP.LE.0)  RETURN
      IF ( IQ(LDTOP -  2) .GE. 22  .AND.
     +     LQ(LDTOP - 22) .GT.  0 ) THEN
         LQRCV0 = LQ(LDTOP - 22)
         NRV0   = IQ(LQRCV0 + 1)
         IDAT   = 1
*
*--      V0  neutral tracks bank
         IF ( IQ(LDTOP -  2) .GE. 27  .AND.
     +        LQ(LDTOP - 27) .GT.  0 ) THEN
            LQV0TK = LQ(LDTOP - 27)
            NWTK   = NINT(Q(LQV0TK + 2))
            IDTK   = 2
         ELSE
            LQV0TK = 0
         ENDIF
*
*--      Loop over V0's
         DO I = 1, NRV0
*
*--         Reference links
            KRV0(1,I) = IUCOMP (LQ(LQRCV0-2*I+1), LVECP, NVECP)
            KRV0(2,I) = IUCOMP (LQ(LQRCV0-2*I  ), LVECP, NVECP)
*
*--         Data words
            IF ( ISVER .GE. 102 .OR. IFVER .GE. 330 ) THEN
               NWV0       = JBYT(NINT(Q(LQRCV0 + IDAT + 1)), 1,10)
               NHYP       = JBYT(NINT(Q(LQRCV0 + IDAT + 1)),11, 4)
               KRV0( 5,I) = JBYT(NINT(Q(LQRCV0 + IDAT + 1)),15, 6)
            ELSE
               NWV0       =      NINT(Q(LQRCV0 + IDAT + 1) /1000.)
               KRV0( 5,I) =  MOD(NINT(Q(LQRCV0 + IDAT + 1)),1000 )
            ENDIF
*
               CALL ucopyr( Q(LQRCV0 + IDAT + 2), QRV0( 6,I), 14 )
               IDAT = IDAT + 15
*
            IF ( LQV0TK .GT. 0 ) THEN
               CALL ucopyr( Q(LQV0TK + IDTK + 1), QRV0(20,I), NWTK )
               IDTK = IDTK + NWTK
            ENDIF
*
            IF ( ISVER .LE. 102 ) THEN
*
               KRV0H1( 1,I) = -1
               KRV0H2( 1,I) = -1
               KRV0H3( 1,I) = -1
               KRV0H4( 1,I) = -1
               KRV0H5( 1,I) = -1
               KRV0H6( 1,I) = -1
               KRV0H7( 1,I) = -1
               KRV0H8( 1,I) = -1
*
               DO J = 1, NHYP
                  NWHP = JBYT(NINT(Q(LQRCV0 + IDAT + 1)), 1,10)
                  KFIT = JBYT(NINT(Q(LQRCV0 + IDAT + 1)),11, 6)
                  NPRB = JBYT(NINT(Q(LQRCV0 + IDAT + 1)),17, 7)
*
                  IF ( KFIT .EQ.  1 ) THEN
                     KRV0H1( 1,I) = KFIT
                     QRV0H1( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H1(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ.  2 ) THEN
                     KRV0H2( 1,I) = KFIT
                     QRV0H2( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H2(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 11 ) THEN
                     KRV0H3( 1,I) = KFIT
                     QRV0H3( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H3(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 12 ) THEN
                     KRV0H4( 1,I) = KFIT
                     QRV0H4( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H4(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 21 ) THEN
                     KRV0H5( 1,I) = KFIT
                     QRV0H5( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H5(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 22 ) THEN
                     KRV0H6( 1,I) = KFIT
                     QRV0H6( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H6(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 31 ) THEN
                     KRV0H7( 1,I) = KFIT
                     QRV0H7( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H7(3,I), NWHP-1)
                  ELSEIF ( KFIT .EQ. 32 ) THEN
                     KRV0H8( 1,I) = KFIT
                     QRV0H8( 2,I) = FLOAT(NPRB)/100.
                     CALL ucopyr( Q(LQRCV0+IDAT+2), QRV0H8(3,I), NWHP-1)
                  ENDIF
*
                  IDAT = IDAT + NWHP
               ENDDO
            ELSE
               IDAT = IDAT + NWV0-15
            ENDIF
         ENDDO
      ENDIF
*
      END

+DECK,PSHMC. ***********************************************************
      SUBROUTINE PSHMC
************************************************************************
*                                                                      *
*     Name           :  PSHMC                                          *
*     Called by      :  PSHORT                                         *
*     Date of coding :  May 08, 1994                                   *
*     Last update    :  Aug 29, 1997                                   *
*     Task           :  To steer the reading of simulation banks       *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
*
*--   Read the Simulation banks
      IF     ( IQ(LDTOP -  2) .GT. 28  .AND.
     +         LQ(LDTOP - 28) .NE.  0  .AND.
     +         LQ(LDTOP - 29) .NE.  0 ) THEN
*     short DST simulation structure
         CALL PSHLUJ
         CALL PSHSIM
      ELSE
*     full  DST simulation structure
         CALL PSFLUJ
         CALL PSFSIM
      ENDIF
*
      END
*
+DECK,PSHLUJ. **********************************************************
      SUBROUTINE PSHLUJ
************************************************************************
*                                                                      *
*     Name           :  PSHLUJ                                         *
*     Called by      :  PSHMC                                          *
*     Date of coding :  May 08, 1994                                   *
*     Last update    :  Jun 17, 1994                                   *
*     Task           :  To fill the LUJETS-like common (shortDST)      *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCLUJ.
+CDE, PSCTBL.
*
*--   functions
      INTEGER JBYT,IUCOMP
*
*--   local variables
      INTEGER LENHED
      INTEGER LPVS,LSTSH
      INTEGER NPVS,NSH0,NSTSH,NST0
      INTEGER NWSH0,NWSTSH,NWST0
      INTEGER IOFSET,IOFFST,IOFFSH
      INTEGER I,J,IP,M0,M,IERR
*
      INTEGER INDARR(NPMAX,3)
      INTEGER IORDER(NPMAX)
*
          IF ( IQ(LDTOP - 2) .GT. 28  .AND.
     +         LQ(LDTOP -28) .NE.  0  .AND.
     +         LQ(LDTOP -29) .NE.  0 ) THEN
             LPVS  =  LQ(LDTOP - 28)
             LSTSH =  LQ(LDTOP - 29)
      ELSEIF ( ISVER .LE. 101         .AND.
     +         IQ(LDTOP - 2) .GT. 18  .AND.
     +         LQ(LDTOP -18) .NE.  0  .AND.
     +         LQ(LDTOP -19) .NE.  0 ) THEN
             LPVS  =  LQ(LDTOP - 18)
             LSTSH =  LQ(LDTOP - 19)
      ELSE
         WRITE(*,1300) IIIRUN,IIIEVT,NEVENT
      ENDIF
*
      IF ( LPVS  .LE. 0 ) GO TO 99
      IF ( LSTSH .LE. 0 ) GO TO 99
*
*--   Numbers of different banks
      NPVS   =     IQ(LPVS  + 1)
      NSH0   =     IQ(LSTSH + 2)/1000
      NSTSH  =     IQ(LSTSH + 3)/1000
      NST0   =     IQ(LSTSH + 4)/1000
*
*--   Header length
      LENHED = IQ(LSTSH + 1) - (NSH0 + 2*NSTSH + NST0) + 1
*
*--   Number of words per bank
      NWSH0  = MOD(IQ(LSTSH + 2),1000)
      NWSTSH = MOD(IQ(LSTSH + 3),1000)
      NWST0  = MOD(IQ(LSTSH + 4),1000)
*
*--   Fill the index array
      NP = 0
      IOFSET = LSTSH + LENHED
      DO I = 1, NSH0
         IF ( NP .GE. NPMAX ) THEN
            WRITE(*,1000) NPMAX,NSH0,NSTSH,NST0
     +                    ,IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
*
         NP = NP + 1
         INDARR(NP,1) = JBYT(IQ(IOFSET+I),  9, 8)
         INDARR(NP,2) = JBYT(IQ(IOFSET+I), 17, 8)
      ENDDO
*
      IOFSET = IOFSET + NSH0
      DO I = 1, 2*NSTSH, 2
         IF ( NP .GE. NPMAX ) THEN
            WRITE(*,1000) NPMAX,NSH0,NSTSH,NST0
     +                    ,IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
*
         NP = NP + 1
         INDARR(NP,1) = JBYT(IQ(IOFSET+I),  9, 8)
         INDARR(NP,2) = JBYT(IQ(IOFSET+I), 17, 8)
      ENDDO
*
*--   Sort-out the index particles
      CALL PSSORT(INDARR,NPMAX,NP,IORDER,IERR)
      IF ( IERR .EQ. -1 ) THEN
         WRITE(*,*) '%PSHORT-E-PSHLUJ, Can not fill the LUJETS common'
         WRITE(*,*) '                  Infinite loop spotted         '
         WRITE(*,*) '                  Run ',IIIRUN,' Event',IIIEVT
         GO TO 99
      ENDIF
*
*--   Fill-up the KP, PP and VP arrays
      DO I = 1, NP
         KP(I,3) = 0
         KP(I,4) = 0
         KP(I,5) = 0
      ENDDO
*
      IOFFSH = LSTSH + LENHED + NSH0 + 2*NSTSH + NST0
      IOFFST = IOFFSH + NSH0*NWSH0
*
      M0 = -1
*
*--   Find SH index from LUND index
      DO I = 1, NP
         J = IORDER(I)
         IF ( J .EQ. 0 ) THEN
            WRITE(*,1100) I,J,IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ELSEIF( J .LE. NSH0 ) THEN
            IP = IOFFSH + NWSH0*(J-1)
         ELSEIF( J .LE. NSH0+NSTSH ) THEN
            IP = IOFFST + NWSTSH*(J-NSH0-1)
         ELSE
            WRITE(*,1100) I,J,IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
*
         IF ( J .LE. NSH0 ) THEN
            KP(I,1) = NINT(Q(IP + 8))/10000
            KP(I,2) = NINT(Q(IP + 9))
         ELSE
            KP(I,1) = NINT(Q(IP +13))/10000
            KP(I,2) = NINT(Q(IP +14))
         ENDIF
*
         M = INDARR(J,1)               ! Mother index from original SH
         M = IUCOMP(M,IORDER(1),NP)    ! Index SH -> index LUND
         IF ( M .NE. 0 ) THEN
            KP(I,3) = M
            IF ( M .NE. M0 ) THEN
               IF ( M0 .NE. -1 ) THEN
                  KP(M0,5) = I - 1
               ENDIF
               KP(M,4) = I
               M0 = M
            ENDIF
         ENDIF
*
         PP(I,1) = Q(IP + 3)
         PP(I,2) = Q(IP + 4)
         PP(I,3) = Q(IP + 5)
         PP(I,4) = Q(IP + 6)
         PP(I,5) = Q(IP + 2)
*
         IF ( J .LE. NSH0 ) THEN
            ZF(I) = Q(IP + 10)
            DM(I) = Q(IP + 11)
         ELSE
            ZF(I) = Q(IP + 15)
            DM(I) = Q(IP + 16)
         ENDIF
*
         IF ( J .LE. NSH0 ) THEN
            VP(I,1) = 0.
            VP(I,2) = 0.
            VP(I,3) = 0.
            VP(I,4) = 0.
            VP(I,5) = 0.
         ELSE
            IP = LSTSH + LENHED + NSH0 + 2*(J-NSH0)
            IP = JBYT(IQ(IP), 9, 8)
            IF ( IP .EQ. 0 ) THEN
               WRITE(*,1200) I,J,IIIRUN,IIIEVT,NEVENT
               VP(I,1) = 0.
               VP(I,2) = 0.
               VP(I,3) = 0.
               VP(I,4) = 0.
               VP(I,5) = 0.
            ELSE
               IP = LPVS + 1 + NPVS + 6*(IP-1)
               VP(I,1) = Q(IP + 4)
               VP(I,2) = Q(IP + 5)
               VP(I,3) = Q(IP + 6)
               VP(I,4) = 0.
               VP(I,5) = 0.
            ENDIF
         ENDIF
      ENDDO
*
*  ...and the last line
      KP(M0,5) = NP
*
*--   Correspondance tables SH <--> LU
      DO I = 1, NP
         ILUSH(I) = IORDER(I)
         ISHLU(IORDER(I)) = I
      ENDDO
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHLUJ, ','More than ',I4,' SH found :'
     +      ,/,1X,'                  ', I4,' SH non assoc. with ST '
     +      ,/,1X,'                  ', I4,' SH     assoc. with ST '
     +      ,/,1X,'                  ', I4,' ST non assoc. with SH '
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
 1100 FORMAT(/,1X,'%PSHORT-E-PSHLUJ, ','Particle not found :'
     +      ,/,1X,'                  ','LUND index ',I4
     +      ,/,1X,'                  ','SH   index ',I4
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
 1200 FORMAT(/,1X,'%PSHORT-E-PSHLUJ, ','Vertex not found :'
     +      ,/,1X,'                  ','LUND index ',I4
     +      ,/,1X,'                  ','SH   index ',I4
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
 1300 FORMAT(/,1X,'%PSHORT-E-PSHLUJ, ','No simulation structure for'
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSHSIM. **********************************************************
      SUBROUTINE PSHSIM
************************************************************************
*                                                                      *
*     Name           :  PSHSIM                                         *
*     Called by      :  PSHMC                                          *
*     Date of coding :  May 18, 1994                                   *
*     Last update    :  Mar 18, 1998                                   *
*     Task           :  To fill-up the VECP vector for simulation      *
*                       and the correspondance tables: LU <-> ST       *
*                                                      ST <-> PA       *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVTX.
+CDE, PSCLUJ.
+CDE, PSCVEC.
+CDE, PSCTBL.
*
*--   functions
      INTEGER JBYT,IUCOMP
      REAL    VMOD
*
*--   local variables
      INTEGER LENHED
      INTEGER LPVS,LSTSH,LPA
      INTEGER NSH0,NSTSH,NST0
      INTEGER NWSH0,NWSTSH,NWST0
      INTEGER MSTJ,ICHA,IOFSET,I
*
      REAL       EPSYLO
      PARAMETER (EPSYLO = 1.E-10)
*
          IF ( IQ(LDTOP - 2) .GT. 28  .AND.
     +         LQ(LDTOP -28) .NE.  0  .AND.
     +         LQ(LDTOP -29) .NE.  0 ) THEN
             LPVS  =  LQ(LDTOP - 28)
             LSTSH =  LQ(LDTOP - 29)
      ELSEIF ( ISVER .LE. 101         .AND.
     +         IQ(LDTOP - 2) .GT. 18  .AND.
     +         LQ(LDTOP -18) .NE.  0  .AND.
     +         LQ(LDTOP -19) .NE.  0 ) THEN
             LPVS  =  LQ(LDTOP - 18)
             LSTSH =  LQ(LDTOP - 19)
      ELSE
         WRITE(*,1100) IIIRUN,IIIEVT,NEVENT
      ENDIF
*
*--   Numbers of different banks
      NSH0  = IQ(LSTSH + 2)/1000
      NSTSH = IQ(LSTSH + 3)/1000
      NST0  = IQ(LSTSH + 4)/1000
      MSTJ  = IQ(LSTSH + 5)
*
*--   Header length
      LENHED =IQ(LSTSH + 1) - (NSH0 + 2*NSTSH + NST0) + 1
*
*--   Number of words per bank
      NWSH0  = MOD(IQ(LSTSH+2),1000)
      NWSTSH = MOD(IQ(LSTSH+3),1000)
      NWST0  = MOD(IQ(LSTSH+4),1000)
*
*--   Vertex MC information
      NVTXMC = IQ(LPVS + 1)
*
      IF ( NVTXMC .GE. NVTXMX ) THEN
         WRITE(*,1000) NVTXMC,'PV',NVTXMX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      DO I = 1, NVTXMC
         IOFSET = LPVS + 1 + NVTXMC + 6*(I-1)
*
         IF ( ISVER .GE. 102 ) THEN
            KVTX( 1,NVTXMX + I) = JBYT(IQ(LPVS + I + 1), 1, 8)
            KVTX( 2,NVTXMX + I) = JBYT(IQ(LPVS + I + 1), 9, 8)
         ELSE
            KVTX( 1,NVTXMX + I) = DIM(JBYT(IQ(LPVS + I + 1), 1, 8),NSH0)
            KVTX( 2,NVTXMX + I) = DIM(JBYT(IQ(LPVS + I + 1), 9, 8),NSH0)
         ENDIF
*
         KVTX( 3,NVTXMX + I) = JBYT(IQ(IOFSET + 2),  1, 9)
         KVTX( 5,NVTXMX + I) = NINT( Q(IOFSET + 3))
         QVTX( 6,NVTXMX + I) =       Q(IOFSET + 4)
         QVTX( 7,NVTXMX + I) =       Q(IOFSET + 5)
         QVTX( 8,NVTXMX + I) =       Q(IOFSET + 6)
         KVTX(17,NVTXMX + I) = JBYT(IQ(IOFSET + 2), 10, 4)
      ENDDO
*
*--   Fill-up the VECP with ST array
      NVECMC = NSTSH + NST0
*
      IF ( NVECMC .GE. MTRACK ) THEN
         WRITE(*,1000) NVECMC,'ST',MTRACK,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      IOFSET = LSTSH + LENHED + NSH0 + 2*NSTSH + NST0 +
     +         NSH0*NWSH0
*
      DO I = 1, NSTSH
         VECP( 1,MTRACK + I) = Q(IOFSET + 3)              ! Px
         IF (ABS(Q(IOFSET + 3)) .LT. EPSYLO)
     +   VECP( 1,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 3))
         VECP( 2,MTRACK + I) = Q(IOFSET + 4)              ! Py
         IF (ABS(Q(IOFSET + 4)) .LT. EPSYLO)
     +   VECP( 2,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 4))
         VECP( 3,MTRACK + I) = Q(IOFSET + 5)              ! Pz
         IF (ABS(Q(IOFSET + 5)) .LT. EPSYLO)
     +   VECP( 3,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 5))
         VECP( 4,MTRACK + I) = Q(IOFSET + 6)              ! E
         VECP( 5,MTRACK + I) = Q(IOFSET + 2)              ! Mass value
         VECP( 6,MTRACK + I) = VMOD(VECP( 1,MTRACK+I),3)  ! |P|
         ICHA = NINT(Q(IOFSET + 12))                      ! LUND charge
         IF ( ICHA .EQ. 0 ) THEN
            VECP( 7,MTRACK + I) = 0.
         ELSEIF ( ICHA .GT. 0 ) THEN
            VECP( 7,MTRACK + I) = 1.
         ELSE
            VECP( 7,MTRACK + I) =-1.
         ENDIF
         VECP( 8,MTRACK + I) = Q(IOFSET + 8)              ! Mass code
         VECP( 9,MTRACK + I) = Q(IOFSET + 9)              ! R Phi impact
         VECP(10,MTRACK + I) = Q(IOFSET +10)              ! Z     impact
*
         IOFSET = IOFSET + NWSTSH
      ENDDO
*
      IOFSET = LSTSH + LENHED + NSH0 + 2*NSTSH + NST0 +
     +         NSH0*NWSH0 + NSTSH*NWSTSH
*
      DO I = NSTSH + 1, NSTSH + NST0
         VECP( 1,MTRACK + I) = Q(IOFSET + 3)              ! Px
         IF (ABS(Q(IOFSET + 3)) .LT. EPSYLO)
     +   VECP( 1,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 3))
         VECP( 2,MTRACK + I) = Q(IOFSET + 4)              ! Py
         IF (ABS(Q(IOFSET + 4)) .LT. EPSYLO)
     +   VECP( 2,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 4))
         VECP( 3,MTRACK + I) = Q(IOFSET + 5)              ! Pz
         IF (ABS(Q(IOFSET + 5)) .LT. EPSYLO)
     +   VECP( 3,MTRACK + I) = SIGN (EPSYLO,Q(IOFSET + 5))
         VECP( 4,MTRACK + I) = Q(IOFSET + 6)              ! E
         VECP( 5,MTRACK + I) = Q(IOFSET + 2)              ! Mass value
         VECP( 6,MTRACK + I) = VMOD(VECP( 1,MTRACK+I),3)  ! |P|
         ICHA = NINT(Q(IOFSET + 7))                       ! Charge
         IF ( ICHA .EQ. 0 ) THEN
            VECP( 7,MTRACK + I) = 0.
         ELSEIF ( ICHA .EQ. 1 ) THEN
            VECP( 7,MTRACK + I) = 1.
         ELSEIF ( ICHA .EQ. 2 ) THEN
            VECP( 7,MTRACK + I) =-1.
         ENDIF
         VECP( 8,MTRACK + I) = Q(IOFSET + 9)          ! Mass code
         VECP( 9,MTRACK + I) = Q(IOFSET +10)          ! R Phi impact
         VECP(10,MTRACK + I) = Q(IOFSET +11)          ! Z     impact
*
         IOFSET = IOFSET + NWST0
      ENDDO
*
*--   Correspondance table sizes
      NSH = NSH0 + NSTSH
      NLU = NSH
      IF ( NSH .GE. NVMAX ) THEN
         WRITE(*,1000) NSH,'SH',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      NST = NSTSH + NST0
      IF ( NST .GE. NVMAX ) THEN
         WRITE(*,1000) NST,'ST',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      NPA = NVECP
      IF ( NPA .GE. NVMAX ) THEN
         WRITE(*,1000) NPA,'PA',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
*--   Correspondance table SH --> ST
      DO I = 1, NSH0
         ISHST(I) = 0
      ENDDO
*
      DO I = 1, NSTSH
         ISHST(NSH0 + I) = I
      ENDDO
*
*--   Correspondance table ST --> SH
      DO I = 1, NSTSH
         ISTSH(I) = NSH0 + I
      ENDDO
*
      DO I = 1, NST0
         ISTSH(NSTSH+ I) = 0
      ENDDO
*
*--   Correspondance table ST --> PA
      DO I = 1, NSTSH + NST0
         LPA = LQ(LSTSH - I)
         IF ( LPA .EQ. 0 ) THEN
            ISTPA(I) = 0
         ELSE
            ISTPA(I) = IUCOMP(LPA,LVECP,NVECP)
         ENDIF
      ENDDO
*
*--   Correspondance table PA --> ST
      CALL vzeroi(IPAST,NPA)
      DO I = 1, NST
         IF ( ISTPA(I) .NE. 0 ) THEN
            IPAST(ISTPA(I)) = I
         ENDIF
      ENDDO
*
*--   Correspondance table LU --> ST
      DO I = 1, NLU
         ILUST(I) = ISHST(ILUSH(I))
      ENDDO
*
*--   Correspondance table ST --> LU
      DO I = 1, NST
         IF ( ISTSH(I) .EQ. 0 ) THEN
            ISTLU(I) = 0
         ELSE
            ISTLU(I) = ISHLU(ISTSH(I))
         ENDIF
      ENDDO
*
*--   Correspondance table ST --> VX
      IOFSET =  LSTSH + LENHED + NSH0
*
      DO I = 1, NSTSH
         ISTVX(1,I) = JBYT(IQ(IOFSET+2*I), 9, 8)
         ISTVX(2,I) = JBYT(IQ(IOFSET+2*I), 1, 8)
      ENDDO
*
      IOFSET = IOFSET + NSTSH
*
      DO I = NSTSH+1, NSTSH+NST0
         ISTVX(1,I) = JBYT(IQ(IOFSET+  I), 9, 8)
         ISTVX(2,I) = JBYT(IQ(IOFSET+  I), 1, 8)
      ENDDO
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHSIM, ',I4,' ',A2,' banks, limit at',I4
     +      ,/,1X,'                  ',' Run',I7,', Event',I6,'/',I6,/)
 1100 FORMAT(/,1X,'%PSHORT-E-PSHSIM, ','No simulation structure for'
     +      ,/,1X,'                  ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+PATCH,PSFULL.==========================================================
+DECK,PSFULL. **********************************************************
      SUBROUTINE PSFULL
************************************************************************
*                                                                      *
*     Name           :  PSFULL                                         *
*     Called by      :  PSBEG                                          *
*     Date of coding :  May 24, 1994                                   *
*     Last update    :  Sep 27, 1996                                   *
*     Task           :  Access and reading the full DST data,          *
*                       called once per event                          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCFLG.
+CDE, PSDSTYPE.
*
*--   VECP links protection
      CALL PUCINI
*
      FULLDST=.TRUE.
*
      CALL PSHORT
*
      END
*
+DECK,PSFTRA. **********************************************************
      SUBROUTINE PSFTRA(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFTRA                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Mar  15, 1995                                  *
*     Task           :  To fill the track information COMMON           *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCBSP.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCTBL.
+CDE, PSCTRA.
+CDE, AAMAIN.
+CDE, AAFLAG.
+CDE, AAMNVX.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,IUCOMP
      REAL    VMOD
*
*--   local variables
      INTEGER LQUP,LQEND
      INTEGER LMAIN,LTRAC,LQTDVD
      INTEGER NVDH,NWPH,NH,LTH,IMOD,ILAY,IU
      INTEGER NHITR(3),NHITZ(3)
      REAL    DCA(4)
*
*--   Access the standard PA module
      LMAIN = LPHPA ('MAIN', LPA, 0)
      IF ( LMAIN .LE. 0 )  GO TO 99
*
*--   Index of origin vertex
      LQUP = LQ(LVECP(I) + 1)
      IF ( LQUP .NE. 0 ) THEN
         KTRAC( 1,I) = IUCOMP(LQUP,LVTX,NVTX)
      ENDIF
*
*--   Index of end vertex (if any)
      LQEND = LQ(LVECP(I) - 1)
      IF ( LQEND .NE. 0 ) THEN
         KTRAC( 2,I) = IUCOMP(LQEND,LVTX,NVTX)
      ENDIF
*
*--   Index of simulated track
      KTRAC( 3,I) = IPAST(I)
*
*--   For charged tracks
      IF ( VECP(7,I) .NE. 0. ) THEN
*
*--      Access the "TRAC" extra module
         LTRAC = LPHPA ('TRAC', LPA, 0)
         IF ( LTRAC .GT. 0 ) THEN
            NTRAC = NTRAC + 1
            CALL ucopyr(Q(LTRAC + 2), QTRAC( 4,I), 20)
         ENDIF
*
*--      Track length
         IU = IUCOMP(LPA,IADTR(1),100)
         IF ( IU .NE. 0 ) THEN
            IF ( INMVX(IU) ) THEN
               QTRAC(24,I) = ABS(Q(LMAIN + 9))
            ELSE
               QTRAC(24,I) =-ABS(Q(LMAIN + 9))
            ENDIF
         ELSE
            QTRAC(24,I) =-ABS(Q(LMAIN + 9))
         ENDIF
*
*--      Detectors used in the reconstruction
         KTRAC(25,I) = IQ(LPA + 2)
*
*--      First measured point of the track
         QTRAC(26,I) = VMOD(Q(LMAIN + 23),2)
         QTRAC(27,I) =      Q(LMAIN + 25)
*
*--      Chi2 of the track fit
         QTRAC(28,I) = Q(LMAIN + 16)
         QTRAC(29,I) = Q(LMAIN + 26)
*
*--      Number of d.o.f. of the track fit
         IF ( Q(LMAIN + 17) .LT.    0.   .OR.
     +        Q(LMAIN + 17) .GT. 1000. ) THEN
              Q(LMAIN + 17) = 0.
         ENDIF
*
         KTRAC(30,I) = NINT(Q(LMAIN + 17))
         KTRAC(31,I) = NINT(Q(LMAIN + 27))
*
*--      Impact parameters with geom. sign
*--      to the primary vertex
         CALL vfillr( DCA, 4, -999.)
         IF ( KVTX(16,1) .LE. 0 ) THEN
            CALL TBDCAE( QTRAC(4,I), QVTX(6,1), QVTX(10,1), DCA )
         ENDIF
         QTRAC(38,I) = DCA(1)
         QTRAC(39,I) = DCA(2)
*
*--      Impact parameters with geom. sign
*--      to the beam spot
         CALL vfillr( DCA, 4, -999.)
         CALL TBDCAE( QTRAC(4,I), XYZBS, COVVX, DCA )
         QTRAC(40,I) = DCA(1)
*
*--      Energy error (for team4 cut)
         QTRAC(41,I) = Q(LMAIN + 19)
*
*--      Chi2 of VD associated hits
         QTRAC(42,I) = Q(LMAIN + 18)
*
*--      RPhi assoc. hits in VD
         LQTDVD  =  LQ(LDTOP -  9)
         IF ( LQTDVD .GT. 0 ) THEN
            NVDH  =    IQ(LQTDVD-3)            ! Number of all VD hits
            NWPH = MOD(IQ(LQTDVD+1),1000)      ! Number of words per hit
            CALL vzeroi (NHITR(1), 3)
            CALL vzeroi (NHITZ(1), 3)
*
*--         Loop over the VD hits
            DO NH = 1, NVDH
*              Reference link to the PA bank
               IF ( LQ(LQTDVD - NH) .EQ. LPA ) THEN
                  LTH = LQTDVD+1 + (NH-1)*NWPH
                  IMOD = MOD(IQ(LTH + 1),1000)
                  ILAY = ABS(IMOD)/100 + 1
                  IF (NINT(Q(LTH + 2)) .GT. 0) THEN
                     NHITR(ILAY) = NHITR(ILAY) + 1
                  ELSE
                     NHITZ(ILAY) = NHITZ(ILAY) + 1
                  ENDIF
               ENDIF
            ENDDO
*
            CALL SBYT(NHITR(1), KTRAC(32,I), 1, 2)
            CALL SBYT(NHITR(2), KTRAC(32,I), 3, 2)
            CALL SBYT(NHITR(3), KTRAC(32,I), 5, 2)
*
            CALL SBYT(NHITZ(1), KTRAC(33,I), 1, 2)
            CALL SBYT(NHITZ(2), KTRAC(33,I), 3, 2)
            CALL SBYT(NHITZ(3), KTRAC(33,I), 5, 2)
         ENDIF
*
*--   For neutral tracks
      ELSE
*
*--      Theta and Phi
         IF ( Q(LMAIN+7) .NE. 0. ) THEN
             QTRAC( 6,I) = ACOS (Q(LMAIN+5)/Q(LMAIN+7))     ! Theta
             QTRAC( 7,I) = ATAN2(Q(LMAIN+4),Q(LMAIN+3))     ! Phi
         ENDIF
*
*--      Detectors used in the reconstruction
         KTRAC(25,I) = IQ(LPA + 2)
*
*--      Set the SAT tracker  (if charge = 3)
         IF ( NINT(Q(LMAIN+8)) .EQ. 3 )  THEN
            CALL SBYT( 1, KTRAC(25,I), 5, 1 )
         ENDIF
*
*--      Energy error (for cuts)
         QTRAC(41,I) = Q(LMAIN+19)
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSFEMC. **********************************************************
      SUBROUTINE PSFEMC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFEMC                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Jun  15, 1995                                  *
*     Task           :  To fill the Elm. calorimetry COMMONs           *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, MTRACK.
+CDE, PSCHPC.
+CDE, PSCEMF.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA,JBYT
      REAL    VMOD
*
*--   local variables
      INTEGER LEMCA,LSHOWR,LENSHO,IDETID
      INTEGER NLAYER,NBLOCK,LPATTR,IPACK
      INTEGER NCLUS,NWDCL,NC,IE,NL,IB,KB
      INTEGER LEL,NWIDET,IDET,NW,NWORD
      INTEGER NSHOWR,NS
      REAL    ESHOWR,EMFBLK(10),EMFEXB(16)
*
*--   Access the "EMCA" extra module
      LEMCA = LPHPA ('EMCA', LPA, 0)
      IF ( LEMCA .EQ. 0 )  GO TO 99
*
         NSHOWR = NINT(Q(LEMCA + 2))
         ESHOWR = 0.
*
*--      Loop over the showers
         DO NS = 1,NSHOWR
            LSHOWR = LPHPA('EMCA.SHOWER',LEMCA,NS)
            IF ( Q(LSHOWR + 3) .GT. ESHOWR )  THEN
               LENSHO = NINT(Q(LSHOWR+1))
               IDETID = NINT(Q(LSHOWR+2))
*
*--            Access the HPC information
               IF ( IDETID .EQ.  9 ) THEN
*
*--               Loop over the clusters
                  NCLUS  = NINT(Q(LSHOWR+10))
                  NWDCL  = NINT(Q(LSHOWR+11))
                  NCLUS =  MIN(NCLUS,(LENSHO-11)/NWDCL)
*
                  DO NC = 1,NCLUS
                     NW = NWDCL * (NC-1)
                     IPACK = NINT(Q(LSHOWR+11+NW+1))
                     IE = IPACK/64
                     NL = (IPACK - 64*IE) - 30
                     IF(IE .NE. 0) THEN
                       HPCLAY(NL,I) = HPCLAY(NL,I) + FLOAT(IE)/1000.
                     ENDIF
                  ENDDO
*
                  NLAYER = 0
                  LPATTR = 0
*
*--               Loop over the layers
                  DO NL = 1, NHPLAY
                     IF ( HPCLAY(NL,I) .NE. 0. ) THEN
                       CALL SBIT1 (LPATTR,NL)
                       NLAYER  =  NLAYER + 1
                     ENDIF
                  ENDDO
*
                  NHPC = NHPC + 1

                  QHPC( 1,I) = Q(LSHOWR + 3)
                  QHPC( 2,I) = ACOS (Q(LSHOWR+6)/VMOD(Q(LSHOWR+4),3))
                  QHPC( 3,I) = ATAN2(Q(LSHOWR+5),Q(LSHOWR+4))
                  IF ( QHPC( 3,I) .LT. 0. )
     +            QHPC( 3,I) = QHPC( 3,I) + 2.*PI
                  KHPC( 4,I) = JBYT(IQ(LPA+3), 19, 7 )
                  KHPC( 5,I) = NLAYER
                  KHPC( 6,I) = LPATTR
*
                  ESHOWR = Q(LSHOWR + 3)
                  KHPC( 7,I) = NSHOWR
                  QHPC( 8,I) = QHPC( 8,I) + ESHOWR
               ENDIF
*
*--            Access the EMF information
               IF ( IDETID .EQ. 26 ) THEN
                  LEL = LPHPA ('EL',LPA,0)
*
                  IF ( LEL .NE. 0 )  THEN
                     NWIDET = MOD(INT(Q(LEL+2)),10000)
                     NW     = MOD(NWIDET, 100)
                     IDET   =     NWIDET/ 100
*
                     CALL uzeror(EMFBLK, 1, 10)
                     CALL uzeror(EMFEXB, 1, 16)
                     NWORD = INT(Q(LEL+3))/10
*
                     NBLOCK = 0
                     LPATTR = 0
*
*--                  Loop over the blocks
                     DO IB = 1,NWORD-1
                        IF(Q(LEL+4+IB).NE.    0. .AND.
     +                     Q(LEL+4+IB).NE.-9999.) THEN
                           CALL SBIT1 (LPATTR,IB)
                           NBLOCK  =  NBLOCK + 1
                           IF ( IB .LE. 10) THEN
                              EMFBLK(IB  ) = Q(LEL+4+IB)
                           ELSE
                              KB=2*(IB-10)
                              EMFEXB(KB-1) = Q(LEL+4+IB)
                              EMFEXB(KB  ) = Q(LEL+4+IB)
                           ENDIF
                        ENDIF
                     ENDDO
*
                     NEMF = NEMF + 1
*
                     QEMF( 1,I) = Q(LSHOWR + 3)
                     QEMF( 2,I) = ACOS (Q(LSHOWR+6)/VMOD(Q(LSHOWR+4),3))
                     QEMF( 3,I) = ATAN2(Q(LSHOWR+5),Q(LSHOWR+4))
                     IF ( QEMF( 3,I) .LT. 0. )
     +               QEMF( 3,I) = QEMF( 3,I) + 2.*PI
                     KEMF( 4,I) = 0
                     KEMF( 5,I) = NBLOCK
                     KEMF( 6,I) = LPATTR
*
                     ESHOWR = Q(LSHOWR + 3)
                     KEMF( 7,I) = NSHOWR
                     QEMF( 8,I) = QEMF( 8,I) + ESHOWR
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
*
   99 CONTINUE
      END
*
*
+DECK,PSFPHO. **********************************************************
      SUBROUTINE PSFPHO(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFPHO                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Nov  21, 1994                                  *
*     Last update    :  Mar  19, 1995                                  *
*     Task           :  To fill the photon and pi0 ident. commons      *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP vector             *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCPHO.
+CDE, PSCPI0.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
*
*--   local variables
      INTEGER LPHOT,LPDAT
      INTEGER LNPHO,LNPI0,IDAT
*
*--   Access the "PHOT" extra module
      LPHOT = LPHPA ('PHOT', LPA, 0)
      IF ( LPHOT .EQ. 0 )  GO TO 99
*
         LPDAT  = NINT(Q(LPHOT+1))
         LNPHO  =  MOD(LPDAT,100)            ! Length of photon data
         LNPI0  =      LPDAT/100             ! Length of pi0    data
         IDAT   = 2
*
         IF ( LNPHO .GT. 0 ) THEN
            QPHOT( 1,I) =          Q(LPHOT + IDAT + 1)
            KPHOT( 2,I) =     NINT(Q(LPHOT + IDAT + 2))/1000
            KPHOT( 3,I) = MOD(NINT(Q(LPHOT + IDAT + 2))/100 ,10)
            KPHOT( 4,I) = MOD(NINT(Q(LPHOT + IDAT + 2))/10  ,10)
            KPHOT( 5,I) = MOD(NINT(Q(LPHOT + IDAT + 2))     ,10)
            QPHOT( 6,I) =          Q(LPHOT + IDAT + 3)
            QPHOT( 7,I) =          Q(LPHOT + IDAT + 4)
*
            NPHOT = NPHOT + 1
            IDAT  = IDAT  + 4
         ENDIF
*
         IF ( LNPI0 .GT. 0 ) THEN
            QPI0( 1,I) =          Q(LPHOT + IDAT +  1)
            QPI0( 2,I) =          Q(LPHOT + IDAT +  2)
            QPI0( 3,I) =          Q(LPHOT + IDAT +  3)
            QPI0( 4,I) =          Q(LPHOT + IDAT +  4)
            KPI0( 5,I) =     NINT(Q(LPHOT + IDAT +  5))
            KPI0( 6,I) =     NINT(Q(LPHOT + IDAT +  6))
            QPI0( 7,I) =          Q(LPHOT + IDAT +  7)
            QPI0( 8,I) =          Q(LPHOT + IDAT +  8)
            QPI0( 9,I) =          Q(LPHOT + IDAT +  9)
            QPI0(10,I) =          Q(LPHOT + IDAT + 10)
            QPI0(11,I) =          Q(LPHOT + IDAT + 11)
            QPI0(12,I) =          Q(LPHOT + IDAT + 12)
            QPI0(13,I) =          Q(LPHOT + IDAT + 13)
            QPI0(14,I) =          Q(LPHOT + IDAT + 14)
            QPI0(15,I) =          Q(LPHOT + IDAT + 15)
            QPI0(16,I) =          Q(LPHOT + IDAT + 16)
            QPI0(17,I) =          Q(LPHOT + IDAT + 17)
            QPI0(18,I) =          Q(LPHOT + IDAT + 18)
            QPI0(19,I) =          Q(LPHOT + IDAT + 19)
            KPI0(20,I) = MOD(NINT(Q(LPHOT + IDAT + 20)),100)
            KPI0(21,I) =     NINT(Q(LPHOT + IDAT + 20))/100
*
            NPI0 = NPI0 +  1
            IDAT = IDAT + 20
         ENDIF
*
   99 CONTINUE
      END
*
*
+DECK,PSFHAD. **********************************************************
      SUBROUTINE PSFHAD(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFHAD                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  07, 1993                                  *
*     Last update    :  Mar  03, 1997                                  *
*     Task           :  To fill the Hadron identification COMMONs      *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
*
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCHAD.
+CDE, PSCDEX.
+CDE, PSCGRC.
+CDE, PSCLRC.
*
+CDE, RIBPAR.
+CDE, RIBCHE.
+CDE, RIBTA.
+CDE, RIBGEN.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
      REAL    VMOD,BBDXER
*
*--   local variables
      INTEGER NWIR,I1,ITK,NHIT,IERVD,IQUA
      INTEGER LMAIN,IRICH,IQFLAG,IDTAN
      INTEGER METHOD,IQUAL
      REAL    DEDX,SIGM,ERROR,GAP
      REAL    VDDEDX,SIGVD
      REAL    PMOM,PRICH(5)
      REAL    EDEDX(5),DDEDX(5),UDEDX(5),PDEDX(5)
*
      IF ( I .EQ. 0 ) THEN
         CALL RICHID
CCC      CALL RINGSCAN(0)
         RETURN
      ENDIF
*
      LMAIN = LPHPA('MAIN',LPA,0)
      PMOM  = VMOD (Q(LMAIN+3),3)
*
*--   dE/dx identification
      IF ( IQ(LDTOP+3) .LT. 333 ) THEN
         CALL GETDEDX( LPA, DEDX, SIGM, NWIR, ERROR)
      ELSE
         CALL BBDXGET( LPA, DEDX, GAP, NWIR, METHOD)
         IF ( NWIR .GT. 1 ) THEN
            ERROR = BBDXER( DEDX, GAP, NWIR, METHOD, IQUAL )
         ELSE
            ERROR = -1.
         ENDIF
         NWIR = NINT(NWIR*.8)
      ENDIF
*
      IF ( DEDX .NE. 0. ) THEN
         QDEDX( 1,I) = DEDX
         QDEDX( 2,I) = 0.
         KDEDX( 3,I) = NWIR
         QDEDX( 4,I) = 0.
         QDEDX( 5,I) = ERROR
      ENDIF
*
*--   dE/dx with VD only
      CALL VRDEDX( LPA, VDDEDX, SIGVD, NHIT, IERVD )
      IF ( IERVD .EQ. 0 ) THEN
         QDEDX( 6,I) = VDDEDX
         KDEDX( 7,I) = NHIT
      ENDIF
*
*--   dE/dx counter
      IF ( DEDX  .NE. 0.  .OR.
     +     IERVD .EQ. 0 ) THEN
         NDEDX = NDEDX + 1
      ENDIF
*
*--   Kaon/Proton/Pion signature with dE/dx & RICH
*
      KHAID( 2,I) = -1
      KHAID( 3,I) = -1
      KHAID( 4,I) = -1
      KHAID( 5,I) = -1
      KHAID( 6,I) = -1
      QHAID( 7,I) = -1.
      QHAID( 8,I) = -1.
*
      CALL HADSIGN(LPA,ISIGN(I),XKAON(I),XPROTON(I),IDKAON(I),
     +                 IDPROTON(I),IKAON(I),IPROTON(I))
*
      CALL PIONSIGN(LPA, I1, IPION(I))
*
      IF ( ISIGN(I) .NE. 0 ) THEN
         KHAID( 1,I) = ISIGN   (I)
         KHAID( 2,I) = IDKAON  (I)
         KHAID( 3,I) = IDPROTON(I)
         KHAID( 4,I) = IKAON   (I)
         KHAID( 5,I) = IPROTON (I)
         KHAID( 6,I) = IPION   (I)
         QHAID( 7,I) = XKAON   (I)
         QHAID( 8,I) = XPROTON (I)
      ENDIF
*
*--   RICH quality status
      CALL GETTRK( IQ(LPA+1), ITK )
      IF ( ITK .GT. 0 ) THEN
         CALL RISTAT( ITK, IQUA )
         KHAID( 9,I) = IQUA
      ENDIF
*
*--   Identification counter
      IF ( ISIGN(I) .NE. 0   .OR.
     +     ITK      .GT. 0 ) THEN
         NHAID = NHAID + 1
      ENDIF
*
*--   New hadron identification based on...
*
      CALL vfilli( KHAIDN(1,I), LNHADN, -1 )
      CALL vfilli( KHAIDT(1,I), LNHADN, -1 )
      CALL vfilli( KHAIDR(1,I), LNHADR, -1 )
      CALL vfilli( KHAIDE(1,I), LNHADE, -1 )
      CALL vfilli( KHAIDC(1,I), LNHADC, -1 )
*
      IDTAN = IQ(  LPA  + 1 )
*
      LMAIN = LPHPA('MAIN',LPA,0)
      PMOM  = VMOD (Q(LMAIN+3),3)
      IF ( PMOM .GT.  0. )  THEN
                                            IRICH = 1
         IF( ABS(Q(LMAIN+5)/PMOM) .GT. .7 ) IRICH = 2
*
*--      ... RICH gas/liquid, Cherenkov angle,
*--        number of photons and quality flag
*
         CALL GETMINE( 1 )
         CALL XNEWTAG( IDTAN, KHAIDN(1,I), KHAIDN(2,I),
     +                        KHAIDN(3,I), KHAIDN(4,I),
     +                        KHAIDT(1,I), KHAIDT(2,I),
     +                        KHAIDT(3,I), KHAIDT(4,I))
*
*--      ... RICH gas/liquid and RIBMEAN probablities
*
         CALL XNEWPRO( IDTAN, KHAIDR(1,I), KHAIDR(2,I), KHAIDR(3,I),
     +                        KHAIDR(4,I), KHAIDR(5,I), KHAIDR(6,I),
     +                        PRICH )
*
*--      ... dE/dx in TPC using probablities
*
         IF ( IQ(LDTOP+3) .LT. 333 ) THEN
            CALL GETDEDX( LPA, DEDX, SIGM, NWIR, ERROR )
            CALL RPRODO ( PMOM, IRICH, DEDX, SIGM, NWIR,
     +                    EDEDX,  DDEDX,  UDEDX,  PDEDX,
     +                    IQFLAG     , KHAIDE(1,I), KHAIDE(2,I),
     +                    KHAIDE(3,I), KHAIDE(4,I), KHAIDE(5,I))
         ELSE
            CALL RPRODE ( LPA,
     +                    PMOM, IRICH, DEDX, SIGM, NWIR,
     +                    EDEDX,  DDEDX,  UDEDX,  PDEDX,
     +                    IQFLAG     , KHAIDE(1,I), KHAIDE(2,I),
     +                    KHAIDE(3,I), KHAIDE(4,I), KHAIDE(5,I))
         ENDIF
*
         IF ( IQFLAG .EQ. 2 )  KHAIDE( 6,I) = 1
*
*--      ... combined RICH and TPC probablities
*
         CALL RPROCO( PMOM, PDEDX, PRICH, IRICH,
     +                KHAIDC(1,I),  KHAIDC(2,I),
     +                KHAIDC(3,I),  KHAIDC(4,I),
     +                KHAIDC(5,I))
*
         IF ( KHAIDR(6,I) .GE. 0 ) THEN
            KHAIDC(6,I) = KHAIDR(6,I)
            IF ( IQFLAG .EQ. 2 ) CALL SBIT1(KHAIDC(6,I), 3)
         ELSE
            IF ( IQFLAG .EQ. 2 ) THEN
               KHAIDC(6,I) = 0
               CALL SBIT1(KHAIDC(6,I), 3)
           ENDIF
        ENDIF
*
      ENDIF
*
*--   Cerenkov angle from RICH
*
      THEG (I) = -1.
      SIGG (I) = -1.
      NPHG (I) = -1
      NEPG (I) = -1
      FLAGG(I) = -1.
*
      THEL (I) = -1.
      SIGL (I) = -1.
      NPHL (I) = -1
      NEPL (I) = -1
      FLAGL(I) = -1.
*
*--   Does the track have RICH info ?
      CALL GETTRK( IQ(LPA+1), ITK )
*
      IF ( ITK .GT. 0 )  THEN
*
*--      RICH gas data
         NGRIC = NGRIC + 1
*
         QGRIC( 1,I) =      RIBCHG(11, ITK)
         QGRIC( 2,I) =      RIBCHG(13, ITK)
         KGRIC( 3,I) = NINT(RIBCHG( 2, ITK))
         QGRIC( 4,I) =      RIBGMA(4,1,ITK)
         KGRIC( 5,I) = NINT(FLARIG(    ITK))
*
         THEG (I) = QGRIC( 1,I)
         SIGG (I) = QGRIC( 2,I)
         NPHG (I) = KGRIC( 3,I)
         NEPG (I) = NINT(QGRIC( 4,I))
         FLAGG(I) = KGRIC( 5,I)
*
*--      RICH liquid data
         NLRIC = NLRIC + 1
*
         QLRIC( 1,I) =      RIBCHL(11, ITK)
         QLRIC( 2,I) =      RIBCHL(13, ITK)
         KLRIC( 3,I) = NINT(RIBCHL( 2, ITK))
         QLRIC( 4,I) =      RIBLMA(4,1,ITK)
         KLRIC( 5,I) = NINT(FLARIL(    ITK))
*
         THEL (I) = QLRIC( 1,I)
         SIGL (I) = QLRIC( 2,I)
         NPHL (I) = KLRIC( 3,I)
         NEPL (I) = NINT(QLRIC( 4,I))
         FLAGL(I) = KLRIC( 5,I)
      ENDIF
*
   99 CONTINUE
      END
*
+DECK,PSFSTC. **********************************************************
      SUBROUTINE PSFSTC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFSTC                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  May 26, 1995                                   *
*     Last update    :  May 18, 1998                                   *
*     Task           :  To fill the STIC information commons           *
*                                                                      *
*     Input          :  LPA - track address in the ZEBRA structure     *
*                       I   - track index   in the VECP vector         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, MTRACK.
+CDE, PSCSTC.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
*
*--   local variables
      INTEGER LSTIC,LSHOWR,NSHOWR,LENSHO,NS
*
*--   Access the STIC extra module
      LSTIC = LPHPA ('STIC',LPA,0)
      IF ( LSTIC .EQ. 0 ) GO TO 99
*
         NSTIC  = NSTIC + 1
*
         NSHOWR = NINT(Q(LSTIC  + 2))
         LSHOWR = LSTIC + 3
         LENSHO = NINT(Q(LSHOWR + 1))
*
         DO NS = 1, NSHOWR
            QSTIC( 1,I) = Q(LSHOWR + 5)
            QSTIC( 2,I) = ATAN2(Q(LSHOWR + 6), Q(LSHOWR + 8))
            QSTIC( 3,I) = Q(LSHOWR + 7)/Q(LSHOWR + 6)
            KSTIC( 4,I) = NINT(Q(LSHOWR + 3)/1000.)
*
*--         Charged tag from the Veto counters
            CALL SDVETO( LSHOWR, KSTIC( 5,I), KSTIC( 6,I) )
*
*--         Veto multiplicity side A and C
            CALL VEDECODE( KSTIC( 7,I), KSTIC( 8,I) )
*
*--         Silicon strip vertex position
            KSTIC( 9,I) = 0
*
CCC         LSHOWR = LSHOWR+LENSHO
         ENDDO
*
   99 CONTINUE
      END
*
+DECK,PSFVDH. **********************************************************
      SUBROUTINE PSFVDH
************************************************************************
*                                                                      *
*     Name           :  PSFVDH                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1994                                  *
*     Last update    :  Jun  19, 1997                                  *
*     Task           :  To fill the VD hits COMMONs                    *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCVDA.
+CDE, PSCVDU.
*
*--   functions
      INTEGER  IUCOMP
      REAL     EVS2N
      EXTERNAL EVS2N
*
*--   local variables
      INTEGER LPA,LQTDVD,NWPH,LTH,NH,I
      INTEGER ISTR,NSTR,MAXSTR,IRFIOZ
      REAL    XPH(10),XNOI(10)
*
*--   Micro VD hits bank address
      IF (LDTOP  .LE. 0) GOTO 99
      LQTDVD = LQ(LDTOP -  9)
      IF (LQTDVD .LE. 0) GOTO 99
*
*--   Find the number of hits
      NVDHT =     IQ(LQTDVD-3)           ! Number of all  VD  hits
      NWPH  = MOD(IQ(LQTDVD+1),1000)     ! Number of words per hit
*
      MAXSTR = 7
*
*--   Loop over the VD hits
      DO NH = 1, NVDHT
*
*--      Take the associated hits first
         IF (LQ(LQTDVD-NH) .NE. 0) THEN
*
*--         Skip the dropped hits (if any)
            LTH = LQTDVD + 1 + (NH-1)*NWPH
            IF ( Q(LTH + 2) .NE. 0. ) THEN
*
*--            Reference link
               LPA = LQ(LQTDVD - NH)
*
               I = IUCOMP(LPA,LVECP,NVECP)
*
               IF ( I .NE. 0 ) THEN
*
*--               Data words
                  NVDAS = NVDAS + 1
*
                  NASHT(I) = NASHT(I)+1
                  KVDAS( 1,I,NASHT(I) ) = MOD(IQ(LTH + 1), 1000)
                  QVDAS( 2,I,NASHT(I) ) =      Q(LTH + 6)
                  QVDAS( 3,I,NASHT(I) ) =      Q(LTH + 2)
                  IF ( Q(LTH+2) .GT. 0. ) THEN
                     QVDAS( 4,I,NASHT(I)) =    Q(LTH + 3)
                  ELSE
                     QVDAS( 4,I,NASHT(I)) =    Q(LTH + 4)
                  ENDIF
*
*--               Rphi 0r RZ hit ?
                  IRFIOZ = 1 - NINT(SIGN(1.,Q(LTH + 2)))
*
*--               Strip information
                  NSTR = 0
                  DO ISTR = 1, MAXSTR
                     IF ( Q(LTH + 6 + ISTR) .GE. -99998.0 ) THEN
                        XPH (ISTR) = INT( Q(LTH + 6 + ISTR) )
                        XNOI(ISTR) =(ABS( Q(LTH + 6 + ISTR) )
     -                             - ABS( XPH(ISTR)) ) *1000.
                        NSTR = ISTR
                     ENDIF
                  ENDDO
*
                  QVDAS( 5,I,NASHT(I)) = EVS2N(XPH,XNOI,NSTR,IRFIOZ)
*
               ENDIF
            ENDIF
         ENDIF
      ENDDO
*
*--   Loop over the VD hits
      DO NH = 1, NVDHT
*
*--      Take the unassociated hits now
         IF (LQ(LQTDVD-NH) .EQ. 0) THEN
*
*--         Skip the dropped hits (if any)
            LTH = LQTDVD + 1 + (NH-1)*NWPH
            IF ( Q(LTH + 2) .NE. 0. ) THEN
*
*--            Data words
               NVDUN = NVDUN + 1
*
               KVDUN(1,NVDUN) = MOD(IQ(LTH + 1), 1000)
               QVDUN(2,NVDUN) =      Q(LTH + 6)
               QVDUN(3,NVDUN) =      Q(LTH + 2)
               IF ( Q(LTH+2) .GT. 0. ) THEN
                  QVDUN(4,NVDUN) =   Q(LTH + 3)
               ELSE
                  QVDUN(4,NVDUN) =   Q(LTH + 4)
               ENDIF
*
*--            Rphi 0r RZ hit ?
               IRFIOZ = 1 - NINT(SIGN(1.,Q(LTH + 2)))
*
*--            Strip information
               NSTR = 0
               DO ISTR = 1, MAXSTR
                  IF ( Q(LTH + 6 + ISTR) .GE. -99998.0 ) THEN
                     XPH (ISTR) = INT( Q(LTH + 6 + ISTR) )
                     XNOI(ISTR) =(ABS( Q(LTH + 6 + ISTR) )
     -                          - ABS( XPH(ISTR)) ) *1000.
                     NSTR = ISTR
                  ENDIF
               ENDDO
*
               QVDUN( 5,NVDUN) = EVS2N(XPH,XNOI,NSTR,IRFIOZ)
*
            ENDIF
         ENDIF
      ENDDO
*
      NVDHT = NVDAS + NVDUN
*
   99 CONTINUE
      END
*
+DECK,PSFRV0. **********************************************************
      SUBROUTINE PSFRV0
************************************************************************
*                                                                      *
*     Name           :  PSFRV0                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Apr  08, 1999                                  *
*     Task           :  To fill the Reconstructed V0 COMMON's          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCBSP.
+CDE, PSCVEC.
+CDE, PSCRV0.
+CDE, PSCHV0.
+CDE, MAMCOM.
*
*--   functions
      INTEGER IUCOMP,JBYT
*
*--   local variables
      INTEGER I,J,LMAX,LRV0(3),ICW,IDAT
      INTEGER NWV0,NHYP,NWHP,KFIT,NPRB
      INTEGER NV0L,NV0T,IFLAGV
      REAL    V0DATA(100)
*
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST /.TRUE./
*
*--   MAMMOTH initialization
      IF ( FIRST ) THEN
         CALL MAMDATA
         L_RECV0 = .TRUE.
         FIRST   = .FALSE.
      ENDIF
*
      NRV0 = 0
      NV0L = 0
      NV0T = 0
      CALL uzeror( QRV0  , 1, LENRV0*NV0MAX )
      CALL uzeror( QRV0H1, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H2, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H3, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H4, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H5, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H6, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H7, 1, LENHV0*NV0MAX )
      CALL uzeror( QRV0H8, 1, LENHV0*NV0MAX )
*
*--   Call the  V0  reconstruction code
*
      CALL MAMMOTH
      CALL GIVENV0( NRV0 )
*
      IF ( NRV0 .GT. 0 ) THEN
*--
         DO I = 1, NRV0
            LMAX = 100
            CALL GETV0I ( I, LMAX, V0DATA(1), LRV0(1) )
*
*--         Indecies of the V0 prongs
            KRV0( 1,I) = IUCOMP ( LRV0(1), LVECP(1), NVECP )
            KRV0( 2,I) = IUCOMP ( LRV0(2), LVECP(1), NVECP )
*
*--         Data words
            ICW    = NINT( V0DATA(1) )
            NWV0   = JBYT( ICW,  1, 10 )
            NHYP   = JBYT( ICW, 11,  4 )
            IFLAGV = JBYT( ICW, 15,  6 )
*
            IF ( IFLAGV .EQ. 0 ) THEN
               NV0L = NV0L + 1
            ELSE
               NV0T = NV0T + 1
            ENDIF
*
            KRV0( 5,I) = IFLAGV
            CALL ucopyr ( V0DATA(2), QRV0( 6,I), 14 )
*
            IDAT = 15
*
*--         Reconstructed V0 hypotheses
            KRV0H1( 1,I) = -1
            KRV0H2( 1,I) = -1
            KRV0H3( 1,I) = -1
            KRV0H4( 1,I) = -1
            KRV0H5( 1,I) = -1
            KRV0H6( 1,I) = -1
            KRV0H7( 1,I) = -1
            KRV0H8( 1,I) = -1
*
            DO J = 1, NHYP
               NWHP = JBYT(NINT(V0DATA(IDAT + 1)),  1, 10)
               KFIT = JBYT(NINT(V0DATA(IDAT + 1)), 11,  6)
               NPRB = JBYT(NINT(V0DATA(IDAT + 1)), 17,  7)
*
               IF ( KFIT .EQ.  1 ) THEN
                  KRV0H1( 1,I) = KFIT
                  QRV0H1( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H1( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ.  2 ) THEN
                  KRV0H2( 1,I) = KFIT
                  QRV0H2( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H2( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 11 ) THEN
                  KRV0H3( 1,I) = KFIT
                  QRV0H3( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H3( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 12 ) THEN
                  KRV0H4( 1,I) = KFIT
                  QRV0H4( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H4( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 21 ) THEN
                  KRV0H5( 1,I) = KFIT
                  QRV0H5( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H5( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 22 ) THEN
                  KRV0H6( 1,I) = KFIT
                  QRV0H6( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H6( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 31 ) THEN
                  KRV0H7( 1,I) = KFIT
                  QRV0H7( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H7( 3,I), NWHP-1)
               ELSEIF ( KFIT .EQ. 32 ) THEN
                  KRV0H8( 1,I) = KFIT
                  QRV0H8( 2,I) = FLOAT(NPRB)/100.
                  CALL ucopyr( V0DATA(IDAT + 2), QRV0H8( 3,I), NWHP-1)
               ENDIF
*
               IDAT = IDAT + NWHP
            ENDDO
         ENDDO
      ENDIF
*
      END
*
+DECK,PSFUTE. **********************************************************
      SUBROUTINE PSFUTE
************************************************************************
*                                                                      *
*     Name           :  PSFUTE                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Jun  15, 1995                                  *
*     Task           :  To fill the Unassociated TER's COMMON          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCTER.
*
*--   functions
      INTEGER JBYT,NUMBIT
*
*--   local variables
      INTEGER LQTEAD,LQUTER
      INTEGER NB,ME
*
      NTEOD  = 0
      CALL vzeroi( KTEOD ,LENUTE*NUTMAX )
      NTEFCA = 0
      CALL vzeroi( KTEFCA,LENUTE*NUTMAX )
      NTEFCB = 0
      CALL vzeroi( KTEFCB,LENUTE*NUTMAX )
*
*--   Unassoc.  TE bank address
      IF (LDTOP .LE. 0)  RETURN
      LQTEAD  =  LQ(LDTOP - 10)
*
      IF ( LQTEAD .GT. 0 ) THEN
*
*--      TER's in OD
         LQUTER = LQ(LQTEAD - 4)
*
         DO WHILE ( LQUTER .NE. 0 )
            NB = JBYT( IQ(LQUTER + 4),  6, 12 )
            NB = NUMBIT( NB )
            ME = NB*(NB+1)/2
*
            NTEOD  = NTEOD  + 1
*
            KTEOD ( 1,NTEOD ) = IQ(LQUTER +  4)
            QTEOD ( 2,NTEOD ) =  Q(LQUTER +  5)
            QTEOD ( 3,NTEOD ) =  Q(LQUTER +  6)
            QTEOD ( 4,NTEOD ) =  Q(LQUTER +  7)
            QTEOD ( 5,NTEOD ) =  Q(LQUTER +  8)
            QTEOD ( 6,NTEOD ) =  Q(LQUTER +  9)
            QTEOD ( 7,NTEOD ) =  Q(LQUTER + 10)
            QTEOD ( 8,NTEOD ) =  Q(LQUTER + 13 + ME)
*
            LQUTER = LQ(LQUTER)
         ENDDO
*
*--      TER's in FCA
         LQUTER = LQ(LQTEAD - 7)
*
         DO WHILE ( LQUTER .NE. 0 )
            NB = JBYT( IQ(LQUTER + 4),  6, 12 )
            NB = NUMBIT( NB )
            ME = NB*(NB+1)/2
*
            NTEFCA = NTEFCA + 1
*
            KTEFCA( 1,NTEFCA) = IQ(LQUTER +  4)
            QTEFCA( 2,NTEFCA) =  Q(LQUTER +  5)
            QTEFCA( 3,NTEFCA) =  Q(LQUTER +  6)
            QTEFCA( 4,NTEFCA) =  Q(LQUTER +  7)
            QTEFCA( 5,NTEFCA) =  Q(LQUTER +  8)
            QTEFCA( 6,NTEFCA) =  Q(LQUTER +  9)
            QTEFCA( 7,NTEFCA) =  Q(LQUTER + 10)
            QTEFCA( 8,NTEFCA) =  Q(LQUTER + 13 + ME)
*
            LQUTER = LQ(LQUTER)
         ENDDO
*
*--      TER's in FCB
         LQUTER = LQ(LQTEAD - 9)
*
         DO WHILE ( LQUTER .NE. 0 )
            NB = JBYT( IQ(LQUTER + 4),  6, 12 )
            NB = NUMBIT( NB )
            ME = NB*(NB+1)/2
*
            NTEFCB = NTEFCB + 1
*
            KTEFCB( 1,NTEFCB) = IQ(LQUTER +  4)
            QTEFCB( 2,NTEFCB) =  Q(LQUTER +  5)
            QTEFCB( 3,NTEFCB) =  Q(LQUTER +  6)
            QTEFCB( 4,NTEFCB) =  Q(LQUTER +  7)
            QTEFCB( 5,NTEFCB) =  Q(LQUTER +  8)
            QTEFCB( 6,NTEFCB) =  Q(LQUTER +  9)
            QTEFCB( 7,NTEFCB) =  Q(LQUTER + 10)
            QTEFCB( 8,NTEFCB) =  Q(LQUTER + 13 + ME)
*
            LQUTER = LQ(LQUTER)
         ENDDO
      ENDIF
*
      END
*
*
+DECK,PSFBTG. **********************************************************
      SUBROUTINE PSFBTG
************************************************************************
*                                                                      *
*     Name           :  PSFBTG                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Nov  15, 1993                                  *
*     Last update    :  Mar  19, 1995                                  *
*     Task           :  To fill the B tagging COMMON                   *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCBSP.
+CDE, PSCVTX.
+CDE, PSCBTG.
+CDE, AAMAIN.
+CDE, AAFLAG.
+CDE, AAMNVX.
+CDE, AAJETS.
+CDE, AAPARM.
*
*--   functions
      INTEGER LPHPA,IUCOMP
*
*--   local variables
      INTEGER LPV,LPA,LMAIN,J
      REAL    PROBN, PROBP, PROBS
      REAL    PROBHN(2),PROBHP(2)
      REAL    PROBHS(2),PTHRST(3)
      CHARACTER*4 NAMBTG
*
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST /.TRUE./
*
*--   AABTAG initialization
      IF ( FIRST ) THEN
         FIRST = .FALSE.
*
         NAMBTG = NAMDST
         CALL AADATA
         NAMDST = NAMBTG
         IFK0ST = .TRUE.
         IFRFIX = .TRUE.
      ENDIF
*
      CALL vfillr( QBTPRN, 3, 2.)
      CALL vfillr( QBTPRP, 3, 2.)
      CALL vfillr( QBTPRS, 3, 2.)
      CALL vfillr( QBTTHR, 4, 2.)
*
*--   Check the Beam Spot quality
      IF ( IERRBS .EQ. 0 ) THEN
*
         CALL AABTGS( XYZBS, DXYZBS, PROBN, PROBP, PROBS )
*
         IF (IFLPVT.EQ.1) THEN
           IF ( IBAD .EQ. 0 ) THEN
             NDOFVX = NATTVX
             KVTX( 3,1) = NATTVX
             KVTX( 4,1) = NDOFVX
*
*--         Vertex coordinates
             QVTX( 6,1) = POSVX(1)
             QVTX( 7,1) = POSVX(2)
             QVTX( 8,1) = POSVX(3)
*
*--         Chi2 of the vertex fit
             QVTX( 9,1) = CHI2VX
*
*--         Covariance matrix
             QVTX(10,1) = COVVX(1)
             QVTX(11,1) = COVVX(2)
             QVTX(12,1) = COVVX(3)
             QVTX(13,1) = COVVX(4)
             QVTX(14,1) = COVVX(5)
             QVTX(15,1) = COVVX(6)
           ELSE
*--         Vertex coordinates
             QVTX( 6,1) = XYZBS(1)
             QVTX( 7,1) = XYZBS(2)
             QVTX( 8,1) = XYZBS(3)
           ENDIF
*
*--      Error flag
           KVTX(16,1) = IBAD
         ENDIF
*
*--      B-tagging  probabilities
         QBTPRN(3) = PROBN
         QBTPRP(3) = PROBP
         QBTPRS(3) = PROBS
*
*--      Hemisphere probabilities
         CALL AAHEMI( PROBHN, PROBHP, PROBHS, PTHRST )
*
         QBTPRN(1) = PROBHN(1)
         QBTPRN(2) = PROBHN(2)
         QBTPRP(1) = PROBHP(1)
         QBTPRP(2) = PROBHP(2)
         QBTPRS(1) = PROBHS(1)
         QBTPRS(2) = PROBHS(2)
         QBTTHR(1) = PTHRST(1)
         QBTTHR(2) = PTHRST(2)
         QBTTHR(3) = PTHRST(3)
         QBTTHR(4) = THRVAL
      ELSE
         IF (IFLPVT.EQ.1) THEN
*--      Vertex coordinates
           QVTX( 6,1) = -999.
           QVTX( 7,1) = -999.
           QVTX( 8,1) = -999.
           KVTX(16,1) =    1
         ENDIF
      ENDIF
*
*--   Chi2 of associated VD hits
      LPV = LQ(LDTOP - 1)
      DO WHILE (LPV .NE. 0)
         LPA =  LQ(LPV - 1)
         DO WHILE (LPA .NE. 0)
            J = IUCOMP( LPA, IADTR, NTRK )
            IF ( J .NE. 0 ) THEN
               LMAIN = LPHPA('MAIN',LPA,0)
               Q(LMAIN + 18)  =  CHI2VD(J)
            ENDIF
            LPA = LQ(LPA)
         ENDDO
         LPV = LQ(LPV)
      ENDDO
*
   99 CONTINUE
      END
*
+DECK,PSFECL. **********************************************************
      SUBROUTINE PSFECL
************************************************************************
*                                                                      *
*     Name           :  PSFECL                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  July 18, 1999                                  *
*     Last update    :  July 18, 1999                                  *
*     Task           :  To fill the electromagnetic cluster COMMON     *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, PSCECL.
+CDE, PEMOUT.
*
*--   functions
      INTEGER IUCOMP,JBYT,JBIT
*
*--   local variables
      INTEGER N,I,J
      INTEGER NPACLU,NP
      INTEGER NPACLF,IPATYP
      INTEGER ISEARCH
*
      IF ( NECL .EQ. 0 ) GO TO 99
*
      NEMCLU = NECL
      NPACLF = 1
*
*--   Loop on clusters
      DO N = 1, NEMCLU
*
*--      Number of associated PA's
         NPACLU = JBYT( NINT(DEMCLU( 6,N)), 19, 6 )
         IPATYP = 1
*
*--      Reference links
         DO NP = NPACLF, NPACLF+NPACLU-1
            I  = IUCOMP( LEMCLU(NP), LVECP, NVECP )
*
*--         Cluster data
            IF ( NP .EQ. NPACLF ) THEN
              IF ( I .EQ.  0 ) GO TO 90
               QEMCLU( 1,I) =           DEMCLU( 1,N)
               QEMCLU( 2,I) =           DEMCLU( 2,N)
               QEMCLU( 3,I) =           DEMCLU( 3,N)
               QEMCLU( 4,I) =           DEMCLU( 4,N)
               QEMCLU( 5,I) =           DEMCLU( 5,N)
               KEMCLU( 6,I) = JBYT(NINT(DEMCLU( 6,N)), 1, 6)
               KEMCLU( 7,I) = 1 + 1000*N
               KEMCLU( 8,I) = NPACLU
               KEMCLU( 9,I) = JBYT(NINT(DEMCLU( 6,N)), 17, 2)
               IF (KEMCLU( 9,I).EQ.2) KEMCLU( 9,I) = -1
*
               IEMCLU(I) = N
            ELSE
               IPATYP = IPATYP +  1
               IF ( I .GT. 0 ) THEN
                  J = JBIT(NINT(DEMCLU( 7,N)), IPATYP)
                  ISEARCH = JBIT(NINT(DEMCLU( 6,N)),7)
                  IF( J .EQ. 1 ) KEMCLU( 7,I) = 2 + 1000*N
                  IF( J .EQ. 0 ) THEN
                    IF (ISEARCH.EQ.0) THEN
                      KEMCLU( 7,I) = 4 + 1000*N
                    ELSE
                      KEMCLU( 7,I) = 3 + 1000*N
                    ENDIF
                  ENDIF
*
                  IF (NP-NPACLF+1.EQ.JBYT(NINT(DEMCLU( 6,N)), 8, 5))
     &              THEN
                      KEMCLU( 7,I) = 11 + 1000*N
                  ENDIF
*
                  IEMCLU(I) = N
               ENDIF
            ENDIF
         ENDDO
*
   90    CONTINUE
         NPACLF = NPACLF + NPACLU
      ENDDO
*
   99 CONTINUE
      END
*
+DECK,PSFMC. ***********************************************************
      SUBROUTINE PSFMC
************************************************************************
*                                                                      *
*     Name           :  PSFMC                                          *
*     Called by      :  PSFULL                                         *
*     Date of coding :  May 08, 1994                                   *
*     Last update    :  Mar 07, 1995                                   *
*     Task           :  To steer the reading of simulation banks       *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
*
*--   Read the Simulation banks
      IF ( LQ(LDTOP - 2) .NE. 0  .AND.
     +     LQ(LDTOP - 3) .NE. 0 ) THEN
*        full  DST structure
         CALL PSFLUJ
         CALL PSFSIM
      ELSE
         WRITE(*,1000) IIIRUN,IIIEVT,NEVENT
      ENDIF
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSFULL-E-PSFMC, ','No simulation structure for'
     +      ,/,1X,'                 ','Run',I7,', Event',I6,'/',I6,/)
      END
*
+DECK,PSFLUJ. **********************************************************
      SUBROUTINE PSFLUJ
************************************************************************
*                                                                      *
*     Name           :  PSFLUJ                                         *
*     Called by      :  PSFMC                                          *
*     Date of coding :  May 08, 1994                                   *
*     Last update    :  Feb 15, 2000                                   *
*     Task           :  To fill the LUND-like common (full DST)        *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCLUJ.
+CDE, PSCTBL.
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER LPV,LST,LSH,LSHMO
      INTEGER IORDER(NPMAX)
      INTEGER I,M
*
*--   Loop over the SH's
      LSH = LQ(LDTOP - 3)
*
      I  = 0
*
      DO WHILE ( LSH .NE. 0 )
         IF ( NINT(Q(LSH + 1)) .NE. 0 ) THEN
            I = I + 1
            IORDER(I) = NINT(Q(LSH + 9))
*
            KP(I,1) =     NINT(Q(LSH + 10))/10000
            KP(I,2) =     NINT(Q(LSH + 11))
*
            LSHMO = LQ(LSH - 2)
            IF ( LSHMO .GT. 0 ) THEN
               KP(I,3) = NINT(Q(LSHMO + 9))
               KP(I,3) = IUCOMP(KP(I,3), IORDER(1), I)
            ELSE
               KP(I,3) = 0
            ENDIF
*
            KP(I,4) = 0
            KP(I,5) = 0
*
            PP(I,1) = Q(LSH + 3)
            PP(I,2) = Q(LSH + 4)
            PP(I,3) = Q(LSH + 5)
            PP(I,4) = Q(LSH + 6)
            PP(I,5) = Q(LSH + 2)
*
            ZF(I)   = Q(LSH +12)
            DM(I)   = Q(LSH +14)
*
            LST = LQ(LSH - 4)
            IF ( LST .GT. 0 ) THEN
               LPV = LQ(LST + 1)
               IF ( LPV .GT. 0 ) THEN
                  VP(I,1) = Q(LPV + 5)
                  VP(I,2) = Q(LPV + 6)
                  VP(I,3) = Q(LPV + 7)
                  VP(I,4) = 0.
                  VP(I,5) = 0.
               ENDIF
            ENDIF
         ENDIF
         LSH = LQ(LSH)
      ENDDO
*
      NP = MIN(I,NVMAX)
*
      DO I = 1, NP
         M = KP(I,3)
         IF ( M .NE. 0 ) THEN
            IF ( KP(M,4) .EQ. 0 ) KP(M,4)=I
                                  KP(M,5)=I
         ENDIF
      ENDDO
*
*--   Correspondence tables SH <--> LU
      DO I = 1, NP
         ILUSH(I) = I
         ISHLU(I) = I
      ENDDO
*
      END
*
+DECK,PSFSIM. **********************************************************
      SUBROUTINE PSFSIM
************************************************************************
*                                                                      *
*     Name           :  PSFSIM                                         *
*     Called by      :  PSFMC                                          *
*     Date of coding :  May 20, 1994                                   *
*     Last update    :  Oct 16, 1995                                   *
*     Task           :  To fill-up the VECP vector for simulation      *
*                       and the correspondence tables: LU <--> ST      *
*                                                      ST <--> PA      *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCLUJ.
+CDE, PSCVTX.
+CDE, PSCVEC.
+CDE, PSCTBL.
*
*--   functions
      INTEGER LPHPA,IUCOMP
*
*--   local variables
      INTEGER LPV,LPA,LST,LSH
      INTEGER LMAIN,LSTOUT,LSTINC
      INTEGER NPVS,NSTS,NSHS,NTRK
      INTEGER MSTJ,ICHA,I
*
      INTEGER LPVS(NVTXMX)
      INTEGER LSTS(NVMAX),LSHS(NVMAX)
*
*--   Loop on the PV's and ST's
      NPVS = 0
      NSTS = 0
      LPV  = LQ(LDTOP - 2)
*
      DO WHILE ( LPV .NE. 0 )
         IF ( NPVS .LT. NVTXMX ) THEN
            NPVS = NPVS  + 1
            LPVS(NPVS) = LPV
         ELSE
            WRITE(*,1000) NPVS,'PV',NVTXMX,IIIRUN,IIIEVT,NEVENT
            GO TO 99
         ENDIF
*
         LST = LQ(LPV - 1)
*
         NTRK = 0
*
         DO WHILE ( LST .NE. 0 )
            NTRK = NTRK  + 1
*
            IF ( NSTS .LT. NVMAX ) THEN
               NSTS = NSTS  + 1
               LSTS(NSTS) = LST
            ELSE
               WRITE(*,1000) NSTS,'ST',NVMAX,IIIRUN,IIIEVT,NEVENT
               GO TO 99
            ENDIF
*
            LST = LQ(LST)
         ENDDO
*
*--      Number of the outgoing particles
*--      is wrong on the original MC  DST
         IQ(LPV+2) = NTRK
*
         LPV = LQ(LPV)
      ENDDO
*
*--   Loop on the SH's
      NSHS = 0
      LSH  = LQ(LDTOP - 3)
      IF ( LSH .NE. 0 ) MSTJ = NINT(Q(LSH+13))
*
      DO WHILE ( LSH .NE. 0 )
         IF ( NINT(Q(LSH + 1)) .NE. 0 ) THEN
            IF ( NSHS .LT. NVMAX ) THEN
               NSHS = NSHS  + 1
               LSHS(NSHS) = LSH
            ELSE
               WRITE(*,1000) NSHS,'SH',NVMAX,IIIRUN,IIIEVT,NEVENT
               GO TO 99
            ENDIF
         ENDIF
         LSH = LQ(LSH)
      ENDDO
*
*--   Vertex MC information
      DO I = 1, NPVS
         NVTXMC = NVTXMC + 1
         LVTX(NVTXMX+NVTXMC) = LPVS(I)
*
         LSTOUT = LQ( LPVS(I) - 1 )
         LSTINC = LQ( LPVS(I) - 2 )
*
         KVTX( 1,NVTXMX + I) = IUCOMP(LSTOUT, LSTS, NSTS)
         KVTX( 2,NVTXMX + I) = IUCOMP(LSTINC, LSTS, NSTS)
*
         KVTX( 3,NVTXMX + I) =      IQ(LPVS(I) + 2)
         KVTX( 5,NVTXMX + I) = NINT( Q(LPVS(I) + 4))
         QVTX( 6,NVTXMX + I) =       Q(LPVS(I) + 5)
         QVTX( 7,NVTXMX + I) =       Q(LPVS(I) + 6)
         QVTX( 8,NVTXMX + I) =       Q(LPVS(I) + 7)
      ENDDO
*
*--   Fill-up the VECP with ST array
      DO I = 1, NSTS
         NVECMC = NVECMC + 1
         LVECP(MTRACK+NVECMC) =  LSTS(I)
*
         LMAIN = LPHPA('MAIN',LSTS(I),0)
         VECP( 1, MTRACK + I) =  Q(LMAIN + 3)     ! Px
         VECP( 2, MTRACK + I) =  Q(LMAIN + 4)     ! Py
         VECP( 3, MTRACK + I) =  Q(LMAIN + 5)     ! Pz
         VECP( 4, MTRACK + I) =  Q(LMAIN + 6)     ! E
         VECP( 5, MTRACK + I) =  Q(LMAIN + 2)     ! Mass value
         VECP( 6, MTRACK + I) =  Q(LMAIN + 7)     ! P
         ICHA = NINT(Q(LMAIN + 8))                ! Charge
         IF ( ICHA .EQ. 0 ) THEN
            VECP( 7,MTRACK + I) = 0.
         ELSEIF ( ICHA .EQ. 1 ) THEN
            VECP( 7,MTRACK + I) = 1.
         ELSEIF ( ICHA .EQ. 2 ) THEN
            VECP( 7,MTRACK + I) =-1.
         ENDIF
         VECP( 8, MTRACK + I) =  Q(LMAIN +10)     ! Mass code
         VECP( 9, MTRACK + I) =  0.               !
         VECP(10, MTRACK + I) =  0.               !
      ENDDO
*
*--   Correspondance table sizes
      NSH = NSHS
      NLU = NSH
      IF ( NSH .GE. NVMAX ) THEN
         WRITE(*,1000) NSH,'SH',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      NST = NSTS
      IF ( NST .GE. NVMAX ) THEN
         WRITE(*,1000) NST,'ST',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
      NPA = NVECP
      IF ( NPA .GE. NVMAX ) THEN
         WRITE(*,1000) NPA,'PA',NVMAX,IIIRUN,IIIEVT,NEVENT
         GO TO 99
      ENDIF
*
*--   Correspondence table SH --> ST
      DO I = 1, NSH
         LST = LQ(LSHS(I) - 4)
         IF ( LST .EQ. 0 ) THEN
            ISHST(I) = 0
         ELSE
            ISHST(I) = IUCOMP( LST, LSTS, NSTS )
         ENDIF
      ENDDO
*
*--   Correspondence table ST --> SH
      DO I = 1, NST
         LSH = LQ(LSTS(I) - 3)
         IF ( LSH .EQ. 0 ) THEN
            ISTSH(I) = 0
         ELSE
            ISTSH(I) = IUCOMP( LSH, LSHS, NSHS )
         ENDIF
      ENDDO
*
*--   Correspondence table ST --> PA
      DO I = 1, NST
         LPA = LQ(LSTS(I) - 2)
         IF ( LPA .EQ. 0 ) THEN
            ISTPA(I) = 0
         ELSE
            ISTPA(I) = IUCOMP( LPA, LVECP, NVECP )
         ENDIF
      ENDDO
*
*--   Correspondence table PA --> ST
      DO I = 1, NVECP
         LST=0
         IF (LVECP(I).GT.0) LST = LQ(LVECP(I) - 2)
         IF ( LST .EQ. 0 ) THEN
            IPAST(I) = 0
         ELSE
            IPAST(I) = IUCOMP( LST, LSTS, NSTS )
         ENDIF
      ENDDO
*
*--   Correspondence table LU --> ST
      DO I = 1, NLU
         ILUST(I) = ISHST(ILUSH(I))
      ENDDO
*
*--   Correspondence table ST --> LU
      DO I = 1, NST
         IF ( ISTSH(I) .EQ. 0 ) THEN
            ISTLU(I) = 0
         ELSE
            ISTLU(I) = ISHLU(ISTSH(I))
         ENDIF
      ENDDO
*
*--   Correspondance table ST --> VX
      DO I = 1, NSTS
         ISTVX(1,I) = IUCOMP( LQ(LSTS(I)+1), LPVS, NPVS )
         ISTVX(2,I) = IUCOMP( LQ(LSTS(I)-1), LPVS, NPVS )
      ENDDO
*
   99 CONTINUE
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSFULL-E-PSFSIM, ',I4,' ',A2,' banks, limit at',I4
     +      ,/,1X,'                  ',' Run',I7,', Event',I6,'/',I6,/)
      END
*
+PATCH,PSUTYL.==========================================================
+DECK,PSSORT. **********************************************************
      SUBROUTINE PSSORT ( ARRAY, ARRSIZ, NA, IORDER, IERR)
************************************************************************
*                                                                      *
*     Name           :  PSSORT                                         *
*     Called by      :  SKELANA                                        *
*     Date of coding :  May 08, 1994                                   *
*     Last update    :  Apr 26, 1995                                   *
*     Task           :  To sort-out something                          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
*--   arguments
      INTEGER ARRAY(*), ARRSIZ, NA, IORDER(*), IERR
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER    NINIT
      PARAMETER (NINIT = 20)
      INTEGER    NPMAX
      PARAMETER (NPMAX = 4000)
*
      INTEGER INITPA(NINIT),NI
      INTEGER LF(NPMAX), LB(NPMAX)
      INTEGER I, M, J, JT
*
      IERR = 0
*
*--   Set pseudolinks for initial particles
      NI = 0
      DO I = 1, NA
         IF ( ARRAY(I) .EQ. 0 ) THEN
            IF ( NI .LT. NINIT ) THEN
               NI = NI + 1
               INITPA(NI) = I
            ELSE
               WRITE(*,*) '%PHDST-E-PHSORT, Too many initial particles'
               GO TO 99
            ENDIF
         ENDIF
      ENDDO
*
      DO I = 1, NI-1
         ARRAY(ARRSIZ + INITPA(I)) = INITPA(I+1)
      ENDDO
*
*--   Topological sorting
      IF ( NA .GT. NPMAX ) THEN
        WRITE(*,*) '%PHDST-E-PHSORT, Internal error:'
        WRITE(*,*) '                 Unsufficient local memory'
        WRITE(*,*) '                 User is asking for ',NA,' words'
        RETURN
      END IF
*
      CALL vzeroi(LF,NA)
      CALL vzeroi(LB,NA)
*
*--   Set forward/backward sister links
      DO I = 1, NA
        LF(I) = ARRAY(ARRSIZ + I)
        IF ( LF(I) .NE. 0 ) THEN
           LB( LF(I) ) = I
        ENDIF
      END DO
*
*--   Set forward/backward mother-daughter links
      DO I = 1, NA
         IF ( LB(I) .EQ. 0 ) THEN
            J = 0
            M = ARRAY(I)
            IF ( M .NE. 0 ) THEN
               DO WHILE ( LF(M) .NE. 0 )
                  J = J + 1
                  IF ( J .GT. 1000 ) THEN
                     IERR = -1
                     RETURN
                  ENDIF
                  M = LF(M)
               ENDDO
               LF(M) = I
               LB(I) = M
            ENDIF
         ENDIF
      ENDDO
*
*--   Convert links into a table
      JT = IUCOMP ( 0, LB(1), NA )
      IF ( JT .EQ. 0 ) WRITE(*,*)
     +  '%PHDST-E-PHSORT, Start of sequence not found'
*
      DO I = 1, NA
         IORDER(I) = JT
         JT = LF(JT)
      ENDDO
*
   99 CONTINUE
      END
*
+DECK,PSPGBM.***********************************************************
      SUBROUTINE PSPGBM ( RBEAM, PERPRI, PERPRF )
************************************************************************
*                                                                      *
*     Name           : PSPGBM                                          *
*     Called by      : SKELANA                                         *
*     Date of coding : Oct 26, 1991                                    *
*     Last update    : Nov 05, 1995                                    *
*     Task           : To calculate perigee parameters  to arbitrary   *
*                      point from perigee parameters relative to the   *
*                      origin (modified from VDPGBM in VDCLAP)         *
*                                                                      *
*     Input          : RBEAM (2) - xy of point for closest approach    *
*                      PERPRI(5) - perigee parameters (epsilon,z,theta,*
*                                  phi,1/R) relative to origin (0,0)   *
*                                                                      *
*     Output         : PERPRF(5) - perigee parameters (epsilon,z,theta,*
*                                  phi,1/R) relative to RBEAM          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
*--   arguments
      REAL RBEAM(2),PERPRI(5),PERPRF(5)
*
*--   local variables
      REAL RPARI(6),RPARF(6)
*
*--   Check for no extrapolation
      IF ( RBEAM(1) .EQ. 0.  .AND.
     +     RBEAM(2) .EQ. 0. ) THEN
         CALL ucopyr( PERPRI, PERPRF, 5 )
         GO TO 99
      ENDIF
*
*--   Find point of track start
      RPARI(1) = PERPRI(1)*SIN(PERPRI(4))
      RPARI(2) =-PERPRI(1)*COS(PERPRI(4))
      RPARI(3) = PERPRI(2)
      RPARI(4) = PERPRI(3)
      RPARI(5) = PERPRI(4)
      RPARI(6) = PERPRI(5)
*
*--   Find position of closest approach
      CALL PSRDCA( RBEAM, RPARI, RPARF )
*
*--   Find perigee parameters at p.c.a.
      IF ( ABS(SIN(RPARF(5)) ) .GE. 0.7 ) THEN
         PERPRF(1) = (RPARF(1)-RBEAM(1))/SIN(RPARF(5))
      ELSE
         PERPRF(1) =-(RPARF(2)-RBEAM(2))/COS(RPARF(5))
      ENDIF
*
      PERPRF(2) = RPARF(3)
      PERPRF(3) = RPARF(4)
      PERPRF(4) = RPARF(5)
      PERPRF(5) = RPARF(6)
*
   99 CONTINUE
      END
*
+DECK,PSRDCA.***********************************************************
      SUBROUTINE PSRDCA( RBEAM, RPARI, RPARF )
************************************************************************
*                                                                      *
*     Name           : PSRDCA                                          *
*     Called by      : PSPGBM                                          *
*     Date of coding : Oct 26, 1991                                    *
*     Last update    : Nov 05, 1995                                    *
*     Task           : To calculate the basic general positions        *
*                      of closest approach, including curvature        *
*                      (modified from VDRDCA in VDCLAP)                *
*                                                                      *
*     Input          : RBEAM(2) - xy of point for closest approach     *
*                      RPARI(6) - x,y,z,theta,phi,1/R for tracks       *
*                                                                      *
*     Output         : RPARF(5) - x,y,z,theta,phi,1/R at position      *
*                                 of closest approach                  *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
*--   arguments
      REAL RBEAM(2),RPARI(6),RPARF(6)
*
*--   local variables
      DOUBLE PRECISION DBEAM(2),DPARI(6),DPARF(6),SP,CP,DKSINT,DIST
*
*--   Convert to double precision
      DBEAM(1) = DBLE( RBEAM(1) )
      DBEAM(2) = DBLE( RBEAM(2) )
      CALL UDBLE( RPARI, DPARI, 6 )
*
*--   Get some sin and cos variables
      SP = (DPARI(1)-DBEAM(1))*COS(DPARI(5))
     &    +(DPARI(2)-DBEAM(2))*SIN(DPARI(5))
      CP = (DPARI(1)-DBEAM(1))*SIN(DPARI(5))
     &    -(DPARI(2)-DBEAM(2))*COS(DPARI(5))
*
*--   Check for zero curvature
      IF ( DPARI(6) .NE. 0.0D0 ) THEN
*
*--      Find distance of extrapolation
         DKSINT = ATAN2 (-DPARI(6)*SP,1.0D0-DPARI(6)*CP)
         DIST   = DKSINT/(DPARI(6)*SIN(DPARI(4)))
*
*--     Find position of closest approach
        DPARF(1) = DPARI(1)+COS(DPARI(5))*SIN(DKSINT)/DPARI(6)
     &             -2.0D0*SIN(DPARI(5))*
     &             SIN(0.5D0*DKSINT)*SIN(0.5D0*DKSINT)/DPARI(6)
        DPARF(2) = DPARI(2)+SIN(DPARI(5))*SIN(DKSINT)/DPARI(6)
     &             +2.0D0*COS(DPARI(5))*
     &             SIN(0.5D0*DKSINT)*SIN(0.5D0*DKSINT)/DPARI(6)
        DPARF(3) = DPARI(3)+DIST*COS(DPARI(4))
*
*--   For straight line, equations are simpler
      ELSE
        DPARF(1) = DPARI(1)-SP*COS(DPARI(5))
        DPARF(2) = DPARI(2)-SP*SIN(DPARI(5))
        DPARF(3) = DPARI(3)-SP*COS(DPARI(4))/SIN(DPARI(4))
        DKSINT   = 0.0D0
      ENDIF
*
*--   Find other parameters at p.c.a.
      DPARF(4) = DPARI(4)
      DPARF(5) = DPARI(5) + DKSINT
      DPARF(6) = DPARI(6)
*
*--   Convert back to single precision
      CALL UREAL( DPARF, RPARF, 6 )
*
      END
*
+PATCH,PSTRAC.==========================================================
+DECK,PSHSCT. **********************************************************
      SUBROUTINE PSHSCT(I,ICUT,IREJ)
************************************************************************
*                                                                      *
*     Name           :  PSHSCT                                         *
*     Called by      :  PSHORTSEL                                      *
*     Task           :  To select charged tracks with a given cut      *
*                                                                      *
*     Input          :  I    - VECP index                              *
*                       ICUT - selection criteria                      *
*                              = 1 for old skelana selection (pre '98) *
*                             >= 2 for new standard selection          *
*                                                                      *
*     Output         :  IREJ - rejection/selection flag :              *
*                              = 0 if track is selected                *
*                              > 0 if track is rejected                *
*                                                                      *
*                       ICTFAIL Bit pattern:                           *
*                               1 - main module                        *
*                               2 - low momentum                       *
*                               3 - trk length                         *
*                               4 - cos theta                          *
*                               5 - impact parameters Rphi             *
*                               6 - impact parameters Z                *
*                               7 - high momentum                      *
*                               8 - Dp/p                               *
*                               9 - VD only                            *
*                              10 - IDVD w/o Z                         *
*                                                                      *
*                              20+ - used by recovery routine          *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, PSCEVT.
+CDE, PSCVEC.
+CDE, PSCTRA.
+CDE, PSCUTT.
+CDE, PSCVTX.
+CDE, PSCBSP.
+CDE, TRACKNTP.
*
*--   arguments
      INTEGER I,ICUT,IREJ
*
*--   functions
      INTEGER LPHPA,JBYT
*
*--   local variables
      INTEGER LMAIN,LPA
      REAL    ENRTRK
      REAL    VCOV(6),DCA(4)
*
      IREJ = 0
      ICTFAIL=0
*
      LPA=LVECP(I)
*--   "MAIN" extra-module (0)
      LMAIN  = LPHPA('MAIN',LPA,0)
      IF ( LMAIN .LE. 0 ) THEN
         CALL SBIT1(ICTFAIL,1)
         GOTO 98
      ENDIF
*
*--   Momentum cut
      CTMOM = VECP(6,I)
      IF ( CTMOM .LT. TRKMOM(ICUT) )  CALL SBIT1(ICTFAIL,2)
*
*--   Track length
      CTLEN = ABS(QTRAC(24,I))
      IF ( CTLEN.LT.TRKLEN(ICUT) )    CALL SBIT1(ICTFAIL,3)
*
*--   Cos(theta) of the track
      CTCOS =  VECP(3,I) / VECP(6,I)
      IF(ABS(CTCOS).GT.TRCCOS(ICUT))  CALL SBIT1(ICTFAIL,4)
*
*--   Impact parameters (Rphi,Zimp)
      CTTHETA = ACOS (CTCOS)
      IF ( KVTX(16,1) .LE. 0 ) THEN
*     Primary vertex
        CTRPIP  = QTRAC(38,I)
        CTZIP   = QTRAC(39,I)
      ELSE
*     Beamspot
        CALL vfillr( VCOV, 6,    0.)
        CALL vfillr(  DCA, 4, -999.)
        CALL TBDCAE( QTRAC(4,I), XYZBS, VCOV, DCA )
        CTRPIP = DCA(1)
        CTZIP  = DCA(2)
      ENDIF
      IF(ABS(CTRPIP).GT.TRKRPH(ICUT)) CALL SBIT1(ICTFAIL,5)
      IF ( CTTHETA .GT. 0. ) THEN
        IF(ABS(CTZIP).GT.TRKZET(ICUT)/SIN(CTTHETA))
     +                                CALL SBIT1(ICTFAIL,6)
      ENDIF
*
*--   Excessively high momentum
      IF ( CTMOM .GE. TRKMAX(ICUT)*EBEAM )     CALL SBIT1(ICTFAIL,7)
*
*--   Energy error - Deltap/p < 100 %
      ENRTRK = CTMOM
      ENRTRK = MIN(ENRTRK,EBEAM)
      CTDELTE= QTRAC(41,I)
      IF ( CTDELTE/ENRTRK .GT. TRKERR(ICUT) )   CALL SBIT1(ICTFAIL,8)
*
*--   Drop VD only tracks with and without Z
      ICTVDONLY = JBYT(IQ(LPA+3), 19, 7)
      IF(VDONLY(ICUT).GT.1.AND.ICTVDONLY .EQ. 75 )
     +  CALL SBIT1(ICTFAIL,9)   ! VD only with Z                                          
      IF (ISVER.LT.107) THEN
        IF (VDONLY(ICUT).GT.0.AND.ICTVDONLY .EQ. 77 )
     +    CALL SBIT1(ICTFAIL,9) ! VD only without Z
      ELSE
        IF (VDONLY(ICUT).GT.1.AND.ICTVDONLY .EQ. 77 )
     +    CALL SBIT1(ICTFAIL,9) ! VFT only
      ENDIF
*
*--   Drop ID+VD only tracks without Z
      IF (IDVDWZ(ICUT).GT.0) THEN
        IF (ISVER.LT.107) THEN
          ICTIDVDWZ = JBYT(IQ(LPA+3), 19, 7)
          IF ( ICTIDVDWZ .EQ. 72 )  CALL SBIT1(ICTFAIL,10)
C        ELSE
C          ICTIDVDWZ = MOD(NINT(Q(LMAIN+28)),10000)/1000
C          IF ( ICTIDVDWZ .EQ.  9 )  CALL SBIT1(ICTFAIL,10)
        ENDIF
      ENDIF

 98   CONTINUE
*--   Reject tracks
      IF (ICTFAIL.NE.0) IREJ=1
*
   99 CONTINUE
      END
*
+DECK,PSHSNT. **********************************************************
      SUBROUTINE PSHSNT(I,ICUT,IREJ)
************************************************************************
*                                                                      *
*     Name           :  PSHSNT                                         *
*     Called by      :  PSHORTSEL, PSHCTRECCAL                         *
*                                                                      *
*     Task           :  To select neutral tracks with a given cut      *
*                                                                      *
*     Input          :  I  - VECP index                                *
*                       ICUT - selection criteria                      *
*                              = 1 for old skelana selection (pre '98) *
*                             >= 2 for new standard selection          *
*                                                                      *
*     Output         :  IREJ - rejection/selection flag :              *
*                              = 0 if track is selected                *
*                              > 0 if track is rejected                *
*                                                                      *
*                                                                      *
*                       INTFAIL Bit pattern:                           *
*                               1 - main module                        *
*                               2 - theta track                        *
*                               3 - HPC                                *
*                               4 - FEMC                               *
*                               5 - HAC                                *
*                               6 - STIC                               *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PXCONS.
+CDE, PSCVEC.
+CDE, PSCUTT.
+CDE, PSCEMF.
+CDE, PSCHPC.
+CDE, PSCHAC.
+CDE, PSCSTC.
+CDE, TRACKNTP.
*
*--   arguments
      INTEGER I,ICUT,IREJ
*
*--   functions
      INTEGER LPHPA,JBIT,JBYT
*
*--   local variables
      INTEGER LPA,LMAIN,LHAC
      INTEGER IHCNOISE,ISTNOISE
*
      IREJ = 0
      INTFAIL = 0
*
*--   "MAIN" extra-module (0)
      LPA = LVECP(I)
      LMAIN = LPHPA('MAIN',LPA,0)
      IF ( LMAIN .LE. 0 ) THEN
         CALL SBIT1(INTFAIL,1)
         GOTO 98
      ENDIF
*
*--   Cos(theta) of the track
      IF (VECP(6,I).NE.0)
     +   RNTCOS =  VECP(3,I) / VECP(6,I)
      IF(ABS(RNTCOS).GT.TRNCOS(ICUT)) CALL SBIT1(INTFAIL,2)
*
*--   Keep neutrals without cal. deposit:
*     - converted photons in front of TPC
*     - converted photons behind   of TPC
*     - clean pi0's
*     - V0 incomings
      INTCODE = JBYT( IQ(LPA+3), 19, 7 )
      IF ( INTCODE .NE. 0 ) THEN
         IF ( (INTCODE .GE.  21  .AND.
     +         INTCODE .LE.  24) .OR.
     +        (INTCODE .GE.  50  .AND.
     +         INTCODE .LE.  58) .OR.
     +         INTCODE .EQ. 101  .OR.
     +         INTCODE .EQ. 111  .OR.
     +         INTCODE .EQ. 112 ) GO TO 98
      ENDIF
*
*--   Energy cuts of the neutral tracks
      E_HPC  = QHPC (8,I)
      E_EMF  = QEMF (8,I)
      E_HCAL = QHAC (8,I)
      E_STIC = QSTIC(1,I)
*
      INTDET= IQ(LPA+2) ! detector identification word
      IF ( JBIT(INTDET, 10) .EQ. 1 ) THEN ! HPC
         IF ( E_HPC .LT.  EHPC(ICUT) ) CALL SBIT1(INTFAIL,3)
      ENDIF
*
      IF ( JBIT(INTDET, 27) .EQ. 1 ) THEN ! FEMC
         IF ( E_EMF .LT. EFEMC(ICUT) ) CALL SBIT1(INTFAIL,4)
      ENDIF
*
*--   HCAL noise
      IF ( JBIT(INTDET   , 14) .EQ. 1   .OR.
     +     JBIT(IQ(LPA+2), 23) .EQ. 1 ) THEN
         IF ( E_HCAL .LT.  EHAC(ICUT) ) CALL SBIT1(INTFAIL,5)
         IF ( IHADRJ(ICUT) .GT. 0 ) THEN
            LHAC = LPHPA('HCAL', LPA, 0)
            IF ( LHAC .GT. 0 ) THEN
               CALL HCSTAT( LHAC, IHCNOISE )
               ! reject only definite noise
               IF (IHADRJ(ICUT).EQ.1 .AND. IHCNOISE.EQ.2)
     +             CALL SBIT1(INTFAIL,5)
               ! reject all possible noise
               IF (IHADRJ(ICUT).EQ.2 .AND. IHCNOISE.GT.0)
     +             CALL SBIT1(INTFAIL,5)
            ENDIF
         ENDIF
      ENDIF
*
      IF ( JBIT(IQ(LPA+2), 19) .EQ. 1 ) THEN ! STIC
* energy cut
* or
         IF ( (E_STIC .LT.  ESTIC(ICUT)) .OR.
     &        (QSTIC(1,I).GT.2. .AND. KSTIC(4,I).EQ.1 ) )
     &      CALL SBIT1(INTFAIL,6)
         IF (ISTOEL(ICUT).GT.0) THEN
            CALL VETOFFELE(I, ISTNOISE ) ! STIC noise
            IF (ISTNOISE .GT. 0) CALL SBIT1(INTFAIL,6)
         ENDIF
      ENDIF
*
   98 CONTINUE
*--   Reject tracks
      IF (INTFAIL.NE.0) IREJ=1
*
   99 CONTINUE
      END
*
+DECK, VETOFFELE. ******************************************************
      SUBROUTINE VETOFFELE(I,ISTAT )
************************************************************************
*                                                                      *
*     Name           : VETOFFELE
*     Called by      : PSHSNT
*                      Algorithm by Vincent Hedberg, (implement CJP)
*     Task           : Reject off-momentum electrons in the STIC
*     Input          : I, VECP index
*     Output         : ISTAT - 1 if reject, 0 - if keep
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCVEC.
+CDE, PSCSTC.
+CDE, PXCONS.
*
*--   arguments
      INTEGER ISTAT, I
*
      ISTAT=0
      IF ( QSTIC(2,I)*180./PI .LT.   3.  .OR.
     +     QSTIC(2,I)*180./PI .GT. 177. ) ISTAT=1
*
      END
*
+DECK,PSHSCTRECOVER. ****************************************************
      SUBROUTINE PSHSCTRECOVER(I,ICUT,IREJ)
************************************************************************
*                                                                      *
*     Name       : PSHSCTRECOVER
*     Called by  : PSHORTSEL
*     Task       :
*  Simple recovery routine for initially rejected charged tracks
*  INPUTS - I VECP index, ICUT selection flag
*  OUTPUTS - IREJ, 1 not recovered, 0 recovered, -1 to be recovered as neutral
*  if the track is recovered ICTFAIL bits greater than 20 are set
*  bits:
*  20 - calorimeter deposits
*  21 - refit with beamspot constraint
*  22 - mammoth recovery
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCVEC.
+CDE, TRACKNTP.
+CDE, PSCFLG.
* arguments
      INTEGER I,ICUT
* local
      INTEGER IREJ
* functions
      INTEGER JBIT

      IREJ=1 ! assume track has been rejcted

      IF (MOD(IFLRVR,10).EQ.1) THEN
* For unphysical high p tracks
        IF (JBIT(ICTFAIL,7).EQ.1) THEN
          CALL PSHCTRECPBS(I,IREJ,ICUT)
          IF (IREJ.EQ.0) CALL SBIT1(ICTFAIL,21)
        ENDIF
      ENDIF

* Mammoth recovery
      IF (MOD(IFLRVR,100).GE.10) THEN
        IF (IREJ.EQ.1.AND.
     +    JBIT(ICTFAIL,5).EQ.0.AND.JBIT(ICTFAIL,6).EQ.0) THEN
*  do not apply if failed IP cuts
          CALL PSHCTRECMAM(I,IREJ) ! Mammoth created particles
          IF (IREJ.EQ.0) CALL SBIT1(ICTFAIL,22)
        ENDIF
      ENDIF

* create neutrals
      IF (IFLRVR.GE.100) THEN
        IF (IREJ.EQ.1) THEN
          CALL PSHCTRECCAL(I,ICUT,IREJ) ! use calorimeter deposits
          IF (IREJ.EQ.0) THEN
            CALL SBIT1(ICTFAIL,20)
            IREJ = -1
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END
*
+DECK,PSHCTRECCAL. *****************************************************
      SUBROUTINE PSHCTRECCAL(I,ICUT,IREJ)
************************************************************************
*                                                                      *
*     Name       : PSHCTRECCAL                                         *
*     Called by  : PSHSCTRECOVER                                        *
*     Task       : Calorimeter deposits Rescaling                      *
*                  i.e. is this track acceptable as a neutral          *
*     Input      : I VECP index, ICUT selection flag
*     Output     : IREJ, 1 not recovered, 0 recovered
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PSCVEC.
+CDE, PSCVECJJ.
+CDE, TRACKNTP.
+CDE, PSCUTT.
*--   arguments
      INTEGER I,ICUT,IREJ
*
*--   function
      INTEGER JBIT
*
*--   local variables
      REAL PNEUT
*
      IREJ=0
*
      CALL PSHSNT(I,ICUT,IREJ) ! call standard neutral routine
*
      PNEUT=0.
      IF (JBIT(INTFAIL,3).EQ.0)
     +    PNEUT=PNEUT+E_HPC
      IF (JBIT(INTFAIL,4).EQ.0)
     +    PNEUT=PNEUT+E_EMF
      IF (JBIT(INTFAIL,5).EQ.0)
     +    PNEUT=PNEUT+E_HCAL
      IF (JBIT(INTFAIL,6).EQ.0)
     +    PNEUT=PNEUT+E_STIC
*
      IF (PNEUT.GT.RECCAL(ICUT)) THEN ! TRK recovered
        IREJ=0
        INREC = INREC+1
* save index of track and LVSELE,LVLOCK contents
* this is then recovered and set in the PSHCHREC routine
        LVECP(LVWORK+INREC) = LVECP(I)
* chged track bits
        CALL MVBITS(INTFAIL,0,10,LVSELE(LVWORK+INREC),1)
* recovery bits
        CALL MVBITS(ICTFAIL,19,3,LVSELE(LVWORK+INREC),19)
* this track is recovered
        CALL SBIT1(LVSELE(LVWORK+INREC),20)
* multi-vertex bit, remclu bit
        CALL MVBITS(LVSELE(NVECP),30,2,LVSELE(LVWORK+INREC),30)
* LVLOCK multi-vertex,remclu PA bit
        CALL MVBITS(LVLOCK(NVECP),31,1,LVLOCK(LVWORK+INREC),31)
      ELSE
        IREJ=1 ! trk not recovered
      ENDIF
*
      END
*
+DECK, PSHCTRECMAM. ****************************************************
      SUBROUTINE PSHCTRECMAM(I,IREJ)
************************************************************************
*                                                                      *
*     Name       : PSHCTRECMAM                                         *
*     Called by  : PSHSCTRECOVER                                        *
*     Task       : If the incoming mammoth track is unreliable,        *
*                  correct the momentum using the outgoing tracks      *
*     Input      : I - VECP track index                                *
*     Output     : IREJ - track rejection flag :                       *
*                         1 not recovered                              *
*                         0 recovered                                  *
*     CJP 6/99, uses CW LPV+15 word on DST added at version 1.07       *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, PSCVEC.
*
*--   arguments
      INTEGER I,IREJ
*
*--   functions
      INTEGER JBYT
*
*--   local variables
      REAL PRECOV,PFAC
      INTEGER LPV,LPA,ICODE
*
      IREJ=1
      PRECOV=0
*
*--   Check version
      IF (ISVER.LT.107) RETURN ! PV word not there previously
*
      LPA=LVECP(I)
      LPV=LQ(LPA-1)
*
*--   Use mammoth codes
      ICODE = JBYT( IQ(LPA+3), 19, 7 )
      IF  (((ICODE.GE.120).AND.(ICODE.LE.126)) ! incoming hadronic
     + .OR.((ICODE.GE.82).AND.(ICODE.LE.87))   ! kinks
     + .OR. (ICODE.EQ.99)) THEN                ! kink
*
        IF (LPV.GT.0) THEN
           PRECOV=Q(LPV+15)
           IF (PRECOV.GT.0) THEN ! track reocvered
             IREJ=0
             PFAC=PRECOV/VECP(6,I)
*--          Refill VECP with new information
             VECP(1,I)=VECP(1,I)*PFAC
             VECP(2,I)=VECP(2,I)*PFAC
             VECP(3,I)=VECP(3,I)*PFAC
             VECP(6,I)=VECP(6,I)*PFAC
             VECP(4,I)=SQRT(VECP(6,I)**2+VECP(5,I)**2)
           ENDIF
        ENDIF
      ENDIF
*
      END
*
+DECK,PSHCTRECPBS. *****************************************************
      SUBROUTINE PSHCTRECPBS(ITK,IREJ,ICUT)
************************************************************************
*                                                                      *
*     Name       : PSHCTRECBS                                          *
*     Called by  : PSHSCTRECOVER,PSHTREFT                              *
*     Task       : Refit tracks with primary vertex constraint         *
*     Input      : ITK  - track number in VECP array                   *
*                : ICUT - track cut to apply                           *
*     Output     : IREJ - 0 if track is recovered                      *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCUTT.
+CDE, PSCVTX.
+CDE, PXCONS.
+CDE, PSCTRA.
+CDE, PSCBSP.
+CDE, AAMNVX.
+CDE, PSCFLG.

*
*--   arguments
      INTEGER ITK,IREJ,ICUT
*
*--   functions
      INTEGER LPHPA
*
*--   local vaariables
      INTEGER IERROR,LMAIN,LTRAC
      REAL PABLK8(20)
      REAL VERT(3),COV_VERT(6),PC_CUT,PABLK0(31),PCHI
      REAL COV_IN(36),COV_OUT(36)
      REAL DELTP,TRAC(5),DCA(4)
      REAL WGT(15),COV(15),PERR
      REAL CONSB
*
      IREJ = 1
*
      CALL uzeror(COV_IN,1,36)
      CALL uzeror(COV_OUT,1,36)
*
*--   DELANA standard module
*
      LMAIN = LPHPA('MAIN',LVECP(ITK),0)
      IF (LMAIN.NE.0) THEN
        CALL ucopyr(Q(LMAIN+2),PABLK0,31)
      ELSE
        RETURN
      ENDIF
*
*--   TRAC x-module
*
      LTRAC = LPHPA('TRAC',LVECP(ITK),0)
      IF (LTRAC.NE.0) THEN
        CALL ucopyr(Q(LTRAC+2),PABLK8,20)
      ELSE
        RETURN
      ENDIF
*
*--   Primary vertex information (according to what chosen by the user)
*
      CALL ucopyr(QVTX(6,1),VERT,3)
      CALL ucopyr(QVTX(10,1),COV_VERT,6)
*
*--   Cut on probability for the fit
*
      PC_CUT = 1.E-2
*
      CALL CONFPV(VERT,COV_VERT,PC_CUT,PABLK8,PABLK0,
     &  COV_IN,COV_OUT,PCHI,IERROR)
*
      IF (IERROR.EQ.0) THEN
*
*--     Check dp/p and p are acceptable
*
        IF ((PABLK0(6).GE.TRKMOM(ICUT)).AND.
     +      (PABLK0(6).LT.TRKMAX(ICUT)*EBEAM)) THEN
*
          CALL ucopyr(PABLK8(6),WGT,15)
          CALL FKMI5(WGT,COV,IERROR)
          DELTP = TRKERR(ICUT)
          IF (IERROR.EQ.0) THEN
            CONSB = BMAG*CONSA
            PERR  = (CONSB/PABLK8(5)/SIN(PABLK8(3)))**2
     +              *(COV(15)/PABLK8(5)**2+
     +              COV(6)/TAN(PABLK8(3))**2+
     +              2.*COV(13)/TAN(PABLK8(3))/PABLK8(5))
            PERR  = SQRT(PERR)
            DELTP = PERR/ABS(CONSB/PABLK8(5)/SIN(PABLK8(3)))
          ENDIF
*
          IF (DELTP.LT.TRKERR(ICUT)) THEN
*
*--           Track recovered
*
            IREJ=0
          ENDIF
        ENDIF
* if trk selection is not used
        IF (IFLSTR.EQ.0) IREJ=0
      ENDIF
      IF (IREJ.EQ.1) RETURN ! trk not recovered
*
*--   Extrapolate the refit track to the primary vertex
*
      CALL PSPGBM(QVTX(6,1),PABLK8(1),TRAC)
*
*--   Refill VECP with new information
*
      VECP(4,ITK) = PABLK0(5)
      VECP(6,ITK) = PABLK0(6)
      VECP(7,ITK) = PABLK0(7)
      IF (NINT(PABLK0(7)).EQ.2) VECP(7,ITK)=-1 ! change from DST Q convention
      VECP(1,ITK) = VECP(6,ITK)*SIN(TRAC(3))*COS(TRAC(4))
      VECP(2,ITK) = VECP(6,ITK)*SIN(TRAC(3))*SIN(TRAC(4))
      VECP(3,ITK) = VECP(6,ITK)*COS(TRAC(3))
*
*--   Replace the original information coming from the TRAC module
*--   with the result of the refit
*
      CALL ucopyr(PABLK8,QTRAC(4,ITK),20)
*
*--   Impact parameters with geom. sign
*--   to the primary vertex
      CALL vfillr( DCA, 4, -999.)
      IF ( KVTX(16,1) .LE. 0 ) THEN
        CALL TBDCAE( QTRAC(4,ITK), QVTX(6,1), QVTX(10,1), DCA )
      ENDIF
      QTRAC(38,ITK) = DCA(1)
      QTRAC(39,ITK) = DCA(2)
*
*--   Impact parameters with geom. sign
*--   to the beam spot
      CALL vfillr( DCA, 4, -999.)
      CALL TBDCAE( QTRAC(4,ITK), XYZBS, COVVX, DCA )
      QTRAC(40,ITK) = DCA(1)
*
*--   Chi2 of the track fit
      QTRAC(28,ITK) = PCHI
*
*--   Error on the energy
      QTRAC(41,ITK) = PERR
*
      IREJ = 0
*
      END
*
+DECK,PSHNTRECOVER. ****************************************************
      SUBROUTINE PSHSNTRECOVER(LPA,ICUT,IREJ)
************************************************************************
*                                                                      *
*     Name       : PSHNTRECOVER                                        *
*     Called by  : PSHORTSEL                                           *
*     Task       : Recovery routine for neutral clusters               *
*                  (by default no recovery applied)                    *
*     Input      : LPA  - PA address                                   *
*                  ICUT - cut selection flag                           *
*     Output     : IREJ - track rejection flag :                       *
*                         1 not recovered                              *
*                         0 recovered                                  *
*                                                                      *
************************************************************************
      IMPLICIT NONE
*
*--   arguments
      INTEGER LPA,ICUT
      INTEGER IREJ
*
      IREJ=1 ! assume track has been rejected
*
      END
*
+DECK,PSHCHREC. ********************************************************
      SUBROUTINE PSHCHREC(LPA)
************************************************************************
*                                                                      *
*     Name       : PSHCHREC                                            *
*     Called by  :                                                     *
*     Task       : Recovery of not selected charged tracks as neutrals *
*     Input      : LPA address of the charged track                    *
*     F. Cossutti - 8/9/1999                                           *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCFLG.
+CDE, PSCVEC.
+CDE, PSCHPC.
+CDE, PSCEMF.
+CDE, PSCSTC.
+CDE, PSCHAC.
+CDE, TRACKNTP.
+CDE, PSCVECJJ.
*
*--   arguments
      INTEGER LPA
*
*--   function
      INTEGER JBIT,LPHPA
*
*--   local variables
      INTEGER I,ICUT,IREJ
      INTEGER LMAIN
      REAL PNEUT,THETA,PHI
*
      I = NVECP
      IREJ = 0
      ICUT = IFLCUT
*
      CALL PSHSNT(I,ICUT,IREJ) ! call standard neutral routine
*
      PNEUT=0.
      IF (JBIT(INTFAIL,3).EQ.0)
     +  PNEUT=PNEUT+E_HPC
      IF (JBIT(INTFAIL,4).EQ.0)
     +  PNEUT=PNEUT+E_EMF
      IF (JBIT(INTFAIL,5).EQ.0)
     +  PNEUT=PNEUT+E_HCAL
      IF (JBIT(INTFAIL,6).EQ.0)
     +  PNEUT=PNEUT+E_STIC
*
*     Define the angle of the new neutral according to the
*     shower energy deposit direction, giving priority to the first hit
*     calorimeter with a good deposit and correct the angles for the
*     beam spot position (otherwise referred to (0,0,0,)
*
      IF (E_HPC.GT.0. .AND. JBIT(INTFAIL,3).EQ.0) THEN
*
        THETA = QHPC(2,I)
        PHI = QHPC(3,I)
        CALL BEAMSPOT_CORR('HPC',THETA,PHI,-1.)
*
      ELSEIF (E_EMF.GT.0. .AND. JBIT(INTFAIL,4).EQ.0) THEN
*
        THETA = QEMF(2,I)
        PHI = QEMF(3,I)
        CALL BEAMSPOT_CORR('EMF',THETA,PHI,-1.)
*
      ELSEIF (E_STIC.GT.0. .AND. JBIT(INTFAIL,6).EQ.0) THEN
*
        THETA = QSTIC(2,I)
        PHI = QSTIC(3,I)
        CALL BEAMSPOT_CORR('STI',THETA,PHI,-1.)
*
      ELSEIF (E_HCAL.GT.0. .AND. JBIT(INTFAIL,5).EQ.0) THEN
*
        THETA = QHAC(2,I)
        PHI = QHAC(3,I)
*
      ELSE
*
        WRITE (*,1000) IIIRUN,IIIEVT
*
      ENDIF
*
*--   Fill VECP with the good shower information
*
      VECP(1,I) = PNEUT*SIN(THETA)*COS(PHI)
      VECP(2,I) = PNEUT*SIN(THETA)*SIN(PHI)
      VECP(3,I) = PNEUT*COS(THETA)
      VECP(4,I) = PNEUT
      VECP(5,I) = 0.
      VECP(6,I) = PNEUT
      VECP(7,I) = 0.
*
*--   Get the standard module info
      LMAIN = LPHPA('MAIN',LPA, 0)
*
*--   Mass code & identification
      VECP(8,I) =  Q(LMAIN+10)
      CALL MVBITS( IQ(LPA+3), 0, 18, IVECP(9,I), 0 )

*--   Fill LVSELE,LVLOCK
      LVSELE(I)=LVSELE(LVWORK+INREC)
      LVLOCK(I)=LVLOCK(LVWORK+INREC)
*
*-----------------------------------------------------------------------
 1000 FORMAT(/,1X,'%PSHORT-E-PSHCHREC, ','Run',I7,', Event',I6
     +      ,/,1X,'Recovery of a charged without good energy deposit')
      END
*
+DECK, PSHTREFT
      SUBROUTINE PSHTREFT(LPA)
************************************************************************
*     Name       : PSHTREFT
*     Called by  : PSHSCTRECOVER,PSHTREFT
*     Task       :
* Refit tracks with primary vertex constraint
*
* Input:  LPA of trk
*
************************************************************************
      IMPLICIT NONE
*I/O
      INTEGER LPA
* local
      INTEGER ICODE,IREJ,ICUT,ITK
* function
      INTEGER JBYT,JBIT
+CDE, PHCDE
+CDE, PSCFLG
+CDE, PSCVEC

      ICUT=IFLCUT
      IREJ=0
      ITK=NVECP
* refit of VD only (with Z) tracks
      IF (IFLVDR.EQ.1) THEN
         ICODE = JBYT(IQ(LPA+3), 19, 7)
         IF (ICODE.EQ.75) CALL PSHCTRECPBS(ITK,IREJ,ICUT)
      ENDIF
* refit of FCA/FCB(RIF) tracks
      IF (IFLFCT.EQ.1) THEN
         ICODE = IQ(LPA+2)
         IF (JBIT(ICODE,4 ).EQ.0 !no VD
     +  .AND.JBIT(ICODE,5 ).EQ.0 !no ID
     +  .AND.JBIT(ICODE,6 ).EQ.0 !no TPC
     +  .AND.JBIT(ICODE,9 ).EQ.0 !no OD
     +  .AND.JBIT(ICODE,21).EQ.1 !FCA
     +  .AND.JBIT(ICODE,26).EQ.1)!FCB
     +       CALL PSHCTRECPBS(ITK,IREJ,ICUT)
      ENDIF
      RETURN
      END
************************************************************************
* Full DST Routines No Longer Used
************************************************************************
+PATCH,UNUSED.==========================================================
+DECK,PSFELE. **********************************************************
      SUBROUTINE PSFELE(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFELE                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Jan  23, 1995                                  *
*     Last update    :  Mar  05, 1995                                  *
*     Task           :  To fill the Electron identification COMMONs    *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCEVT.
+CDE, ELOUTP.
+CDE, ELTKFI.
+CDE, MTRACK.
+CDE, PSCELD.
+CDE, PSCELO.
+CDE, PSCELT.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      REAL    VASUM
*
*--   local variables
      INTEGER ITAG,IVETO,IVTAG,IATAG
*
      IF ( I .EQ. 0 ) THEN
         CALL ELEPHANT
         RETURN
      ENDIF
*
*--   Tagging the electrons
      CALL ELMACO(LPA, ITAG, IVETO)
      CALL ELVLOS(IVTAG)
*
      IF ( (ITAG + IVTAG) .EQ. 0 )  IATAG = 1
      IF (         IVTAG  .EQ. 1 )  IATAG = 2
      IF (  ITAG          .NE. 0 )  IATAG = 2 + ITAG
*
*--   Electron identification
*
      KELID( 1,I) = IATAG
      KELID( 2,I) = IVETO
      QELID( 3,I) = ELPXF
      QELID( 4,I) = ELPYF
      QELID( 5,I) = ELPZF
*
      IF ( IATAG .GT. 1 ) THEN
         NELID = NELID + 1
         NELOU = NELOU + 1
*
         QELOU( 1,I) = EOVERP
         QELOU( 2,I) = ELDZS
         QELOU( 3,I) = ELDPHI
         QELOU( 4,I) = ELDFI
         QELOU( 5,I) = ELDEDX
         QELOU( 6,I) = ELEDEDX
         QELOU( 7,I) = ELNWIR
         QELOU( 8,I) = PREOVP
         QELOU( 9,I) = PRSHFI
         QELOU(10,I) = PRDZS
         QELOU(11,I) = PRDPHI
         QELOU(12,I) = PRDEDX
         QELOU(13,I) = PRDEXP
         QELOU(14,I) = PRHPC
         QELOU(15,I) = PROBEL
         QELOU(16,I) = PRNSHO
         QELOU(17,I) = PRNSOD
         QELOU(18,I) = PRRGA1
         QELOU(19,I) = PRRGA2
         QELOU(20,I) = ELEFLG
         QELOU(21,I) = ELEFIT
         QELOU(22,I) = ELZEXR0
         QELOU(23,I) = ELPHIR0
         QELOU(24,I) = ELRCON
         QELOU(25,I) = ELRICH
         QELOU(26,I) = ELHPCF
         QELOU(27,I) = ELPREF
         QELOU(28,I) = EELEC
         QELOU(29,I) = ELCURI
         QELOU(30,I) = ELCURO
         QELOU(31,I) = ELCH2I
         QELOU(32,I) = ELCH2O
         QELOU(33,I) = ELROTA
         QELOU(34,I) = ELSIGN
*
*--      Electron track refitting
*
         IF ( VASUM(ELBLK8,5) .NE. 0. ) THEN
*
            NELTR = NELTR + 1
*
            QELTR( 1,I) = ELBLK8(1)                ! R Phi imp.parameter
            QELTR( 2,I) = ELBLK8(2)                ! Z     imp.parameter
            QELTR( 3,I) = ELBLK8(3)                ! Theta
            QELTR( 4,I) = ELBLK8(4)                ! Phi
            QELTR( 5,I) = ELBLK8(5)                ! 1/R (R-curv.radius)
            CALL ucopyr(ELBLK8(6), QELTR( 6,I), 15) ! Error matrix
         ENDIF
      ENDIF
*
      END

+DECK,PSFMUO. **********************************************************
      SUBROUTINE PSFMUO(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFMUO                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  May  07, 1992                                  *
*     Last update    :  May  30, 1997                                  *
*     Task           :  To fill the Muon identification COMMONs        *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, MTRACK.
+CDE, PSCMUD.
+CDE, PSCMUV.
+CDE, PSCMUL.
+CDE, PSCMUT.
+CDE, MCLCDE.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER JBIT
*
*--   local variables
      INTEGER NMUS,LMUONS(20)
      INTEGER NMUT,LMUONT(20)
      INTEGER NMUL,LMUONL(20)
      INTEGER NMUV,LMUONV(20)
      INTEGER NMUH,LMUONH(20)
      INTEGER NS,NT,NV,NH
*
      SAVE NMUS,LMUONS
      SAVE NMUT,LMUONT
      SAVE NMUL,LMUONL
      SAVE NMUV,LMUONV
      SAVE NMUH,LMUONH
*
      IF ( I .EQ. 0 ) THEN
*
*--      Call the muon identification routines
         CALL MUCAL2(NMUS,LMUONS,NMUT,LMUONT,NMUL,LMUONL,NMUV,LMUONV)
*
*--      Call the HCAL tagging
         CALL PXHAID(1,NMUH,LMUONH)
*
         GO TO 99
      ENDIF
*
*--   Reset muon identification code
      CALL SBYT( 0, IQ(LPA+3), 1, 4 )
*
*--   Very Loose identification
      DO NV = 1, NMUTV
         IF ( LPA  .EQ.  MUTV(0,NV) ) THEN
            IF ( MUTV(10,NV) .EQ. 0 ) GOTO 99
*
            NMUVL = NMUVL + 1
*
            KMUVL( 1,I) = NINT(RMUPTV(18,NV))
            IF ( MUTV(1,NV) .EQ. 14 )
     >      KMUVL( 1,I) = KMUVL( 1,I) + 128
            QMUVL( 2,I) =      RMUTV ( 4,NV)
            QMUVL( 3,I) = FLOAT(MUTV ( 9,NV))
            QMUVL( 4,I) = FLOAT(MUTV ( 3,NV))
            QMUVL( 5,I) =      RCOVLT( 1,NV)
            QMUVL( 6,I) =      RCOVLT( 2,NV)
            QMUVL( 7,I) =      RCOVLT( 3,NV)
            QMUVL( 8,I) =      RCOVLT( 4,NV)
            QMUVL( 9,I) =      RCOVLT( 5,NV)

*--         Mass ambiguity code
            CALL SBIT1( IQ(LPA + 3), 1 )
*
*--         Loose and Standard indentification
            DO NS = 1, NMUTS
               IF ( LPA .EQ. MUTS(0,NS) ) THEN
*
                  NMULS = NMULS + 1
*
                  KMULS( 1,I) =  MUTS( 3,NS)
                  IF ( MUTS(1,NS) .EQ. 14 )
     >            KMULS( 1,I) = KMULS( 1,I ) + 128
                  QMULS( 2,I) = RMUTS( 4,NS)
                  QMULS( 3,I) = RMUTS( 5,NS)
                  IF ( MUTS(1,NS) .EQ. 14 ) THEN
                     QMULS( 4,I) =  RMUTS( 6,NS)
                     QMULS( 5,I) =  RMUTS( 7,NS)
                     QMULS( 6,I) =  RMUTS( 8,NS)
                  ENDIF
                  QMULS( 7,I) = RCOST( 1,NS)
                  QMULS( 8,I) = RCOST( 2,NS)
                  QMULS( 9,I) = RCOST( 3,NS)
                  QMULS(10,I) = RCOST( 4,NS)
                  QMULS(11,I) = RCOST( 5,NS)
*
                  IF ( MUTL(10,NS) .EQ.  1 ) THEN
*--                  Mass ambiguity code
                     CALL SBIT1( IQ(LPA + 3), 2 )
                  ENDIF
*
                  IF ( MUTS(10,NS) .EQ.  1 ) THEN
*--                  Mass ambiguity code
                     CALL SBIT1( IQ(LPA + 3), 3 )
                  ENDIF
*
               ENDIF
            ENDDO
*
*--         Tight identification
            DO NT = 1, NMUTT
               IF ( LPA .EQ. MUTT(0,NT) ) THEN
*
                  NMUTI = NMUTI + 1
*
                  KMUTI( 1,I) =  MUTT( 3,NT)
                  IF ( MUTT(1,NT) .EQ. 14 )
     >            KMUTI( 1,I) = KMUTI( 1,I) + 128.
                  QMUTI( 2,I) = RMUTT ( 4,NT)
                  QMUTI( 3,I) = RMUTT ( 5,NT)
                  QMUTI( 4,I) = RCOTT ( 1,NT)
                  QMUTI( 5,I) = RCOTT ( 2,NT)
                  QMUTI( 6,I) = RCOTT ( 3,NT)
                  QMUTI( 7,I) = RCOTT ( 4,NT)
                  QMUTI( 8,I) = RCOTT ( 5,NT)
*
                  IF ( MUTT(10,NT) .EQ.  1 ) THEN
*--                  Mass ambiguity code
                     CALL SBIT1( IQ(LPA + 3), 4 )
                  ENDIF
               ENDIF
            ENDDO
*
         ENDIF
      ENDDO
*
*--   HCAL identification
      DO NH = 1, NMUH
         IF( LPA .EQ. LMUONH(NH) ) THEN
*--        Mass ambiguity code
           CALL SBIT1(IQ(LPA + 3), 5)
         ENDIF
      ENDDO
*
*--   General muon identification
      IF ( JBIT(IQ(LPA + 3), 1) .NE. 0 ) THEN
         NMUID = NMUID + 1
         CALL MVBITS( IQ(LPA+3), 0, 5, KMUID( 1,I), 0 )
         QMUID( 2,I) = QMUVL( 2,I)
         KMUID( 3,I) = NINT(QMUVL( 3,I))
      ENDIF
*
   99 CONTINUE
      END
*

+DECK,PSFPHC. **********************************************************
      SUBROUTINE PSFPHC
************************************************************************
*                                                                      *
*     Name           :  PSFPHC                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Nov  11, 1993                                  *
*     Last update    :  Mar  19, 1995                                  *
*     Task           :  To fill the Photon converersion COMMON         *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PSCVEC.
+CDE, PSCPHC.
+CDE, PXPHOC.
*
*--   functions
      INTEGER IUCOMP
*
*--   local variables
      INTEGER I
*
      IF ( NPXPHO .GT. 0 ) THEN
         NPHOC  =  NPXPHO
*
         DO I = 1, NPHOC
*
*--         Reference links
            KPHOC( 1,I) = IUCOMP ( LPXPHO(1,I), LVECP, NVECP )
            KPHOC( 2,I) = IUCOMP ( LPXPHO(2,I), LVECP, NVECP )
            KPHOC( 3,I) = IUCOMP ( LPXPHO(3,I), LVECP, NVECP )
*
*--         Data words
            KPHOC( 4,I) = IPXPHO(1,I)
            CALL ucopyr ( RPXPHO(2,I), QPHOC( 5,I), 8 )
         ENDDO
      ENDIF
*
      END

+DECK,PSFHAC. **********************************************************
      SUBROUTINE PSFHAC(LPA,I)
************************************************************************
*                                                                      *
*     Name           :  PSFHAC                                         *
*     Called by      :  PSFULL                                         *
*     Date of coding :  Sep  03, 1993                                  *
*     Last update    :  Mar  11, 1995                                  *
*     Task           :  To fill the Hadron calorimetry COMMONs         *
*                                                                      *
*     Input          :  LPA - track address in ZEBRA structure         *
*                       I   - track index   in VECP  vector            *
*                                                                      *
************************************************************************
      IMPLICIT NONE
+CDE, PHCDE.
+CDE, PXCONS.
+CDE, PSCFLG.
+CDE, MTRACK.
+CDE, PSCHAC.
+CDE, INTVEC.
*
*--   arguments
      INTEGER LPA,I
*
*--   functions
      INTEGER LPHPA
      REAL    VMOD
*
*--   local variables
      INTEGER LMAIN,LHCAL,LSHOWR
      INTEGER NSHOWR,NS,NLHITS,NL
      INTEGER NLAY,NCHA,IERR,N
      REAL    ESHOWR,PMOM
*
      LOGICAL FIRST
      SAVE    FIRST
      DATA    FIRST /.TRUE./
*
      IF ( IFLHAC .EQ. 1 ) THEN
*
*--      Access the HCAL extra module
         LHCAL = LPHPA ('HCAL',LPA,0)
         IF ( LHCAL .EQ. 0 ) GO TO 99
*
         NHAC = NHAC + 1
*
         NSHOWR = NINT(Q(LHCAL + 2))
         ESHOWR = 0.
*
*--      Loop over the showers
         DO NS = 1, NSHOWR
            LSHOWR = LPHPA('HCAL.SHOWER',LHCAL,NS)
            IF ( Q(LSHOWR + 3) .GT. ESHOWR )  THEN
               QHAC( 1,I) = Q(LSHOWR + 3)
*
               PMOM = VMOD(Q(LSHOWR+4),3)
               IF ( PMOM .GT. 0 ) THEN
                  QHAC( 2,I) = ACOS (Q(LSHOWR+6)/PMOM)
                  QHAC( 3,I) = ATAN2(Q(LSHOWR+5),Q(LSHOWR+4))
                  IF ( QHAC( 3,I) .LT. 0. )
     +            QHAC( 3,I) = QHAC( 3,I) + 2.*PI
               ENDIF
*
               KHAC( 4,I) = 0
*
*--            Loop over the layer hits
               NLHITS = NINT(Q(LSHOWR+10))
*
               DO NL = 1, NLHITS
                  NLAY =     NINT(Q(LSHOWR + 11 + 2*NL))/1000
                  NCHA = MOD(NINT(Q(LSHOWR + 11 + 2*NL)),1000)
*
                  KHAC( 5,I) = KHAC( 5,I) + NCHA
                  CALL MVBITS( MIN(NCHA,255),0,8,KHAC( 6,I),(NLAY-1)*8 )
               ENDDO
*
               ESHOWR = Q(LSHOWR + 3)
            ENDIF
*
            KHAC( 7,I) = NSHOWR
            QHAC( 8,I) = QHAC( 8,I) + Q(LSHOWR + 3)
         ENDDO
*
      ELSE
*
*--      HACCOR initialization
         IF ( I .EQ. 0 ) THEN
*
            IF ( FIRST ) THEN
               FIRST = .FALSE.
               CALL CORINI
            ENDIF
*
            CALL HCFEVT
            CALL COREVT( IERR )
            IF ( IERR .EQ.  0 ) THEN
*--            Fill-up INTVEC common
               CALL STOCOR
            ENDIF
            RETURN
         ENDIF
*
*--      Charged tracks
         DO N = 1, NCHPA
            IF ( LPA .EQ. LQPA_CH(N) .AND.
     +           NINT(XHCNC_CH(1,N)) .NE. 0) THEN
*
               NHAC = NHAC + 1
*
               QHAC( 1,I) = XHCNC_CH(3,N)
               QHAC( 2,I) = ACOS (XHCNC_CH(6,N)/VMOD(XHCNC_CH(4,N),3))
               QHAC( 3,I) = ATAN2(XHCNC_CH(5,N),XHCNC_CH(4,N))
               KHAC( 4,I) = 0
*
               NLHITS = NINT(XHCNC_CH(7,N))
*
*--            Loop over the layer hits
               DO NL = 1, NLHITS
                  NLAY =     NINT(XHCNC_CH(7+2*NL,N))/1000
                  NCHA = MOD(NINT(XHCNC_CH(7+2*NL,N)),1000)
*
                  KHAC( 5,I) = KHAC( 5,I) + NCHA
                  CALL MVBITS( MIN(NCHA,255),0,8,KHAC(6,I),(NLAY-1)*8 )
               ENDDO
            ENDIF
         ENDDO
*
*--      Old neutral tracks
*
*--      Access the HCAL extra module
         LHCAL = LPHPA ('HCAL',LPA,0)
         IF ( LHCAL .EQ. 0 ) GO TO 30
*
*--      Skip the charged tracks
         LMAIN = LPHPA('MAIN',LPA,0)
         IF(NINT(Q(LMAIN+8)) .NE. 0) GO TO 30
*
            NHAC = NHAC + 1
*
            QHAC( 1,I) = Q(LHCAL + 5)
*
            PMOM = VMOD(Q(LHCAL+6),3)
            IF ( PMOM .GT. 0. ) THEN
               QHAC( 2,I) = ACOS (Q(LHCAL+8)/PMOM)
               QHAC( 3,I) = ATAN2(Q(LHCAL+7),Q(LHCAL+6))
            ENDIF
*
            KHAC( 4,I) = 0
*
            NLHITS = NINT(Q(LHCAL +12))
*
*--         Loop over layer hits
            DO NL = 1, NLHITS
               NLAY =     NINT(Q(LHCAL +13 + 2*NL))/1000
               NCHA = MOD(NINT(Q(LHCAL +13 + 2*NL)),1000)
*
               KHAC( 5,I) = KHAC( 5,I) + NCHA
               CALL MVBITS( MIN(NCHA,255), 0, 8, KHAC(6,I), (NLAY-1)*8 )
            ENDDO
   30    CONTINUE
      ENDIF
*
   99 CONTINUE
      END
